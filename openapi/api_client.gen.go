// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	TokenScopes = "token.Scopes"
)

// Defines values for DialogLastMessageType.
const (
	DialogLastMessageTypeAudio DialogLastMessageType = "audio"
	DialogLastMessageTypeFile  DialogLastMessageType = "file"
	DialogLastMessageTypePhoto DialogLastMessageType = "photo"
	DialogLastMessageTypeText  DialogLastMessageType = "text"
	DialogLastMessageTypeVideo DialogLastMessageType = "video"
)

// Defines values for AttributeCustomModerationStatus.
const (
	New      AttributeCustomModerationStatus = "new"
	Rejected AttributeCustomModerationStatus = "rejected"
)

// Defines values for AttributeIsKworkLinksSites.
const (
	AttributeIsKworkLinksSitesN1 AttributeIsKworkLinksSites = 1
	AttributeIsKworkLinksSitesN2 AttributeIsKworkLinksSites = 2
	AttributeIsKworkLinksSitesN3 AttributeIsKworkLinksSites = 3
)

// Defines values for AttributeLang.
const (
	AttributeLangEn AttributeLang = "en"
	AttributeLangRu AttributeLang = "ru"
)

// Defines values for AttributePortfolioType.
const (
	AttributePortfolioTypeNone  AttributePortfolioType = "none"
	AttributePortfolioTypePhoto AttributePortfolioType = "photo"
	AttributePortfolioTypeVideo AttributePortfolioType = "video"
)

// Defines values for AttributeVisible.
const (
	AttributeVisibleN0 AttributeVisible = 0
	AttributeVisibleN1 AttributeVisible = 1
	AttributeVisibleN2 AttributeVisible = 2
	AttributeVisibleN3 AttributeVisible = 3
	AttributeVisibleN4 AttributeVisible = 4
)

// Defines values for FileWithMiniatureConvertStatus.
const (
	FileWithMiniatureConvertStatusDone       FileWithMiniatureConvertStatus = "done"
	FileWithMiniatureConvertStatusError      FileWithMiniatureConvertStatus = "error"
	FileWithMiniatureConvertStatusProcessing FileWithMiniatureConvertStatus = "processing"
)

// Defines values for FileWithMiniatureStatus.
const (
	FileWithMiniatureStatusActive  FileWithMiniatureStatus = "active"
	FileWithMiniatureStatusDeleted FileWithMiniatureStatus = "deleted"
)

// Defines values for FileWithSizeStatus.
const (
	FileWithSizeStatusActive  FileWithSizeStatus = "active"
	FileWithSizeStatusDeleted FileWithSizeStatus = "deleted"
)

// Defines values for KworkFileStatus.
const (
	Active  KworkFileStatus = "active"
	Deleted KworkFileStatus = "deleted"
)

// Defines values for KworkFileType.
const (
	KworkDescription KworkFileType = "kwork_description"
	KworkInstruction KworkFileType = "kwork_instruction"
)

// Defines values for PackageType.
const (
	PackageTypeMedium   PackageType = "medium"
	PackageTypePremium  PackageType = "premium"
	PackageTypeStandard PackageType = "standard"
)

// Defines values for PackageItemType.
const (
	Digit PackageItemType = "digit"
	Label PackageItemType = "label"
)

// Defines values for TrackFilesConvertStatus.
const (
	TrackFilesConvertStatusDone       TrackFilesConvertStatus = "done"
	TrackFilesConvertStatusError      TrackFilesConvertStatus = "error"
	TrackFilesConvertStatusProcessing TrackFilesConvertStatus = "processing"
)

// Defines values for VolumeTypeLang.
const (
	VolumeTypeLangEn VolumeTypeLang = "en"
	VolumeTypeLangRu VolumeTypeLang = "ru"
)

// Defines values for WantWorkerAlreadyWork.
const (
	WantWorkerAlreadyWorkN0 WantWorkerAlreadyWork = 0
	WantWorkerAlreadyWorkN3 WantWorkerAlreadyWork = 3
	WantWorkerAlreadyWorkN5 WantWorkerAlreadyWork = 5
)

// Defines values for AllowMobilePushParamsAllow.
const (
	AllowMobilePushParamsAllowN0 AllowMobilePushParamsAllow = 0
	AllowMobilePushParamsAllowN1 AllowMobilePushParamsAllow = 1
)

// Defines values for AllowPushNotificationsSoundParamsAllow.
const (
	AllowPushNotificationsSoundParamsAllowN0 AllowPushNotificationsSoundParamsAllow = "0"
	AllowPushNotificationsSoundParamsAllowN1 AllowPushNotificationsSoundParamsAllow = "1"
)

// Defines values for CatalogFiltersParamsIsSearch.
const (
	CatalogFiltersParamsIsSearchN0 CatalogFiltersParamsIsSearch = 0
	CatalogFiltersParamsIsSearchN1 CatalogFiltersParamsIsSearch = 1
)

// Defines values for ConfirmCancelOrderRequestByPayerParamsReplyType.
const (
	Agree    ConfirmCancelOrderRequestByPayerParamsReplyType = "agree"
	Disagree ConfirmCancelOrderRequestByPayerParamsReplyType = "disagree"
)

// Defines values for CreateReviewFormdataBodyType.
const (
	CreateReviewFormdataBodyTypeNegative CreateReviewFormdataBodyType = "negative"
	CreateReviewFormdataBodyTypePositive CreateReviewFormdataBodyType = "positive"
)

// Defines values for EditReviewFormdataBodyType.
const (
	EditReviewFormdataBodyTypeNegative EditReviewFormdataBodyType = "negative"
	EditReviewFormdataBodyTypePositive EditReviewFormdataBodyType = "positive"
)

// Defines values for GetInboxTracksParamsDirection.
const (
	GetInboxTracksParamsDirectionAfter  GetInboxTracksParamsDirection = "after"
	GetInboxTracksParamsDirectionAround GetInboxTracksParamsDirection = "around"
	GetInboxTracksParamsDirectionBefore GetInboxTracksParamsDirection = "before"
)

// Defines values for GetKworkReviewsParamsType.
const (
	GetKworkReviewsParamsTypeAll      GetKworkReviewsParamsType = "all"
	GetKworkReviewsParamsTypeNegative GetKworkReviewsParamsType = "negative"
	GetKworkReviewsParamsTypePositive GetKworkReviewsParamsType = "positive"
)

// Defines values for GetPaymentMethodsParamsWithCompany.
const (
	GetPaymentMethodsParamsWithCompanyN0 GetPaymentMethodsParamsWithCompany = 0
	GetPaymentMethodsParamsWithCompanyN1 GetPaymentMethodsParamsWithCompany = 1
)

// Defines values for GetTracksParamsDirection.
const (
	GetTracksParamsDirectionAfter  GetTracksParamsDirection = "after"
	GetTracksParamsDirectionAround GetTracksParamsDirection = "around"
	GetTracksParamsDirectionBefore GetTracksParamsDirection = "before"
)

// Defines values for OfferOrderOptionsParamsUpdatedPackage.
const (
	OfferOrderOptionsParamsUpdatedPackageMedium  OfferOrderOptionsParamsUpdatedPackage = "medium"
	OfferOrderOptionsParamsUpdatedPackagePremium OfferOrderOptionsParamsUpdatedPackage = "premium"
)

// Defines values for PayerBuyExtrasParamsAsVolume.
const (
	PayerBuyExtrasParamsAsVolumeN0 PayerBuyExtrasParamsAsVolume = 0
	PayerBuyExtrasParamsAsVolumeN1 PayerBuyExtrasParamsAsVolume = 1
)

// Defines values for RegisterCloudTokenParamsOs.
const (
	Android RegisterCloudTokenParamsOs = "android"
	Ios     RegisterCloudTokenParamsOs = "ios"
)

// Defines values for SetAvailableAtWeekendsParamsAvailable.
const (
	False SetAvailableAtWeekendsParamsAvailable = "false"
	True  SetAvailableAtWeekendsParamsAvailable = "true"
)

// Defines values for SetUserTypeParamsType.
const (
	N0 SetUserTypeParamsType = "0"
	N1 SetUserTypeParamsType = "1"
)

// Defines values for UserReviewsParamsType.
const (
	UserReviewsParamsTypeAll      UserReviewsParamsType = "all"
	UserReviewsParamsTypeNegative UserReviewsParamsType = "negative"
	UserReviewsParamsTypePositive UserReviewsParamsType = "positive"
)

// DialogLastMessage defines model for DialogLastMessage.
type DialogLastMessage struct {
	// FromUserId Идентификатор пользователя который отправил последнее сообщение
	FromUserId *int `json:"fromUserId,omitempty"`

	// FromUsername Имя пользователя который отправил последнее сообщение
	FromUsername *string `json:"fromUsername,omitempty"`

	// Message Текст последнего сообщения
	Message *string `json:"message,omitempty"`

	// OriginText Оригинальный текст
	OriginText *string `json:"originText,omitempty"`

	// ProfilePicture URL аватара профайла пользователя
	ProfilePicture *string `json:"profilePicture,omitempty"`

	// Time Время отправки последнего сообщения
	Time *int `json:"time,omitempty"`

	// Type Тип посленего соощения
	Type *DialogLastMessageType `json:"type,omitempty"`

	// Unread Было ли прочитано последнне сообщение
	Unread *bool `json:"unread,omitempty"`
}

// DialogLastMessageType Тип посленего соощения
type DialogLastMessageType string

// DialogMessage defines model for DialogMessage.
type DialogMessage struct {
	// ActiveOrders Данные об активных заказах между пользователями
	ActiveOrders *[]TrackOrder `json:"active_orders,omitempty"`

	// AllowedDialog Разрешено ли писать пользователю - собеседнику
	AllowedDialog *bool `json:"allowedDialog,omitempty"`

	// Archived Является ли диалог архивным или нет
	Archived *bool `json:"archived,omitempty"`

	// BlockedByUser Заблокирован ли диалог с пользователем - собеседником
	BlockedByUser *bool `json:"blocked_by_user,omitempty"`

	// Countup Количество часов до ответа, -1 - значение не задано
	Countup *int `json:"countup,omitempty"`

	// DisallowReason Причина невозможности ведения диалога
	DisallowReason *int `json:"disallowReason,omitempty"`

	// Draft Рудимент черновика
	Draft *string `json:"draft,omitempty"`

	// DraftDetails Черновики сообщений и треков
	DraftDetails *InboxAndTrackDraft `json:"draft_details,omitempty"`

	// HasActiveOrder Есть ли активный заказ среди собеседников
	HasActiveOrder *bool `json:"has_active_order,omitempty"`

	// HasAnswer Был ли ответ в диалоге пользователей
	HasAnswer *bool `json:"has_answer,omitempty"`

	// HiddenAt Время скрытия/удаления диалога
	HiddenAt *int `json:"hidden_at,omitempty"`

	// IsStarred Помечен ли диалог как избранный
	IsStarred *bool `json:"isStarred,omitempty"`

	// IsAllowCustomRequest Принимает ли пользователь запросы на индивидуальный кворк
	IsAllowCustomRequest *bool `json:"is_allow_custom_request,omitempty"`

	// IsImportant Важное ли сообщение
	IsImportant *bool `json:"is_important,omitempty"`

	// IsOnline Онлайн ли собеседник
	IsOnline *bool `json:"is_online,omitempty"`

	// IsSpam Был ли диалог помечен как спамный
	IsSpam      *bool              `json:"is_spam,omitempty"`
	LastMessage *DialogLastMessage `json:"lastMessage,omitempty"`

	// LastOnlineTime Время, когда пользователь был последний раз онлайн
	LastOnlineTime *int `json:"lastOnlineTime,omitempty"`

	// LastMessageText Текст последнего сообщения
	LastMessageText *string `json:"last_message,omitempty"`

	// Link Ссылка страницы, на которую должен попадать пользователь
	Link *string `json:"link,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что заказ не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Note Заметка о пользователе
	Note *struct {
		// PostedTimestamp Дата публикации
		PostedTimestamp *int `json:"posted_timestamp,omitempty"`

		// Text Текст заметки
		Text *int `json:"text,omitempty"`
	} `json:"note,omitempty"`

	// Profilepicture Ссылка на аватар пользователя - собеседника
	Profilepicture *string `json:"profilepicture,omitempty"`

	// Status Заглушка после удаления поля 'status'
	Status *string `json:"status,omitempty"`

	// Time Время последнего сообщения UNIXTIME
	Time *int `json:"time,omitempty"`

	// Unread Является ли последнее сообщение непричитанным
	Unread *int `json:"unread,omitempty"`

	// UnreadCount Количество непрочитанных сообщений
	UnreadCount *int `json:"unread_count,omitempty"`

	// UserId Идентификатор пользователя-собеседника
	UserId *int `json:"user_id,omitempty"`

	// Username Имя пользователя - собеседника
	Username *string `json:"username,omitempty"`

	// WarningMessageId id сообщения на которое требуется обязательный ответ
	WarningMessageId *int `json:"warning_message_id,omitempty"`

	// WarningMessageTime Таймпстемп времени, когда истекут 24 часа для срочного ответа на сообщение
	WarningMessageTime *int `json:"warning_message_time,omitempty"`
}

// Error Ошибка
type Error struct {
	// Error Текст ошибки
	Error *string `json:"error,omitempty"`

	// ErrorCode Код ошибки
	ErrorCode *int `json:"error_code,omitempty"`

	// Success Флаг успешности
	Success *bool `json:"success,omitempty"`
}

// InboxAndTrackDraft Черновики сообщений и треков
type InboxAndTrackDraft struct {
	// Files Прикрепленные файлы
	Files *[]struct {
		// Id Идентификатор файла
		Id *int `json:"id,omitempty"`

		// Miniature Миниатюра
		Miniature *string `json:"miniature,omitempty"`

		// Name Название
		Name *string `json:"name,omitempty"`

		// Path Путь
		Path *string `json:"path,omitempty"`
	} `json:"files,omitempty"`

	// Message Текст сообщения
	Message *string `json:"message,omitempty"`
}

// MultiError Ошибка
type MultiError struct {
	// Error Текст ошибки
	Error *string `json:"error,omitempty"`

	// ErrorCode Код ошибки
	ErrorCode *int `json:"error_code,omitempty"`

	// Errors Ошибки
	Errors *[]struct {
		Position *int    `json:"position,omitempty"`
		Target   *string `json:"target,omitempty"`
		Text     *string `json:"text,omitempty"`
	} `json:"errors,omitempty"`

	// Success Флаг успешности
	Success *bool `json:"success,omitempty"`
}

// Achievement Бейдж пользователя
type Achievement struct {
	// Description Описание
	Description *string `json:"description,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Ссылка на изображение
	ImageUrl *string `json:"image_url,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`
}

// Achievements Бейджи пользователя
type Achievements = []Achievement

// ArbitrationReason Опция в заказе
type ArbitrationReason struct {
	// Currency Валюта опции
	Currency *string `json:"currency,omitempty"`

	// Id Идентификатор опции
	Id *int `json:"id,omitempty"`

	// Name Наименование опции
	Name *string `json:"name,omitempty"`

	// Price Стоимость опции
	Price *int `json:"price,omitempty"`

	// Time Добавочная длительность к заказу
	Time *int `json:"time,omitempty"`
}

// Attribute Классификация/Атрибут
type Attribute struct {
	// Alias Алиас в каталоге
	Alias *string `json:"alias,omitempty"`

	// AllowCustom Разрешено добавление пользовательских потомков
	AllowCustom *bool `json:"allow_custom,omitempty"`

	// AllowMultiple Разрешен множественный выбор потомков
	AllowMultiple *bool `json:"allow_multiple,omitempty"`

	// BaseVolume Базовый числовой объем
	BaseVolume *int `json:"base_volume,omitempty"`

	// CategoryId Идентификатор категории
	CategoryId *int `json:"category_id,omitempty"`

	// Children Потомки
	Children *[]Attribute `json:"children,omitempty"`

	// CustomDescendantCount Количество пользовательских атрибутов среди потомков
	CustomDescendantCount *int `json:"custom_descendant_count,omitempty"`

	// CustomMaxCount Максимальное количество пользовательских потомков
	CustomMaxCount *bool `json:"custom_max_count,omitempty"`

	// CustomModerationStatus Статус модерации пользовательского
	CustomModerationStatus *AttributeCustomModerationStatus `json:"custom_moderation_status,omitempty"`

	// DemoFileUpload Разрешена загрузка демо-отчета
	DemoFileUpload *bool `json:"demo_file_upload,omitempty"`

	// Depth Глубина в дереве
	Depth *int `json:"depth,omitempty"`

	// DuplicatedAttributeId Идентификатор дублируемого атрибута
	DuplicatedAttributeId *int `json:"duplicated_attribute_id,omitempty"`

	// H1 Seo заголовок страницы
	H1 *string `json:"h1,omitempty"`

	// HintPayer Подсказка для покупателя
	HintPayer *string `json:"hint_payer,omitempty"`

	// HintVolume Подсказка по объему
	HintVolume *string `json:"hint_volume,omitempty"`

	// HintWorker Подсказка для продавца
	HintWorker *string `json:"hint_worker,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// IsClassification Является классификацией
	IsClassification *bool `json:"is_classification,omitempty"`

	// IsCustom Пользовательский
	IsCustom *bool `json:"is_custom,omitempty"`

	// IsCustomExtraDenied Запрещено добавлять пакетные доп.опции в кворке
	IsCustomExtraDenied *bool `json:"is_custom_extra_denied,omitempty"`

	// IsDuplicatedChildrenOnly Все потомки дубли
	IsDuplicatedChildrenOnly *bool `json:"is_duplicated_children_only,omitempty"`

	// IsFreePrice Свободная цена
	IsFreePrice *bool `json:"is_free_price,omitempty"`

	// IsKworkLinksSites Необходимость предоставления списка ссылок - 1, доменов - 2, сайтов - 3
	IsKworkLinksSites *AttributeIsKworkLinksSites `json:"is_kwork_links_sites"`

	// IsSmmHide Является ли скрываемым по логике SMM
	IsSmmHide *bool `json:"is_smm_hide,omitempty"`

	// IsSubscribePrice Цена по подписке
	IsSubscribePrice *bool `json:"is_subscribe_price,omitempty"`

	// KworksCount Количество активных кворков в которых используется атрибут
	KworksCount *int `json:"kworks_count,omitempty"`

	// Lang Язык
	Lang *AttributeLang `json:"lang,omitempty"`

	// MaxVolume Максимальный числовой объем
	MaxVolume *int `json:"max_volume,omitempty"`

	// MaxVolumeTypeId Идентификатор типа максимального числовой объема
	MaxVolumeTypeId *int `json:"max_volume_type_id,omitempty"`

	// MetaDescription Значение для meta тега description
	MetaDescription *string `json:"meta_description,omitempty"`

	// MetaTitle Значение для meta тега title
	MetaTitle *string `json:"meta_title,omitempty"`

	// MinVolume Минимальный числовой объем
	MinVolume *int `json:"min_volume,omitempty"`

	// MinVolumeTypeId Идентификатор типа минимального числовой объема
	MinVolumeTypeId *int `json:"min_volume_type_id,omitempty"`

	// MultipleMaxCount Максимальное количество выбранных потомков
	MultipleMaxCount *int `json:"multiple_max_count,omitempty"`

	// NoteWorker Комментарий для продавца
	NoteWorker *string `json:"note_worker,omitempty"`

	// OrderIndex Приоритет сортировки
	OrderIndex *int `json:"order_index,omitempty"`

	// OrdersInprogressLimit Количество заказов кворка, при котором он становится на паузу
	OrdersInprogressLimit *int `json:"orders_inprogress_limit,omitempty"`

	// OrdersInprogressPauseOff Количество заказов кворка, при котором он снимается с паузы
	OrdersInprogressPauseOff *int `json:"orders_inprogress_pause_off,omitempty"`

	// ParentId Идентификатор родителя
	ParentId *int `json:"parent_id,omitempty"`

	// ParentPortfolio Отображать портфолио на странице мои портфолио (унаследовано)
	ParentPortfolio *bool `json:"parent_portfolio,omitempty"`

	// PercentUsage Процент использования в кворках
	PercentUsage *string `json:"percent_usage,omitempty"`

	// Portfolio Отображать портфолио на странице мои портфолио
	Portfolio *bool `json:"portfolio,omitempty"`

	// PortfolioType Разрешено портфолио
	PortfolioType *AttributePortfolioType `json:"portfolio_type,omitempty"`

	// Required Обязателен выбор потомков при редактировании
	Required *bool `json:"required,omitempty"`

	// Title Название
	Title *string `json:"title,omitempty"`

	// TwinId Идентификатор атрибута близнеца в другом языке
	TwinId *int `json:"twin_id,omitempty"`

	// Unembedded Отображать невложенным в основное дерево
	Unembedded *bool `json:"unembedded,omitempty"`

	// Visible Видимость
	Visible *AttributeVisible `json:"visible,omitempty"`

	// VolumeTypeId Идентификатор числового объема
	VolumeTypeId *int `json:"volume_type_id,omitempty"`
}

// AttributeCustomModerationStatus Статус модерации пользовательского
type AttributeCustomModerationStatus string

// AttributeIsKworkLinksSites Необходимость предоставления списка ссылок - 1, доменов - 2, сайтов - 3
type AttributeIsKworkLinksSites int

// AttributeLang Язык
type AttributeLang string

// AttributePortfolioType Разрешено портфолио
type AttributePortfolioType string

// AttributeVisible Видимость
type AttributeVisible int

// Attributes Классификации/Атрибуты
type Attributes = []Attribute

// BalanceDeficit Нехватка денежных средств при оплате заказа
type BalanceDeficit struct {
	// Error Текст ошибки
	Error *string `json:"error,omitempty"`

	// ErrorCode Код ошибки
	ErrorCode *int `json:"error_code,omitempty"`

	// Response Массив с данными
	Response *struct {
		// Amount Сумма пополнения без комиссии, если не хватает средств
		Amount *int `json:"amount,omitempty"`

		// Currency Валюта операции
		Currency *string `json:"currency,omitempty"`

		// OrderId Идентификатор заказа
		OrderId *int `json:"orderId,omitempty"`

		// PaymentUrlWebView Ссылка для оплаты покупки кворк в WebView
		PaymentUrlWebView *string `json:"paymentUrlWebView,omitempty"`

		// PaymentTypeAvailableCollection Доступные типы оплаты для пользователя с вложенной структурой
		PaymentTypeAvailableCollection *[]PaymentType `json:"payment_type_available_collection,omitempty"`

		// ServiceFeeFixed Фиксированная сумма, прибавляемая к комиссии для типа percent_and_fixed
		ServiceFeeFixed *int `json:"service_fee_fixed,omitempty"`

		// ServiceFeeMin Фиксированная минимальная сумма сервисного сбора для типа min_or_percent, которая считается до service_fee_min_percent_sum
		ServiceFeeMin *int `json:"service_fee_min,omitempty"`

		// ServiceFeeMinPercentSum Минимальная сумма, после которой считается процент от суммы для типа min_or_percent
		ServiceFeeMinPercentSum *int `json:"service_fee_min_percent_sum,omitempty"`

		// ServiceFeePercent Процент сервисного сбора, берется всегда для типа percent_and_fixed и если сумма выше service_fee_min_percent_sum для типа min_or_percent
		ServiceFeePercent *float32 `json:"service_fee_percent,omitempty"`

		// ServiceFeeType Тип расчета комиссии. Возможные варианты: min_or_percent, percent_and_fixed
		ServiceFeeType *string `json:"service_fee_type,omitempty"`
	} `json:"response,omitempty"`

	// Success Флаг успешности
	Success *bool `json:"success,omitempty"`
}

// BudgetWithCount Диапазоны цен в фильтре проектов
type BudgetWithCount struct {
	// Boundaries Диапазон цен
	Boundaries *struct {
		// From Начало диапазона
		From *int `json:"from"`

		// To Конец диапазона
		To *int `json:"to"`
	} `json:"boundaries,omitempty"`

	// Count Количество проектов в диапазоне
	Count *int `json:"count,omitempty"`

	// Name Наименование диапазона
	Name *string `json:"name,omitempty"`
}

// CancelReason Причина отмены заказа
type CancelReason struct {
	// CommentRequired Возможность добавлять комментарии
	CommentRequired *bool `json:"commentRequired,omitempty"`

	// HideWorkerKworkByDefault По умолчанию включить галку `Скрыть кворки продавца`
	HideWorkerKworkByDefault *bool `json:"hide_worker_kwork_by_default,omitempty"`

	// Id Идентификатор причины
	Id *string `json:"id,omitempty"`

	// IsArbitragePopupAvailable Выдать окно отправки заказа в арбитраж
	IsArbitragePopupAvailable *bool `json:"is_arbitrage_popup_available,omitempty"`

	// Subtypes Достпуные дочерние причины отмены
	Subtypes *[]struct {
		// CommentRequired Возможность добавлять комментарии
		CommentRequired *bool `json:"commentRequired,omitempty"`

		// HideWorkerKworkByDefault По умолчанию включить галку `Скрыть кворки продавца`
		HideWorkerKworkByDefault *bool `json:"hide_worker_kwork_by_default,omitempty"`

		// Id Идентификатор причины отмены
		Id *string `json:"id,omitempty"`

		// IsArbitragePopupAvailable Выдать окно отправки заказа в арбитраж
		IsArbitragePopupAvailable *bool `json:"is_arbitrage_popup_available,omitempty"`

		// IsCancellationAvailable Можно ли совершить отмену
		IsCancellationAvailable *bool `json:"is_cancellation_available,omitempty"`

		// SubItems Дополнительные пункты выбора причины
		SubItems *[]struct {
			// Name Наименование типа причины
			Name *string `json:"name,omitempty"`

			// Type Тип причины
			Type *string `json:"type,omitempty"`
		} `json:"subItems,omitempty"`

		// Title Наименование причины отмены
		Title *string `json:"title,omitempty"`
	} `json:"subtypes,omitempty"`

	// Title Наименование причины
	Title *string `json:"title,omitempty"`
}

// CatalogOtherServiceBlock defines model for catalogOtherServiceBlock.
type CatalogOtherServiceBlock struct {
	// CategoryId Идентификатор категории, может быть null если это классификация
	CategoryId *int `json:"category_id"`

	// ClassifierId Идентификатор классификации, может быть null если это категория
	ClassifierId *int `json:"classifier_id"`

	// CoverUrl Путь к изображению
	CoverUrl *string `json:"cover_url,omitempty"`

	// Name Название рубрики
	Name *string `json:"name,omitempty"`

	// Order Порядок сортировки
	Order *int `json:"order,omitempty"`
}

// CatalogServiceBlock defines model for catalogServiceBlock.
type CatalogServiceBlock struct {
	// IconPath Иконка рубрики
	IconPath *string `json:"icon_path,omitempty"`

	// Id Идентификатор категории
	Id *int `json:"id,omitempty"`

	// Name Наименование
	Name *string `json:"name,omitempty"`

	// Order Порядок сортировки
	Order *int `json:"order,omitempty"`

	// RubricDescription Описание рубрики(основные категории)
	RubricDescription *string `json:"rubric_description,omitempty"`
}

// Category Категория
type Category struct {
	// Description Описание
	Description *string `json:"description,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`
}

// CategoryLevel1 defines model for categoryLevel1.
type CategoryLevel1 struct {
	// Description Описание
	Description *string `json:"description,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`

	// Subcategories Подкатегории
	Subcategories *[]CategoryLevel2 `json:"subcategories,omitempty"`
}

// CategoryLevel2 defines model for categoryLevel2.
type CategoryLevel2 struct {
	// Description Описание
	Description *string `json:"description,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`

	// Subcategories Подкатегории
	Subcategories *[]CategoryLevel3 `json:"subcategories,omitempty"`
}

// CategoryLevel3 Категория
type CategoryLevel3 = Category

// ComplainCategory Категория жалобы
type ComplainCategory struct {
	// CommentRequired Обязателен ли комментарий для данной категории жалоб
	CommentRequired *bool `json:"commentRequired,omitempty"`

	// HasNotification Название
	HasNotification *bool `json:"hasNotification,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// IsFileUploaderNotAuth Разрешено ли загружать файлы
	IsFileUploaderNotAuth *bool `json:"isFileUploaderNotAuth,omitempty"`

	// SubCategories Подкатегории жалобы
	SubCategories *[]ComplainCategory `json:"subCategories,omitempty"`

	// Title Название
	Title *string `json:"title,omitempty"`
}

// Connects Объект с коннектами
type Connects struct {
	// ActiveConnects Количество доступных коннектов
	ActiveConnects *int `json:"active_connects,omitempty"`

	// AllConnects Кол-во коннектов продавца
	AllConnects *int `json:"all_connects,omitempty"`

	// UpdateTime Дата начисления коннектов (UNIX), -1 - дата начисления не определена (выводится как Н/Д)
	UpdateTime *int `json:"update_time,omitempty"`
}

// ExchangeInfo Ключевая информации по бирже
type ExchangeInfo struct {
	// ArchivedCount Количество заархивированных проектов
	ArchivedCount *int `json:"archived_count,omitempty"`

	// ExchangeResponseCount Количество моих откликов на бирже
	ExchangeResponseCount *int `json:"exchange_response_count,omitempty"`
}

// FavoriteKworks defines model for favoriteKworks.
type FavoriteKworks struct {
	// Activity Активность для текущего юзера
	Activity *struct {
		// Earned Сколько заработано
		Earned *int `json:"earned,omitempty"`

		// Orders Количество заказов
		Orders *int `json:"orders,omitempty"`

		// Views Количество просмотров
		Views *int `json:"views,omitempty"`
	} `json:"activity,omitempty"`

	// Badges Бейджи кворка
	Badges *KworkBadges `json:"badges,omitempty"`

	// BlackFridayPrice Цена по черной пятнице
	BlackFridayPrice *int `json:"blackFridayPrice,omitempty"`

	// CategoryId ID категории
	CategoryId *int `json:"category_id,omitempty"`

	// CategoryName Название категории
	CategoryName *string `json:"category_name,omitempty"`

	// ClassificationId ID атрибута-значения классификации верхнего уровня
	ClassificationId *int `json:"classification_id,omitempty"`

	// ClassifierId ID последнего атрибута/классификации
	ClassifierId *int `json:"classifier_id,omitempty"`

	// DiscountPercentage Скидка по черной пятнице
	DiscountPercentage *int `json:"discountPercentage,omitempty"`

	// EditsList Массив строк что нужно исправить в кворке, для текущего юзера
	EditsList *[]string `json:"edits_list,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Относительный путь к обложке кворка
	ImageUrl *string `json:"image_url,omitempty"`

	// IsBlackFriday Участвует ли в черной пятнице
	IsBlackFriday *bool `json:"isBlackFriday,omitempty"`

	// IsSubscription Кворк с подпиской?
	IsSubscription *bool `json:"isSubscription,omitempty"`

	// IsBest Кворк имеет высший рейтинг
	IsBest *bool `json:"is_best,omitempty"`

	// IsFavorite Кворк в избранных у активного юзера
	IsFavorite *bool `json:"is_favorite,omitempty"`

	// IsHidden Кворк скрыт у активного юзера
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPriceFrom Необходима ли подпись 'Цена ОТ'
	IsPriceFrom *bool `json:"is_price_from,omitempty"`

	// IsViewed Просмотрен ли кворк
	IsViewed *bool `json:"is_viewed,omitempty"`

	// Lang Язык кворка, для привзяки валюты
	Lang *string `json:"lang,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Order Порядок вывода в списке
	Order *int `json:"order,omitempty"`

	// Price Стоимость кворка
	Price *int `json:"price,omitempty"`

	// StatusId Идентификатор статуса кворка
	StatusId *int `json:"status_id,omitempty"`

	// StatusName Название статуса
	StatusName *string `json:"status_name,omitempty"`

	// Title Название кворка
	Title *string `json:"title,omitempty"`

	// Worker Данные продавца
	Worker *UserWorker `json:"worker,omitempty"`
}

// FavouriteCategory Любимая рубрика пользователя
type FavouriteCategory struct {
	// Id ID категории
	Id *int `json:"id,omitempty"`

	// Name Название категории
	Name *string `json:"name,omitempty"`
}

// File Файл
type File struct {
	// Id Идентификатор файла
	Id *int `json:"id,omitempty"`

	// Name Имя файла
	Name *string `json:"name,omitempty"`

	// Path Путь к файлу
	Path *string `json:"path,omitempty"`
}

// FileWithMiniature defines model for file_with_miniature.
type FileWithMiniature struct {
	// ConvertStatus Статус конвертации голосового сообщения
	ConvertStatus *FileWithMiniatureConvertStatus `json:"convert_status,omitempty"`

	// DurationInMs Длительность голосового файла в миллисекундах
	DurationInMs *int `json:"duration_in_ms,omitempty"`

	// FileUrl Абсолютный урл файла на сервере
	FileUrl *string `json:"file_url,omitempty"`

	// Id Идентификатор файла
	Id *int `json:"id,omitempty"`

	// ImageData Данные низкокачественного изображения
	ImageData *struct {
		// Data Изображение закодированное в Base64
		Data *string `json:"data,omitempty"`

		// Height Высота
		Height *int `json:"height,omitempty"`

		// Width Ширина
		Width *int `json:"width,omitempty"`
	} `json:"imageData,omitempty"`

	// IsHeard Прослушано ли голосовое сообщение
	IsHeard *bool `json:"is_heard,omitempty"`

	// IsVoiceMessage Является ли голосовым сообщением
	IsVoiceMessage *bool `json:"is_voice_message,omitempty"`

	// MiniaturePath Путь к файлу миниатюры
	MiniaturePath *string `json:"miniature_path,omitempty"`

	// MiniatureUrl Ссылка на файл с миниатюрой
	MiniatureUrl *string `json:"miniature_url,omitempty"`

	// Name Имя файла
	Name *string `json:"name,omitempty"`

	// Path Путь к файлу
	Path *string `json:"path,omitempty"`

	// Size Размер в байтах
	Size *int `json:"size,omitempty"`

	// Status Статус
	Status *FileWithMiniatureStatus `json:"status,omitempty"`

	// Timestamp Дата создания
	Timestamp *int `json:"timestamp,omitempty"`
}

// FileWithMiniatureConvertStatus Статус конвертации голосового сообщения
type FileWithMiniatureConvertStatus string

// FileWithMiniatureStatus Статус
type FileWithMiniatureStatus string

// FileWithSize defines model for file_with_size.
type FileWithSize struct {
	// Id Идентификатор файла
	Id *int `json:"id,omitempty"`

	// Name Имя файла
	Name *string `json:"name,omitempty"`

	// Path Путь к файлу
	Path *string `json:"path,omitempty"`

	// Size Размер в байтах
	Size *int `json:"size,omitempty"`

	// Status Статус
	Status *FileWithSizeStatus `json:"status,omitempty"`

	// Timestamp Дата создания
	Timestamp *int `json:"timestamp,omitempty"`
}

// FileWithSizeStatus Статус
type FileWithSizeStatus string

// FirstLevelCategory defines model for firstLevelCategory.
type FirstLevelCategory struct {
	// CategoryImage Путь к изображению
	CategoryImage *string `json:"category_image,omitempty"`

	// Ico Иконка
	Ico *string `json:"ico,omitempty"`

	// IcoExtra Иконка png
	IcoExtra *string `json:"ico_extra,omitempty"`

	// Id Идентификатор рубрики
	Id *int `json:"id,omitempty"`

	// Name Название рубрики
	Name *string `json:"name,omitempty"`

	// Order Порядок сортировки
	Order *int `json:"order,omitempty"`

	// RubricDescription Описание
	RubricDescription *string `json:"rubric_description,omitempty"`
}

// GetMessage defines model for getMessage.
type GetMessage struct {
	// Countup Количество часов до ответа, -1 - значение не задано
	Countup *int `json:"countup"`

	// CreatedOrderId Id созданного заказа индивидуального предложения
	CreatedOrderId *int `json:"created_order_id,omitempty"`

	// CustomRequest Запрос на индивидуальный кворк
	CustomRequest *struct {
		// Budget Бюджет
		Budget *string `json:"budget,omitempty"`

		// Duration срок выполнения (секунд); null - срок не ограничен
		Duration *string `json:"duration,omitempty"`

		// NotAvailableForCompany Отображать уведомление о том, что заказ не доступен для дочерней роли покупателя 'Компания'
		NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`
	} `json:"custom_request,omitempty"`

	// Files файлы сообщения
	Files *[]FileWithMiniature `json:"files,omitempty"`

	// Forwarded Флаг является ли сообщение пересланным
	Forwarded *bool `json:"forwarded,omitempty"`

	// FromId Идентификатор пользователя отправителя
	FromId *int `json:"from_id,omitempty"`

	// FromLiveDate Дата последней активности отправителя на сайте UNIXTIME
	FromLiveDate *int `json:"from_live_date,omitempty"`

	// FromProfilepicture Ссылка на аватар отправителя
	FromProfilepicture *string `json:"from_profilepicture,omitempty"`

	// FromUsername Имя пользователя отправителя
	FromUsername *string `json:"from_username,omitempty"`

	// InboxOrder Предложение на индивидуальный кворк
	InboxOrder *InboxOrder `json:"inbox_order,omitempty"`

	// Message Текст сообщения. Возможен HTML
	Message *string `json:"message,omitempty"`

	// MessageId ID сообщений
	MessageId *int `json:"message_id,omitempty"`

	// MessagePage Страница на которой находится сообщение
	MessagePage *int `json:"message_page,omitempty"`

	// Page Номер страницы где находится сообщение
	Page *int `json:"page,omitempty"`

	// Quote Цитируемое сообщение
	Quote *struct {
		// ReplyConversationId Сквозной идентификатор цитируемого сообщения
		ReplyConversationId *int `json:"reply_conversation_id,omitempty"`

		// ReplyMessageDisplayedText Текст цитируемого сообщения
		ReplyMessageDisplayedText *string `json:"reply_message_displayed_text,omitempty"`

		// ReplyMessageFiles Файлы цитируемого изображения
		ReplyMessageFiles *[]FileWithSize `json:"reply_message_files,omitempty"`

		// ReplyMessageId Идентификатор цитируемого сообщения
		ReplyMessageId *int `json:"reply_message_id,omitempty"`

		// ReplyMessagePage Номер страницы на которой находится цитируемое сообщение
		ReplyMessagePage *int `json:"reply_message_page,omitempty"`

		// ReplyMessageThumbnail URL к миниатюре цитируемого изображения
		ReplyMessageThumbnail *string `json:"reply_message_thumbnail,omitempty"`

		// ReplyMessageThumbnailPath Путь к миниатюре цитируемого изображения
		ReplyMessageThumbnailPath *string `json:"reply_message_thumbnail_path,omitempty"`

		// ReplyUserId Идентификатор пользователя отправившего цитируемое сообщение
		ReplyUserId *int `json:"reply_user_id,omitempty"`
	} `json:"quote,omitempty"`

	// Status Заглушка после удаления поля 'status'
	Status *string `json:"status,omitempty"`

	// Time Дата сообщения UNIXTIME
	Time *int `json:"time,omitempty"`

	// ToId ID получаетеля
	ToId *int `json:"to_id,omitempty"`

	// ToLiveDate Дата последней активности получателя на сайте UNIXTIME
	ToLiveDate *int `json:"to_live_date,omitempty"`

	// ToProfilepicture Ссылка на аватар получателя
	ToProfilepicture *string `json:"to_profilepicture,omitempty"`

	// ToUsername Username получателя
	ToUsername *string `json:"to_username,omitempty"`

	// TranscriptionStatus Статус транскрибации, null - если успешно или сообщение не голосовое
	TranscriptionStatus *int `json:"transcription_status,omitempty"`

	// Type Тип сообщения: NULL - обычное сообщение,
	// 	 * 					custom_request - Запрос на индивидуальный кворк,
	// 	 * 					custom_request_new - Запрос на индивидуальный кворк с возможностью отмены,
	// 	 * 					custom_request_payer_cancel - Запрос на индивидуальный кворк отменен покупателем,
	// 	 * 					custom_request_worker_cancel - Запрос на индивидуальный кворк отменен продавцом,
	// 	 * 					offer_kwork_new - Предложение кворка,
	// 	 *     				offer_kwork_payer_cancel - Предложение индивидуального кворка отклонено покупателем,
	// 	 *     				offer_kwork_worker_cancel - Предложение индивидуального кворка отклонено продавцом,
	// 	 *     				offer_kwork_done - Заказ создан, auto - Автоуведомление, support - Сообщение от техподдержки,
	// 	 *     				report - Жалоба на пользователя
	Type *string `json:"type,omitempty"`

	// Unread Сообщение непрочитано
	Unread *bool `json:"unread,omitempty"`

	// UpdatedAt Время изменения сообщения в Unixtime, или null
	UpdatedAt *int `json:"updated_at"`

	// WarningType флаги для получение статуса игнорирования сообщения
	// 	 * 					(check — постановка сообщения на проверку, answer — на сообщение был ответ, ignore — сообщение было проигнорировано)
	WarningType *string `json:"warning_type,omitempty"`
}

// GetMessageWithTrack defines model for getMessageWithTrack.
type GetMessageWithTrack struct {
	// ConversationId ID сообщений в conversation
	ConversationId *int `json:"conversation_id,omitempty"`

	// Countup Количество часов до ответа, -1 - значение не задано
	Countup *int `json:"countup"`

	// CreatedOrderId Id созданного заказа индивидуального предложения
	CreatedOrderId *int `json:"created_order_id,omitempty"`

	// CustomRequest Запрос на индивидуальный кворк
	CustomRequest *struct {
		// Budget Бюджет
		Budget *string `json:"budget,omitempty"`

		// Duration срок выполнения (секунд); null - срок не ограничен
		Duration *string `json:"duration,omitempty"`
	} `json:"custom_request,omitempty"`

	// EntityType Тип сообщения (9 - Inbox, 10 - Track
	EntityType *int `json:"entity_type,omitempty"`

	// Files файлы сообщения
	Files *[]FileWithMiniature `json:"files,omitempty"`

	// Forwarded Флаг является ли сообщение пересланным
	Forwarded *bool `json:"forwarded,omitempty"`

	// ForwardedFromUsername Имя пользователя, от которого переслано сообщение
	ForwardedFromUsername *string `json:"forwarded_from_username,omitempty"`

	// ForwarderFromId Идентификатор пользователя, от которого переслано сообщение
	ForwarderFromId *int `json:"forwarder_from_id,omitempty"`

	// FromId Идентификатор пользователя отправителя
	FromId *int `json:"from_id,omitempty"`

	// FromLiveDate Дата последней активности отправителя на сайте UNIXTIME
	FromLiveDate *int `json:"from_live_date,omitempty"`

	// FromProfilepicture Ссылка на аватар отправителя
	FromProfilepicture *string `json:"from_profilepicture,omitempty"`

	// FromUsername Имя пользователя отправителя
	FromUsername *string `json:"from_username,omitempty"`

	// InboxOrder Предложение на индивидуальный кворк
	InboxOrder *InboxOrder `json:"inbox_order,omitempty"`

	// Message Текст сообщения. Возможен HTML
	Message *string `json:"message,omitempty"`

	// MessageId ID сообщений в Inbox/Track
	MessageId *int `json:"message_id,omitempty"`

	// MessageKey Уникальный ключ сообщения
	MessageKey *string `json:"message_key,omitempty"`

	// MessagePage Страница на которой находится сообщение
	MessagePage *int `json:"message_page,omitempty"`

	// Page Номер страницы где находится сообщение
	Page *int `json:"page,omitempty"`

	// Quote Цитируемое сообщение
	Quote *struct {
		// ReplyMessageDisplayedText Текст цитируемого сообщения
		ReplyMessageDisplayedText *string `json:"reply_message_displayed_text,omitempty"`

		// ReplyMessageFiles Файлы цитируемого изображения
		ReplyMessageFiles *[]FileWithSize `json:"reply_message_files,omitempty"`

		// ReplyMessageId Идентификатор цитируемого сообщения
		ReplyMessageId *int `json:"reply_message_id,omitempty"`

		// ReplyMessagePage Номер страницы на которой находится цитируемое сообщение
		ReplyMessagePage *int `json:"reply_message_page,omitempty"`

		// ReplyMessageThumbnail URL к миниатюре цитируемого изображения
		ReplyMessageThumbnail *string `json:"reply_message_thumbnail,omitempty"`

		// ReplyMessageThumbnailPath Путь к миниатюре цитируемого изображения
		ReplyMessageThumbnailPath *string `json:"reply_message_thumbnail_path,omitempty"`

		// ReplyUserId Идентификатор пользователя отправившего цитируемое сообщение
		ReplyUserId *int `json:"reply_user_id,omitempty"`
	} `json:"quote,omitempty"`

	// Status Заглушка после удаления поля 'status'
	Status *string `json:"status,omitempty"`

	// Time Дата сообщения UNIXTIME
	Time *int `json:"time,omitempty"`

	// ToId ID получаетеля
	ToId *int `json:"to_id,omitempty"`

	// ToLiveDate Дата последней активности получателя на сайте UNIXTIME
	ToLiveDate *int `json:"to_live_date,omitempty"`

	// ToProfilepicture Ссылка на аватар получателя
	ToProfilepicture *string `json:"to_profilepicture,omitempty"`

	// ToUsername Username получателя
	ToUsername *string `json:"to_username,omitempty"`

	// TrackOrder Данные о заказе
	TrackOrder *TrackOrder `json:"track_order,omitempty"`

	// TrackType Тип трека
	TrackType *int `json:"track_type,omitempty"`

	// TranscriptionStatus Статус транскрибации, null - если успешно или сообщение не голосовое
	TranscriptionStatus *int `json:"transcription_status,omitempty"`

	// Type Тип сообщения: NULL - обычное сообщение, custom_request - Запрос на индивидуальный кворк,
	// 	 *     offer_kwork_new - Предложение кворка, offer_kwork_payer_cancel - Предложение индивидуального кворка отклонено покупателем,
	// 	 *     offer_kwork_worker_cancel - Предложение индивидуального кворка отклонено продавцом, offer_kwork_done - Заказ создан, auto - Автоуведомление,
	// 	 *     support - Сообщение от техподдержки, report - Жалоба на пользователя
	Type *string `json:"type,omitempty"`

	// Unread Сообщение непрочитано
	Unread *bool `json:"unread,omitempty"`

	// UpdatedAt Время изменения сообщения в Unixtime, или null
	UpdatedAt *int `json:"updated_at"`

	// WarningType флаги для получение статуса игнорирования сообщения (check — постановка сообщения на проверку,
	// 	 *     answer — на сообщение был ответ, ignore — сообщение было проигнорировано)
	WarningType *string `json:"warning_type,omitempty"`
}

// InboxMessage Сообщение в переписке
type InboxMessage struct {
	// Countup Количество часов до ответа, -1 - значение не задано
	Countup *int `json:"countup"`

	// CreatedOrderId Id созданного заказа индивидуального предложения
	CreatedOrderId *int `json:"created_order_id,omitempty"`

	// CustomRequest Запрос на индивидуальный кворк
	CustomRequest *struct {
		// Budget Бюджет
		Budget *string `json:"budget,omitempty"`

		// Duration срок выполнения (секунд); null - срок не ограничен
		Duration *string `json:"duration,omitempty"`

		// NotAvailableForCompany Отображать уведомление о том, что заказ не доступен для дочерней роли покупателя 'Компания'
		NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`
	} `json:"custom_request,omitempty"`

	// Files файлы сообщения
	Files *[]FileWithMiniature `json:"files,omitempty"`

	// Forwarded Флаг является ли сообщение пересланным
	Forwarded *bool `json:"forwarded,omitempty"`

	// FromId Идентификатор пользователя отправителя
	FromId *int `json:"from_id,omitempty"`

	// FromLiveDate Дата последней активности отправителя на сайте UNIXTIME
	FromLiveDate *int `json:"from_live_date,omitempty"`

	// FromProfilepicture Ссылка на аватар отправителя
	FromProfilepicture *string `json:"from_profilepicture,omitempty"`

	// FromUsername Имя пользователя отправителя
	FromUsername *string `json:"from_username,omitempty"`

	// InboxOrder Предложение на индивидуальный кворк
	InboxOrder *InboxOrder `json:"inbox_order,omitempty"`

	// Message Текст сообщения. Возможен HTML
	Message *string `json:"message,omitempty"`

	// MessageId ID сообщений
	MessageId *int `json:"message_id,omitempty"`

	// MessagePage Страница на которой находится сообщение
	MessagePage *int `json:"message_page,omitempty"`

	// Quote Цитируемое сообщение
	Quote *struct {
		// ReplyConversationId Сквозной идентификатор цитируемого сообщения
		ReplyConversationId *int `json:"reply_conversation_id,omitempty"`

		// ReplyMessageDisplayedText Текст цитируемого сообщения
		ReplyMessageDisplayedText *string `json:"reply_message_displayed_text,omitempty"`

		// ReplyMessageFiles Файлы цитируемого изображения
		ReplyMessageFiles *[]FileWithSize `json:"reply_message_files,omitempty"`

		// ReplyMessageId Идентификатор цитируемого сообщения
		ReplyMessageId *int `json:"reply_message_id,omitempty"`

		// ReplyMessagePage Номер страницы на которой находится цитируемое сообщение
		ReplyMessagePage *int `json:"reply_message_page,omitempty"`

		// ReplyMessageThumbnail URL к миниатюре цитируемого изображения
		ReplyMessageThumbnail *string `json:"reply_message_thumbnail,omitempty"`

		// ReplyMessageThumbnailPath Путь к миниатюре цитируемого изображения
		ReplyMessageThumbnailPath *string `json:"reply_message_thumbnail_path,omitempty"`

		// ReplyUserId Идентификатор пользователя отправившего цитируемое сообщение
		ReplyUserId *int `json:"reply_user_id,omitempty"`
	} `json:"quote,omitempty"`

	// Status Заглушка после удаления поля 'status'
	Status *string `json:"status,omitempty"`

	// Time Дата сообщения UNIXTIME
	Time *int `json:"time,omitempty"`

	// ToId ID получаетеля
	ToId *int `json:"to_id,omitempty"`

	// ToLiveDate Дата последней активности получателя на сайте UNIXTIME
	ToLiveDate *int `json:"to_live_date,omitempty"`

	// ToProfilepicture Ссылка на аватар получателя
	ToProfilepicture *string `json:"to_profilepicture,omitempty"`

	// ToUsername Username получателя
	ToUsername *string `json:"to_username,omitempty"`

	// TranscriptionStatus Статус транскрибации, null - если успешно или сообщение не голосовое
	TranscriptionStatus *int `json:"transcription_status,omitempty"`

	// Type Тип сообщения: NULL - обычное сообщение,
	// 	 * 					custom_request - Запрос на индивидуальный кворк,
	// 	 * 					custom_request_new - Запрос на индивидуальный кворк с возможностью отмены,
	// 	 * 					custom_request_payer_cancel - Запрос на индивидуальный кворк отменен покупателем,
	// 	 * 					custom_request_worker_cancel - Запрос на индивидуальный кворк отменен продавцом,
	// 	 * 					offer_kwork_new - Предложение кворка,
	// 	 *     				offer_kwork_payer_cancel - Предложение индивидуального кворка отклонено покупателем,
	// 	 *     				offer_kwork_worker_cancel - Предложение индивидуального кворка отклонено продавцом,
	// 	 *     				offer_kwork_done - Заказ создан, auto - Автоуведомление, support - Сообщение от техподдержки,
	// 	 *     				report - Жалоба на пользователя
	Type *string `json:"type,omitempty"`

	// Unread Сообщение непрочитано
	Unread *bool `json:"unread,omitempty"`

	// UpdatedAt Время изменения сообщения в Unixtime, или null
	UpdatedAt *int `json:"updated_at"`

	// WarningType флаги для получение статуса игнорирования сообщения
	// 	 * 					(check — постановка сообщения на проверку, answer — на сообщение был ответ, ignore — сообщение было проигнорировано)
	WarningType *string `json:"warning_type,omitempty"`
}

// InboxOrder Предложение на индивидуальный кворк
type InboxOrder struct {
	// Budget Бюджет
	Budget *float32 `json:"budget,omitempty"`

	// Duration срок выполнения (секунд); null - срок не ограничен
	Duration *int `json:"duration,omitempty"`

	// Kwork Объект кворка
	Kwork *struct {
		// UnderscorePackage Пакет
		UnderscorePackage *Package `json:"_package,omitempty"`

		// Files Массив объектов файлов кворка
		Files *[]KworkFile `json:"files,omitempty"`

		// Id ID кворка
		Id *int `json:"id,omitempty"`

		// IsPackage Пакетный ли кворк
		IsPackage *bool `json:"is_package,omitempty"`
	} `json:"kwork,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что заказ не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Order Объект заказа
	Order *struct {
		// Count Количество заказанных кворков
		Count *int `json:"count,omitempty"`

		// Crt Цена заказа со всеми опциями для продавца
		Crt *float32 `json:"crt,omitempty"`

		// KworkDesc Описание кворка на момент заказа. Возможен html
		KworkDesc *string `json:"kwork_desc,omitempty"`

		// KworkTitle Название кворка на момент заказа
		KworkTitle *string `json:"kwork_title,omitempty"`

		// KworkWork Краткое описание на момент заказа
		KworkWork *string `json:"kwork_work,omitempty"`

		// Kworkspayerprice Цена кворков без опций для покупателя
		Kworkspayerprice *float32 `json:"kworkspayerprice,omitempty"`

		// Kworksworkerprice Цена кворков без опций для продавца
		Kworksworkerprice *float32 `json:"kworksworkerprice,omitempty"`

		// OrderedExtras Массив заказанных опций
		OrderedExtras *[]OrderedExtra `json:"ordered_extras,omitempty"`

		// Totaldays Общее количество дней на задачу
		Totaldays *int `json:"totaldays,omitempty"`

		// Totalprice Цена заказа со всеми опциями для покупателя
		Totalprice *float32 `json:"totalprice,omitempty"`
	} `json:"order,omitempty"`

	// OrderId ID заказа
	OrderId *int `json:"order_id,omitempty"`

	// Status Состояние предложения: new - Предложение в силе, cancel - Отказ, done - Заказ создан
	Status *string `json:"status,omitempty"`
}

// InboxTrackMessage Сообщение в переписке
type InboxTrackMessage struct {
	// ConversationId ID сообщений в conversation
	ConversationId *int `json:"conversation_id,omitempty"`

	// Countup Количество часов до ответа, -1 - значение не задано
	Countup *int `json:"countup"`

	// CreatedOrderId Id созданного заказа индивидуального предложения
	CreatedOrderId *int `json:"created_order_id,omitempty"`

	// CustomRequest Запрос на индивидуальный кворк
	CustomRequest *struct {
		// Budget Бюджет
		Budget *string `json:"budget,omitempty"`

		// Duration срок выполнения (секунд); null - срок не ограничен
		Duration *string `json:"duration,omitempty"`
	} `json:"custom_request,omitempty"`

	// EntityType Тип сообщения (9 - Inbox, 10 - Track
	EntityType *int `json:"entity_type,omitempty"`

	// Files файлы сообщения
	Files *[]FileWithMiniature `json:"files,omitempty"`

	// Forwarded Флаг является ли сообщение пересланным
	Forwarded *bool `json:"forwarded,omitempty"`

	// ForwardedFromUsername Имя пользователя, от которого переслано сообщение
	ForwardedFromUsername *string `json:"forwarded_from_username,omitempty"`

	// ForwarderFromId Идентификатор пользователя, от которого переслано сообщение
	ForwarderFromId *int `json:"forwarder_from_id,omitempty"`

	// FromId Идентификатор пользователя отправителя
	FromId *int `json:"from_id,omitempty"`

	// FromLiveDate Дата последней активности отправителя на сайте UNIXTIME
	FromLiveDate *int `json:"from_live_date,omitempty"`

	// FromProfilepicture Ссылка на аватар отправителя
	FromProfilepicture *string `json:"from_profilepicture,omitempty"`

	// FromUsername Имя пользователя отправителя
	FromUsername *string `json:"from_username,omitempty"`

	// InboxOrder Предложение на индивидуальный кворк
	InboxOrder *InboxOrder `json:"inbox_order,omitempty"`

	// Message Текст сообщения. Возможен HTML
	Message *string `json:"message,omitempty"`

	// MessageId ID сообщений в Inbox/Track
	MessageId *int `json:"message_id,omitempty"`

	// MessageKey Уникальный ключ сообщения
	MessageKey *string `json:"message_key,omitempty"`

	// MessagePage Страница на которой находится сообщение
	MessagePage *int `json:"message_page,omitempty"`

	// Quote Цитируемое сообщение
	Quote *struct {
		// ReplyMessageDisplayedText Текст цитируемого сообщения
		ReplyMessageDisplayedText *string `json:"reply_message_displayed_text,omitempty"`

		// ReplyMessageFiles Файлы цитируемого изображения
		ReplyMessageFiles *[]FileWithSize `json:"reply_message_files,omitempty"`

		// ReplyMessageId Идентификатор цитируемого сообщения
		ReplyMessageId *int `json:"reply_message_id,omitempty"`

		// ReplyMessagePage Номер страницы на которой находится цитируемое сообщение
		ReplyMessagePage *int `json:"reply_message_page,omitempty"`

		// ReplyMessageThumbnail URL к миниатюре цитируемого изображения
		ReplyMessageThumbnail *string `json:"reply_message_thumbnail,omitempty"`

		// ReplyMessageThumbnailPath Путь к миниатюре цитируемого изображения
		ReplyMessageThumbnailPath *string `json:"reply_message_thumbnail_path,omitempty"`

		// ReplyUserId Идентификатор пользователя отправившего цитируемое сообщение
		ReplyUserId *int `json:"reply_user_id,omitempty"`
	} `json:"quote,omitempty"`

	// Status Заглушка после удаления поля 'status'
	Status *string `json:"status,omitempty"`

	// Time Дата сообщения UNIXTIME
	Time *int `json:"time,omitempty"`

	// ToId ID получаетеля
	ToId *int `json:"to_id,omitempty"`

	// ToLiveDate Дата последней активности получателя на сайте UNIXTIME
	ToLiveDate *int `json:"to_live_date,omitempty"`

	// ToProfilepicture Ссылка на аватар получателя
	ToProfilepicture *string `json:"to_profilepicture,omitempty"`

	// ToUsername Username получателя
	ToUsername *string `json:"to_username,omitempty"`

	// TrackOrder Данные о заказе
	TrackOrder *TrackOrder `json:"track_order,omitempty"`

	// TrackType Тип трека
	TrackType *int `json:"track_type,omitempty"`

	// TranscriptionStatus Статус транскрибации, null - если успешно или сообщение не голосовое
	TranscriptionStatus *int `json:"transcription_status,omitempty"`

	// Type Тип сообщения: NULL - обычное сообщение, custom_request - Запрос на индивидуальный кворк,
	// 	 *     offer_kwork_new - Предложение кворка, offer_kwork_payer_cancel - Предложение индивидуального кворка отклонено покупателем,
	// 	 *     offer_kwork_worker_cancel - Предложение индивидуального кворка отклонено продавцом, offer_kwork_done - Заказ создан, auto - Автоуведомление,
	// 	 *     support - Сообщение от техподдержки, report - Жалоба на пользователя
	Type *string `json:"type,omitempty"`

	// Unread Сообщение непрочитано
	Unread *bool `json:"unread,omitempty"`

	// UpdatedAt Время изменения сообщения в Unixtime, или null
	UpdatedAt *int `json:"updated_at"`

	// WarningType флаги для получение статуса игнорирования сообщения (check — постановка сообщения на проверку,
	// 	 *     answer — на сообщение был ответ, ignore — сообщение было проигнорировано)
	WarningType *string `json:"warning_type,omitempty"`
}

// IndividualEnterpreneur Индивидуальынй предприниматель
type IndividualEnterpreneur struct {
	// Ip Информация об ИП
	Ip *struct {
		// RegisteredName ФИО
		RegisteredName *string `json:"registered_name,omitempty"`

		// RegistrationNumberPersonal ОГРНИП
		RegistrationNumberPersonal *int `json:"registration_number_personal,omitempty"`
	} `json:"ip,omitempty"`
}

// Interlocutor Данные о собеседнике
type Interlocutor struct {
	// AvatarImagePath Абсолютный урл аватара
	AvatarImagePath *string `json:"avatar_image_path,omitempty"`

	// LastOnlineTimestamp Последнее время в сети (unixtime)
	LastOnlineTimestamp *int `json:"last_online_timestamp,omitempty"`

	// UserId Идентификатор пользователя
	UserId *int `json:"user_id,omitempty"`

	// Username Имя пользователя
	Username *string `json:"username,omitempty"`
}

// KworkBadges Бейджи кворка
type KworkBadges = []struct {
	// BackgroundColor Цвет фона бейджа
	BackgroundColor *string `json:"backgroundColor,omitempty"`

	// CompositeTextColors Цвета частей текста бейджа
	CompositeTextColors *map[string]string `json:"composite_text_colors,omitempty"`

	// Name Текст бейджа
	Name *string `json:"name,omitempty"`

	// TextColor Цвет текста бейджа
	TextColor *string `json:"textColor,omitempty"`
}

// KworkInList Кворк
type KworkInList struct {
	// Badges Бейджи кворка
	Badges *KworkBadges `json:"badges,omitempty"`

	// CategoryId ID категории
	CategoryId *int `json:"category_id,omitempty"`

	// ClassifierId ID атрибута-значения классификации
	ClassifierId *int `json:"classifier_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Относительный путь к обложке кворка
	ImageUrl *string `json:"image_url,omitempty"`

	// IsSubscription Кворк с подпиской?
	IsSubscription *bool `json:"isSubscription,omitempty"`

	// IsBest Кворк имеет высший рейтинг
	IsBest *bool `json:"is_best,omitempty"`

	// IsFavorite Кворк в избранных у активного юзера
	IsFavorite *bool `json:"is_favorite,omitempty"`

	// IsHidden Кворк скрыт у активного юзера
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPriceFrom Необходима ли подпись 'Цена ОТ'
	IsPriceFrom *bool `json:"is_price_from,omitempty"`

	// IsViewed Просмотрен ли кворк
	IsViewed *bool `json:"is_viewed,omitempty"`

	// Lang Язык кворка, для привзяки валюты
	Lang *string `json:"lang,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Price Стоимость кворка
	Price *int `json:"price,omitempty"`

	// Title Название кворка
	Title *string `json:"title,omitempty"`

	// Worker Данные продавца
	Worker *UserWorker `json:"worker,omitempty"`
}

// KworkInListWithWorkerLevel defines model for kworkInListWithWorkerLevel.
type KworkInListWithWorkerLevel struct {
	// Badges Бейджи кворка
	Badges *KworkBadges `json:"badges,omitempty"`

	// CategoryId ID категории
	CategoryId *int `json:"category_id,omitempty"`

	// ClassifierId ID атрибута-значения классификации
	ClassifierId *int `json:"classifier_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Относительный путь к обложке кворка
	ImageUrl *string `json:"image_url,omitempty"`

	// IsSubscription Кворк с подпиской?
	IsSubscription *bool `json:"isSubscription,omitempty"`

	// IsBest Кворк имеет высший рейтинг
	IsBest *bool `json:"is_best,omitempty"`

	// IsFavorite Кворк в избранных у активного юзера
	IsFavorite *bool `json:"is_favorite,omitempty"`

	// IsHidden Кворк скрыт у активного юзера
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPriceFrom Необходима ли подпись 'Цена ОТ'
	IsPriceFrom *bool `json:"is_price_from,omitempty"`

	// IsViewed Просмотрен ли кворк
	IsViewed *bool `json:"is_viewed,omitempty"`

	// Lang Язык кворка, для привзяки валюты
	Lang *string `json:"lang,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Price Стоимость кворка
	Price *int `json:"price,omitempty"`

	// Title Название кворка
	Title  *string `json:"title,omitempty"`
	Worker *struct {
		// Fullname Полное имя пользователя
		Fullname *string `json:"fullname,omitempty"`

		// Id Идентификатор продавца
		Id *int `json:"id,omitempty"`

		// IsOnline Онлайн ли пользователь
		IsOnline *bool `json:"is_online,omitempty"`

		// LevelDescription Название уровня продавца
		LevelDescription *string `json:"level_description,omitempty"`

		// Profilepicture Путь к аватару
		Profilepicture *string `json:"profilepicture,omitempty"`

		// Rating Рейтинг по пятибальной шкале
		Rating *float32 `json:"rating,omitempty"`

		// RatingCount Количество отзывов
		RatingCount *int `json:"rating_count,omitempty"`

		// ReviewsCount Общее количество отзывов
		ReviewsCount *int `json:"reviews_count,omitempty"`

		// Username Имя пользователя
		Username *string `json:"username,omitempty"`
	} `json:"worker,omitempty"`
}

// KworkLinkSiteItem Площадка размещения ссылок кворка, либо продаваемый сайт или домен
type KworkLinkSiteItem struct {
	// Language Язык
	Language *string `json:"language,omitempty"`

	// MajesticCitationFlow Majestic
	MajesticCitationFlow *string `json:"majestic_citation_flow,omitempty"`

	// MozDomainAuthority Moz Domain Authority
	MozDomainAuthority *string `json:"moz_domain_authority,omitempty"`

	// MozSpamScore Moz Spam Score
	MozSpamScore *string `json:"moz_spam_score,omitempty"`

	// Name Наименование площадки/сайта/домена
	Name *string `json:"name,omitempty"`

	// Spam Спам
	Spam *string `json:"spam,omitempty"`

	// Sqi ИКС
	Sqi *string `json:"sqi,omitempty"`

	// Traffic Трафик (поле присутствует у площадки и сайта)
	Traffic *string `json:"traffic,omitempty"`

	// Trust Траст
	Trust *string `json:"trust,omitempty"`
}

// KworkPackage Пакет кворка
type KworkPackage struct {
	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Max Максимальное значение
	Max *int `json:"max,omitempty"`

	// Min Минимальное значение
	Min *int `json:"min,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`

	// Options Опции пакета
	Options *[]struct {
		// Included Опция включена (true/false)
		Included *bool `json:"included,omitempty"`

		// Name Название
		Name *string `json:"name,omitempty"`

		// Value Заложенное значение опции
		Value *string `json:"value,omitempty"`
	} `json:"options,omitempty"`

	// PackageDescription Описание
	PackageDescription *string `json:"package_description,omitempty"`

	// Price Стоимость пакета
	Price *int `json:"price,omitempty"`

	// Term Срок выполнения
	Term *string `json:"term,omitempty"`
}

// KworkFile defines model for kwork_file.
type KworkFile struct {
	// Id Идентификатор файла
	Id *int `json:"id,omitempty"`

	// Name Имя файла
	Name *string `json:"name,omitempty"`

	// Path Путь к файлу
	Path *string `json:"path,omitempty"`

	// Size Размер в байтах
	Size *int `json:"size,omitempty"`

	// Status Статус
	Status *KworkFileStatus `json:"status,omitempty"`

	// Timestamp Дата создания
	Timestamp *int `json:"timestamp,omitempty"`

	// Type Тип файла: kwork_description - Файл для описания кворка, kwork_instruction - Файл для инструкции
	Type *KworkFileType `json:"type,omitempty"`
}

// KworkFileStatus Статус
type KworkFileStatus string

// KworkFileType Тип файла: kwork_description - Файл для описания кворка, kwork_instruction - Файл для инструкции
type KworkFileType string

// KworkNotification defines model for kwork_notification.
type KworkNotification struct {
	// Added Дата создания unixtime
	Added *int `json:"added,omitempty"`

	// EntityId Идентификатор связанной сущности
	EntityId *int `json:"entity_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// KworkTitle Название кворка
	KworkTitle *string `json:"kworkTitle,omitempty"`

	// Link Ссылка для перехода
	Link *string `json:"link,omitempty"`
}

// KworksWithCount Диапазоны количества кворков в фильтре проектов
type KworksWithCount struct {
	// Boundaries Диапазон количества кворков
	Boundaries *struct {
		// From Начало диапазона
		From *int `json:"from"`

		// To Конец диапазона
		To *int `json:"to"`
	} `json:"boundaries,omitempty"`

	// Count Количество проектов в диапазоне
	Count *int `json:"count,omitempty"`

	// Name Наименование диапазона
	Name *string `json:"name,omitempty"`
}

// LegalEntity ООО
type LegalEntity struct {
	// Ooo Информация об ООО
	Ooo *struct {
		// Address Адрес
		Address *string `json:"address,omitempty"`

		// CompanyName Название компании
		CompanyName *string `json:"company_name,omitempty"`

		// RegistrationNumber ОГРН
		RegistrationNumber *int `json:"registration_number,omitempty"`

		// RegistrationReasonCode КПП
		RegistrationReasonCode *int `json:"registration_reason_code,omitempty"`
	} `json:"ooo,omitempty"`
}

// Notification Уведомление
type Notification struct {
	union json.RawMessage
}

// NotificationType Тип уведомления
type NotificationType struct {
	// Description Описание
	Description *string `json:"description,omitempty"`

	// EntityType Тип связанной сущности
	EntityType *string `json:"entity_type,omitempty"`

	// IsRed Важное ли
	IsRed *bool `json:"is_red,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`

	// Notifications Уведомления данного типа
	Notifications *[]Notification `json:"notifications,omitempty"`

	// Priority Приоритет
	Priority *int `json:"priority,omitempty"`
}

// Offer Предложение на запрос услуги на бирже
type Offer struct {
	// Comment Комментарий к предложению
	Comment *string `json:"comment,omitempty"`

	// DateCreate Дата создания предложения
	DateCreate *int `json:"date_create,omitempty"`

	// Duration Срок выполнения дней
	Duration *int `json:"duration,omitempty"`

	// Id Идентификатор предложения
	Id *int `json:"id,omitempty"`

	// IsActual Флаг актуальности предложения
	IsActual *bool `json:"is_actual,omitempty"`

	// IsRead Флаг прочитанности предложения покупателем
	IsRead *bool `json:"is_read,omitempty"`

	// KworkId Идентификатор кворка
	KworkId *int `json:"kwork_id,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int `json:"order_id,omitempty"`

	// Price Цена предложения
	Price *int `json:"price,omitempty"`

	// Project Поля запроса(проекта) для продавца
	Project *WantWorker `json:"project,omitempty"`

	// Status Статус предложения
	Status *string `json:"status,omitempty"`

	// Title Название предложения
	Title *string `json:"title,omitempty"`

	// WantId Идентификатор запроса на услугу
	WantId *int `json:"want_id,omitempty"`
}

// OrderDetails Детальные данные по заказу
type OrderDetails struct {
	// Details Детали заказа
	Details *struct {
		// Attributes Атрибуты заказа
		Attributes *[]struct {
			// Name название классификации/атрибута
			Name *string `json:"name,omitempty"`

			// Values Значения атрибута
			Values *[]string `json:"values,omitempty"`
		} `json:"attributes,omitempty"`

		// Description Описание заказа по данным кворка на момент оформления заказа
		Description *string `json:"description,omitempty"`

		// Files Прикрепленные файлы к заказу
		Files *[]TrackFile `json:"files,omitempty"`

		// Package Пакет заказа
		Package *struct {
			// Options Включенные в заказ опции пакета
			Options *[]struct {
				// Hint Подсказка для опции
				Hint *string `json:"hint,omitempty"`

				// Id Идентификатор опции
				Id *int `json:"id,omitempty"`

				// ListValues Список значений опций
				ListValues *[]string `json:"list_values,omitempty"`

				// MaxValue Максимальное значение опции
				MaxValue *int `json:"max_value,omitempty"`

				// MinValue Минимальное значение опции
				MinValue *int `json:"min_value,omitempty"`

				// Name Наименование опции
				Name *string `json:"name,omitempty"`

				// PredefinedValue1 Предустаановленное значение опции 1
				PredefinedValue1 *string `json:"predefined_value_1,omitempty"`

				// PredefinedValue2 Предустаановленное значение опции 2
				PredefinedValue2 *string `json:"predefined_value_2,omitempty"`

				// PredefinedValue3 Предустаановленное значение опции 3
				PredefinedValue3 *string `json:"predefined_value_3,omitempty"`

				// Type Тип опции
				Type *string `json:"type,omitempty"`
			} `json:"options,omitempty"`

			// Type Тип пакета
			Type *string `json:"type,omitempty"`
		} `json:"package,omitempty"`
	} `json:"details,omitempty"`

	// Draft Рудимент черновика
	Draft *string `json:"draft,omitempty"`

	// DraftDetails Черновики сообщений и треков
	DraftDetails *InboxAndTrackDraft `json:"draft_details,omitempty"`

	// KeyTracks Треки заказа
	KeyTracks *[]struct {
		// CreatedAt Дата создания
		CreatedAt *int `json:"created_at,omitempty"`

		// Id Идентификтор трека
		Id *int `json:"id,omitempty"`

		// Title Заголовок
		Title *string `json:"title,omitempty"`

		// TypeId Тип трека
		TypeId *int `json:"type_id,omitempty"`
	} `json:"key_tracks,omitempty"`

	// Stages Этапы заказа
	Stages *[]struct {
		// CreatedAt Дата создания
		CreatedAt *int `json:"created_at,omitempty"`

		// CurrencyId Валюта
		CurrencyId *int `json:"currency_id,omitempty"`

		// CurrencyRate Курс валюты
		CurrencyRate *float32 `json:"currency_rate,omitempty"`

		// Id Идентификатор этапа
		Id *int `json:"id,omitempty"`

		// Number Номер задачи
		Number *int `json:"number,omitempty"`

		// Price Сумма
		Price *float32 `json:"price,omitempty"`

		// Progress Прогресс по задаче
		Progress *int `json:"progress,omitempty"`

		// Status Статус
		Status *int `json:"status,omitempty"`

		// Title Заголовок
		Title *string `json:"title,omitempty"`
	} `json:"stages,omitempty"`

	// Volume Треки заказа
	Volume *[]struct {
		// Id Идентификтор объема
		Id *int `json:"id,omitempty"`

		// Name Название объема, полное, в им.падеже
		Name *string `json:"name,omitempty"`

		// NameAccusative Название объема, вин.падеж
		NameAccusative *string `json:"name_accusative,omitempty"`

		// NamePlural1119 Название объема, множественное число для кол-ва 11-19
		NamePlural1119 *string `json:"name_plural_11_19,omitempty"`

		// NamePlural24 Название объема, множественное число для кол-ва 2-4
		NamePlural24 *string `json:"name_plural_2_4,omitempty"`

		// NameShort Название объема, сокращенное
		NameShort *string `json:"name_short,omitempty"`

		// VolumeAmount Объем заказа
		VolumeAmount *float32 `json:"volume_amount,omitempty"`
	} `json:"volume,omitempty"`
}

// OrderHeader defines model for order_header.
type OrderHeader struct {
	// Kwork Данные кворка
	Kwork *struct {
		// Category Идентификатор категории
		Category *int `json:"category,omitempty"`

		// Hash Хеш обновления
		Hash *int `json:"hash,omitempty"`

		// Id Идентификатор кворка
		Id *int `json:"id,omitempty"`

		// ImageUrl Ссылка на обложку (абсолютная)
		ImageUrl *string `json:"image_url,omitempty"`

		// Title Заголовок кворка
		Title *string `json:"title,omitempty"`

		// UserId Идентификатор продавца
		UserId *int `json:"user_id,omitempty"`
	} `json:"kwork,omitempty"`

	// Order Данные заказа
	Order *struct {
		// Count Количество кворков в заказе
		Count *int `json:"count,omitempty"`

		// CreatedAt Дата, когда был сделан заказ
		CreatedAt *int `json:"created_at,omitempty"`

		// CurrencyId Идентификтор валюты заказа
		CurrencyId *int `json:"currency_id,omitempty"`

		// DeadlineAt Временная метка окончания таймера
		DeadlineAt *int `json:"deadline_at,omitempty"`

		// Delivery Общее время выполнения заказа в секундах
		Delivery *int `json:"delivery,omitempty"`

		// DiscountAmount Размер скидки
		DiscountAmount *int `json:"discount_amount,omitempty"`

		// HasFiles Есть ли файлы в заказе
		HasFiles *bool `json:"has_files,omitempty"`

		// HasStages Этапный заказ
		HasStages *int `json:"has_stages,omitempty"`

		// Hash Хеш обновления
		Hash *int `json:"hash,omitempty"`

		// Id Идентификатор заказа
		Id *int `json:"id,omitempty"`

		// IsApproveDeliveryAvailable Возможность для покупателя принять заказ
		IsApproveDeliveryAvailable *bool `json:"isApproveDeliveryAvailable,omitempty"`

		// IsArbitrationAvailable Возможность ли пользователю отправить заказ в арбитраж
		IsArbitrationAvailable *bool `json:"isArbitrationAvailable,omitempty"`

		// IsCancelOrderAvailable Возможность отменить заказ для продавца / покупателя
		IsCancelOrderAvailable *bool `json:"isCancelOrderAvailable,omitempty"`

		// IsSendForApprovalAvailable Возможность для продавца сдать на проверку заказ
		IsSendForApprovalAvailable *bool `json:"isSendForApprovalAvailable,omitempty"`

		// IsOrderDataProvided Предоставлены ли данные
		IsOrderDataProvided *bool `json:"is_order_data_provided,omitempty"`

		// IsRequiredSelfEmployedStatus Отображение блока, при заказе от компании, если продавец потенциально СЗ/ИП
		IsRequiredSelfEmployedStatus *bool `json:"is_required_self_employed_status,omitempty"`

		// KworkTitle Заголовок кворка на момент создания заказа (название заказа по умолчанию, если покупатель не ввел свое)
		KworkTitle *string `json:"kwork_title,omitempty"`

		// Metrics Необходимы метрики
		Metrics *bool `json:"metrics,omitempty"`

		// Note Заметка о заказе
		Note *struct {
			// PostedTimestamp Дата публикации
			PostedTimestamp *int `json:"posted_timestamp,omitempty"`

			// Text Текст заметки
			Text *int `json:"text,omitempty"`
		} `json:"note,omitempty"`

		// PayerId Идентификатор покупателя
		PayerId *int `json:"payer_id,omitempty"`

		// PayerPrice Цена для продавца без комиссии
		PayerPrice *float32 `json:"payer_price,omitempty"`

		// PaymentType Тип заказа: 0 - физлицо, 1 - подписка, 2 - эскроу
		PaymentType *int `json:"payment_type,omitempty"`

		// Price Цена заказа
		Price *float32 `json:"price,omitempty"`

		// ReportRequired Необходимость создать отчет
		ReportRequired *bool `json:"report_required,omitempty"`

		// StageMaxTimeInDays Максимальный срок в заказах
		StageMaxTimeInDays *int `json:"stage_max_time_in_days,omitempty"`

		// Status Текущий статус заказа
		Status *int `json:"status,omitempty"`

		// StatusVirtual Виртуальный статус заказа
		StatusVirtual *int `json:"statusVirtual,omitempty"`

		// Title Заголовок заказа (пользовательское название заказа)
		Title *string `json:"title,omitempty"`

		// WorkerId Идентификатор продавца
		WorkerId *int `json:"worker_id,omitempty"`

		// YescrowProperties Информация эскроу
		YescrowProperties *struct {
			// CanPayByYescrow Может ли продавец принимать безнал
			CanPayByYescrow *bool `json:"can_pay_by_yescrow,omitempty"`
		} `json:"yescrow_properties,omitempty"`
	} `json:"order,omitempty"`

	// Payer Данные покупателя
	Payer *struct {
		// Fullname ФИО пользователя
		Fullname *string `json:"fullname,omitempty"`

		// Hash Хеш обновления
		Hash *int `json:"hash,omitempty"`

		// Id Идентификатор кворка
		Id *int `json:"id,omitempty"`

		// ImageUrl Ссылка на обложку
		ImageUrl *string `json:"image_url,omitempty"`

		// IsOnline Онлайн статус
		IsOnline *bool `json:"is_online,omitempty"`

		// IsVoiceMessageBlocked Запрещено ли отправлять ГС данному ользователю
		IsVoiceMessageBlocked *bool `json:"is_voice_message_blocked,omitempty"`

		// Username Логин пользователя
		Username *string `json:"username,omitempty"`
	} `json:"payer,omitempty"`

	// Worker Данные продавца
	Worker *struct {
		// Fullname ФИО пользователя
		Fullname *string `json:"fullname,omitempty"`

		// Hash Хеш обновления
		Hash *int `json:"hash,omitempty"`

		// Id Идентификатор кворка
		Id *int `json:"id,omitempty"`

		// ImageUrl Ссылка на обложку
		ImageUrl *string `json:"image_url,omitempty"`

		// IsOnline Онлайн статус
		IsOnline *bool `json:"is_online,omitempty"`

		// Username Логин пользователя
		Username *string `json:"username,omitempty"`
	} `json:"worker,omitempty"`
}

// OrderNotification defines model for order_notification.
type OrderNotification struct {
	// Added Дата создания unixtime
	Added *int `json:"added,omitempty"`

	// EntityId Идентификатор связанной сущности
	EntityId *int `json:"entity_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// IsOtherUserOnline Онлайн ли другой пользователь
	IsOtherUserOnline *bool `json:"isOtherUserOnline,omitempty"`

	// Link Ссылка для перехода
	Link *string `json:"link,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int `json:"orderId,omitempty"`

	// OrderTitle Название заказа
	OrderTitle *string `json:"orderTitle,omitempty"`

	// OtherUserAvatar Ссылка на изображение аватара другого пользователя
	OtherUserAvatar *string `json:"otherUserAvatar,omitempty"`

	// OtherUserId Идентификатор другого пользователя
	OtherUserId *int `json:"otherUserId,omitempty"`

	// OtherUserName Имя другого пользователя
	OtherUserName *string `json:"otherUserName,omitempty"`
}

// OrderOption Опция в заказе
type OrderOption struct {
	// Currency Валюта опции
	Currency *string `json:"currency,omitempty"`

	// Id Идентификатор опции
	Id *int `json:"id,omitempty"`

	// IsAdditionalKworkExtra Является ли докупкой пакетов/кворков или нет
	IsAdditionalKworkExtra *bool `json:"is_additional_kwork_extra,omitempty"`

	// IsExtraVolume Является ли опцией для увеличения объема заказа
	IsExtraVolume *bool `json:"is_extra_volume,omitempty"`

	// Name Наименование опции
	Name *string `json:"name,omitempty"`

	// PayerPrice Стоимость опции для покупателя
	PayerPrice *float32 `json:"payer_price,omitempty"`

	// Time Добавочная длительность к заказу
	Time *int `json:"time,omitempty"`

	// Volume Максимальный и базовый объём заказа
	Volume *[]struct {
		// Base Базовый объём заказа
		Base *int `json:"base,omitempty"`

		// Max Максимальный объём заказа
		Max *int `json:"max,omitempty"`
	} `json:"volume,omitempty"`

	// WorkerPrice Стоимость опции для продавца
	WorkerPrice *float32 `json:"worker_price,omitempty"`
}

// OrderProvidedData Информация предоставленная по заказу
type OrderProvidedData struct {
	// Files Файлы
	Files *[]struct {
		// Extension Расширение
		Extension *string `json:"extension,omitempty"`

		// FileUrl Абсолютный урл файла на сервере
		FileUrl *string `json:"file_url,omitempty"`

		// Id Идентификатор файла
		Id *int `json:"id,omitempty"`

		// IsMetrics Является ли файл метрикой
		IsMetrics *bool `json:"is_metrics,omitempty"`

		// MiniatureUrl Абсолютный урл миниатюры
		MiniatureUrl *string `json:"miniature_url,omitempty"`

		// Name Имя файла
		Name *int `json:"name,omitempty"`

		// SizeInBytes Размер файла в байтах
		SizeInBytes *int `json:"size_in_bytes,omitempty"`
	} `json:"files,omitempty"`

	// Message Сообщение
	Message *string `json:"message,omitempty"`
}

// OrderedExtra Заказанная опция
type OrderedExtra struct {
	// Count Количество заказанных опций
	Count *int `json:"count,omitempty"`

	// Id ID опции
	Id *int `json:"id,omitempty"`

	// PayerPrice Цена заказанных опции для покупателя
	PayerPrice *float32 `json:"payer_price,omitempty"`

	// Title Название опции
	Title *string `json:"title,omitempty"`

	// Totaldays Общая длительность в днях
	Totaldays *int `json:"totaldays,omitempty"`

	// WorkerPrice Цена заказанных опции для продавца
	WorkerPrice *float32 `json:"worker_price,omitempty"`
}

// Package Пакет
type Package struct {
	// Description Описание пакета
	Description *string `json:"description,omitempty"`

	// Duration Продолжительность в днях
	Duration *int `json:"duration,omitempty"`

	// Items Массив опций пакета
	Items *[]PackageItem `json:"items,omitempty"`

	// Price Цена пакета
	Price *float32 `json:"price,omitempty"`

	// Type Тип пакета
	Type *PackageType `json:"type,omitempty"`
}

// PackageType Тип пакета
type PackageType string

// PackageItem Пакетная опция
type PackageItem struct {
	// Id Идентификатор опции пакета
	Id *int `json:"id,omitempty"`

	// Name Название опции
	Name *string `json:"name,omitempty"`

	// Name1 Название опции в единственном числе
	Name1 *string `json:"name_1,omitempty"`

	// Name2 Название опции для 2
	Name2 *string `json:"name_2,omitempty"`

	// Name5 Название опции для 5
	Name5 *string `json:"name_5,omitempty"`

	// Type Тип значения опции
	Type *PackageItemType `json:"type,omitempty"`

	// Value Значение опции
	Value *string `json:"value,omitempty"`
}

// PackageItemType Тип значения опции
type PackageItemType string

// Paging Данные пагинации
type Paging struct {
	// Limit Количество элементов на странице
	Limit *int `json:"limit,omitempty"`

	// Page Текущая страница
	Page *int `json:"page,omitempty"`

	// Total Общее количество элементов
	Total *int `json:"total,omitempty"`
}

// PagingWithPages defines model for paging_with_pages.
type PagingWithPages struct {
	// Limit Количество элементов на странице
	Limit *int `json:"limit,omitempty"`

	// Page Текущая страница
	Page *int `json:"page,omitempty"`

	// Pages Количество страниц
	Pages *int `json:"pages,omitempty"`

	// Total Общее количество элементов
	Total *int `json:"total,omitempty"`
}

// PaymentType Способ пополнения
type PaymentType struct {
	// AmountLimits Лимиты пополнений для безналичного расчёта
	AmountLimits *struct {
		// Max Максимальная сумма пополнения
		Max *float32 `json:"max,omitempty"`

		// Min Минимальная сумма пополнения
		Min *float32 `json:"min,omitempty"`
	} `json:"amount_limits,omitempty"`

	// CountryGroupCode Предустановленный код группы стран
	CountryGroupCode *string `json:"country_group_code"`

	// CountryGroups Варианты групп стран для выбора
	CountryGroups *[]struct {
		// Code Код группы
		Code *string `json:"code,omitempty"`

		// Name Название группы
		Name *string `json:"name,omitempty"`
	} `json:"country_groups"`

	// Name Название способоа
	Name *string `json:"name,omitempty"`

	// Type Тип способоа
	Type *string `json:"type,omitempty"`
}

// PopularBlock defines model for popularBlock.
type PopularBlock struct {
	// BlockDescription Описание блока
	BlockDescription *string `json:"block_description,omitempty"`

	// Categories Массив категорий
	Categories *[]PopularBlockCategories `json:"categories,omitempty"`

	// Id ID категории
	Id *int `json:"id,omitempty"`

	// Name Наименование блока
	Name *string `json:"name,omitempty"`

	// Order Порядок
	Order *int `json:"order,omitempty"`
}

// PopularBlockCategories defines model for popularBlockCategories.
type PopularBlockCategories struct {
	// CategoryId Идентификатор категории, может быть null если это классификация
	CategoryId *int `json:"category_id"`

	// ClassifierId Идентификатор классификации, может быть null если это категория
	ClassifierId *int `json:"classifier_id"`

	// CoverUrl Путь к изображению
	CoverUrl *string `json:"cover_url,omitempty"`

	// KworksCount Количество кворков
	KworksCount *int `json:"kworks_count,omitempty"`

	// Name Название рубрики
	Name *string `json:"name,omitempty"`

	// Order Порядок сортировки
	Order *int `json:"order,omitempty"`
}

// Portfolio Портфолио
type Portfolio struct {
	// Audios Звукозаписи, прикрепленные к портфолио
	Audios *[]struct {
		// Link Ссылка на звукозапись
		Link *string `json:"link,omitempty"`

		// Position Позиция сортировки звукозаписи
		Position *int `json:"position,omitempty"`
	} `json:"audios,omitempty"`

	// CategoryId ID категории заказа
	CategoryId *int `json:"category_id,omitempty"`

	// CategoryName Название категории заказа
	CategoryName *string `json:"category_name,omitempty"`

	// CommentsCount Кол-во комментариев
	CommentsCount *int `json:"comments_count,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Images Изображения, прикрепленные к портфолио
	Images *[]struct {
		// Link Ссылка на изображение
		Link *string `json:"link,omitempty"`

		// Position Позиция сортировки изображения
		Position *int `json:"position,omitempty"`

		// Thumbnail Ссылка на миниатюру изображения
		Thumbnail *string `json:"thumbnail,omitempty"`
	} `json:"images,omitempty"`

	// OrderId ID заказа
	OrderId *int `json:"order_id,omitempty"`

	// Pdf PDF, прикрепленные к портфолио
	Pdf *[]struct {
		// Link Ссылка на pdf
		Link *string `json:"link,omitempty"`

		// Position Позиция сортировки pdf
		Position *int `json:"position,omitempty"`
	} `json:"pdf,omitempty"`

	// Photo Относительный путь к фото
	Photo *string `json:"photo,omitempty"`

	// PinedAtTimestamp Дата закрепления портфолио timestamp
	PinedAtTimestamp *int `json:"pined_at_timestamp,omitempty"`

	// Title Название работы
	Title *string `json:"title,omitempty"`

	// Type Тип, 'photo' или 'видео'
	Type *string `json:"type,omitempty"`

	// Video Относительный путь к видео
	Video *string `json:"video,omitempty"`

	// Videos Видеоролики, прикрепленные к портфолио
	Videos *[]struct {
		// Link Ссылка на видеоролик
		Link *string `json:"link,omitempty"`

		// Position Позиция сортировки видеоролика
		Position *int `json:"position,omitempty"`
	} `json:"videos,omitempty"`

	// Views Кол-во чистых просмотров
	Views *int `json:"views,omitempty"`

	// ViewsDirty Кол-во грязных просмотров
	ViewsDirty *int `json:"views_dirty,omitempty"`
}

// PositiveReviewsCount Количество отзывов => Количество кворков с таким количество отзывов
type PositiveReviewsCount map[string]string

// ProfileBadges Бейдж пользователя
type ProfileBadges struct {
	// Description Описание
	Description *string `json:"description"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Ссылка на изображение
	ImageUrl *string `json:"image_url,omitempty"`

	// Name Название
	Name *string `json:"name,omitempty"`
}

// ProfileKwork Кворк пользователя
type ProfileKwork struct {
	// Activity Активность для текущего юзера
	Activity *struct {
		// Earned Сколько заработано
		Earned *int `json:"earned,omitempty"`

		// Orders Количество заказов
		Orders *int `json:"orders,omitempty"`

		// Views Количество просмотров
		Views *int `json:"views,omitempty"`
	} `json:"activity,omitempty"`

	// Badges Бейджи кворка
	Badges *KworkBadges `json:"badges,omitempty"`

	// BlackFridayPrice Цена по черной пятнице
	BlackFridayPrice *int `json:"blackFridayPrice,omitempty"`

	// CategoryId ID категории
	CategoryId *int `json:"category_id,omitempty"`

	// CategoryName Название категории
	CategoryName *string `json:"category_name,omitempty"`

	// ClassificationId ID атрибута-значения классификации верхнего уровня
	ClassificationId *int `json:"classification_id,omitempty"`

	// DiscountPercentage Скидка по черной пятнице
	DiscountPercentage *int `json:"discountPercentage,omitempty"`

	// EditsList Массив строк что нужно исправить в кворке, для текущего юзера
	EditsList *[]string `json:"edits_list,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Относительный путь к обложке кворка
	ImageUrl *string `json:"image_url,omitempty"`

	// IsBlackFriday Участвует ли в черной пятнице
	IsBlackFriday *bool `json:"isBlackFriday,omitempty"`

	// IsSubscription Кворк с подпиской?
	IsSubscription *bool `json:"isSubscription,omitempty"`

	// IsBest Кворк имеет высший рейтинг
	IsBest *bool `json:"is_best,omitempty"`

	// IsFavorite Кворк в избранных у активного юзера
	IsFavorite *bool `json:"is_favorite,omitempty"`

	// IsHidden Кворк скрыт у активного юзера
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPriceFrom Необходима ли подпись 'Цена ОТ'
	IsPriceFrom *bool `json:"is_price_from,omitempty"`

	// IsViewed Просмотрен ли кворк
	IsViewed *bool `json:"is_viewed,omitempty"`

	// Lang Язык кворка, для привзяки валюты
	Lang *string `json:"lang,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Order Порядок вывода в списке
	Order *int `json:"order,omitempty"`

	// Price Стоимость кворка
	Price *int `json:"price,omitempty"`

	// StatusId Идентификатор статуса кворка
	StatusId *int `json:"status_id,omitempty"`

	// StatusName Название статуса
	StatusName *string `json:"status_name,omitempty"`

	// Title Название кворка
	Title *string `json:"title,omitempty"`

	// Worker Данные продавца
	Worker *UserWorker `json:"worker,omitempty"`
}

// ProfileKworkWithWorkerLevel defines model for profileKworkWithWorkerLevel.
type ProfileKworkWithWorkerLevel struct {
	// Activity Активность для текущего юзера
	Activity *struct {
		// Earned Сколько заработано
		Earned *int `json:"earned,omitempty"`

		// Orders Количество заказов
		Orders *int `json:"orders,omitempty"`

		// Views Количество просмотров
		Views *int `json:"views,omitempty"`
	} `json:"activity,omitempty"`

	// Badges Бейджи кворка
	Badges *KworkBadges `json:"badges,omitempty"`

	// BlackFridayPrice Цена по черной пятнице
	BlackFridayPrice *int `json:"blackFridayPrice,omitempty"`

	// CategoryId ID категории
	CategoryId *int `json:"category_id,omitempty"`

	// CategoryName Название категории
	CategoryName *string `json:"category_name,omitempty"`

	// ClassificationId ID атрибута-значения классификации верхнего уровня
	ClassificationId *int `json:"classification_id,omitempty"`

	// DiscountPercentage Скидка по черной пятнице
	DiscountPercentage *int `json:"discountPercentage,omitempty"`

	// EditsList Массив строк что нужно исправить в кворке, для текущего юзера
	EditsList *[]string `json:"edits_list,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// ImageUrl Относительный путь к обложке кворка
	ImageUrl *string `json:"image_url,omitempty"`

	// IsBlackFriday Участвует ли в черной пятнице
	IsBlackFriday *bool `json:"isBlackFriday,omitempty"`

	// IsSubscription Кворк с подпиской?
	IsSubscription *bool `json:"isSubscription,omitempty"`

	// IsBest Кворк имеет высший рейтинг
	IsBest *bool `json:"is_best,omitempty"`

	// IsFavorite Кворк в избранных у активного юзера
	IsFavorite *bool `json:"is_favorite,omitempty"`

	// IsHidden Кворк скрыт у активного юзера
	IsHidden *bool `json:"is_hidden,omitempty"`

	// IsPriceFrom Необходима ли подпись 'Цена ОТ'
	IsPriceFrom *bool `json:"is_price_from,omitempty"`

	// IsViewed Просмотрен ли кворк
	IsViewed *bool `json:"is_viewed,omitempty"`

	// Lang Язык кворка, для привзяки валюты
	Lang *string `json:"lang,omitempty"`

	// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
	NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

	// Order Порядок вывода в списке
	Order *int `json:"order,omitempty"`

	// Price Стоимость кворка
	Price *int `json:"price,omitempty"`

	// StatusId Идентификатор статуса кворка
	StatusId *int `json:"status_id,omitempty"`

	// StatusName Название статуса
	StatusName *string `json:"status_name,omitempty"`

	// Title Название кворка
	Title  *string `json:"title,omitempty"`
	Worker *struct {
		// Fullname Полное имя пользователя
		Fullname *string `json:"fullname,omitempty"`

		// Id Идентификатор продавца
		Id *int `json:"id,omitempty"`

		// IsOnline Онлайн ли пользователь
		IsOnline *bool `json:"is_online,omitempty"`

		// LevelDescription Название уровня продавца
		LevelDescription *string `json:"level_description,omitempty"`

		// Profilepicture Путь к аватару
		Profilepicture *string `json:"profilepicture,omitempty"`

		// Rating Рейтинг по пятибальной шкале
		Rating *float32 `json:"rating,omitempty"`

		// RatingCount Количество отзывов
		RatingCount *int `json:"rating_count,omitempty"`

		// ReviewsCount Общее количество отзывов
		ReviewsCount *int `json:"reviews_count,omitempty"`

		// Username Имя пользователя
		Username *string `json:"username,omitempty"`
	} `json:"worker,omitempty"`
}

// ProfileKworks Кворки пользователя
type ProfileKworks = []ProfileKwork

// ProfileKworksWithWorkerLevel Кворки пользователя
type ProfileKworksWithWorkerLevel = []ProfileKworkWithWorkerLevel

// ProfilePortfolios Портфолио пользователя
type ProfilePortfolios = []Portfolio

// PushEvent Непрочитанное push-событие пользователя
type PushEvent struct {
	// CreatedAt Дата создания события
	CreatedAt *string `json:"created_at,omitempty"`

	// Data Данные push-события (свой набор для каждой сущности)
	Data *map[string]interface{} `json:"data,omitempty"`

	// EntityId Идентификатор сущности, связанной с push-событием (inbox_id, notity_id
	EntityId *int `json:"entity_id,omitempty"`

	// Event Наименование события
	Event *string `json:"event,omitempty"`

	// Id Идентификатор сквозной очереди непрочитанных push-событий
	Id *int `json:"id,omitempty"`

	// UserId Идентификатор пользователя-получателя (текущий)
	UserId *int `json:"user_id,omitempty"`
}

// Resize Данные ресайза изображения
type Resize struct {
	// H Высота в % от ширины оригинального изображения
	H *float32 `json:"h,omitempty"`

	// W Ширина в % от ширины оригинального изображения
	W *float32 `json:"w,omitempty"`

	// X Сдвиг по вертикали в % от ширины оригинального изображения
	X *float32 `json:"x,omitempty"`

	// Y Сдвиг по горизонтали в % от высоты оригинального изображения
	Y *float32 `json:"y,omitempty"`
}

// SecondLevelCategory defines model for secondLevelCategory.
type SecondLevelCategory struct {
	// Id Идентификатор рубрики
	Id *int `json:"id,omitempty"`

	// KworksCount Количество кворков
	KworksCount *int `json:"kworks_count,omitempty"`

	// Name Название рубрики
	Name *string `json:"name,omitempty"`

	// Order Порядок сортировки
	Order *int `json:"order,omitempty"`

	// RubricDescription Описание
	RubricDescription *string `json:"rubric_description,omitempty"`
}

// ShortUserInfo defines model for short_user_info.
type ShortUserInfo struct {
	// AchievmentsList Массив объектов наград
	AchievmentsList *[]ProfileBadges `json:"achievments_list,omitempty"`

	// AnswerTime Время ответа
	AnswerTime *string `json:"answer_time,omitempty"`

	// BadReviews Кол-во отрицательных отзывов
	BadReviews *int `json:"bad_reviews,omitempty"`

	// Description Описание
	Description *string `json:"description,omitempty"`

	// GoodReviews Кол-во положительных отзывов
	GoodReviews *int `json:"good_reviews,omitempty"`

	// Id Идентификатор юзера
	Id *int `json:"id,omitempty"`

	// IsCashlessPaymentAvailable Может ли работать по эскроу схеме
	IsCashlessPaymentAvailable *bool `json:"is_cashless_payment_available,omitempty"`

	// IsOnline Онлайн ли юзер
	IsOnline *bool `json:"is_online,omitempty"`

	// Level Уровень пользователя
	Level *string `json:"level,omitempty"`

	// Location Местонахождение и местное время
	Location *string `json:"location,omitempty"`

	// OrderDoneCount Кол-во выполненных заказов
	OrderDoneCount *int `json:"order_done_count,omitempty"`

	// Profilepicture Аватар
	Profilepicture *string `json:"profilepicture,omitempty"`

	// Rating Рейтинг по пятибальной шкале
	Rating *float32 `json:"rating,omitempty"`

	// RatingCount Кол-во оценок
	RatingCount *int `json:"rating_count,omitempty"`

	// RegistrationTime Время регистрации UNIXTIME
	RegistrationTime *int `json:"registration_time,omitempty"`

	// ReviewsCount Кол-во ревью
	ReviewsCount *int `json:"reviews_count,omitempty"`

	// Username Имя юзера
	Username *string `json:"username,omitempty"`
}

// SimpleNotification Уведомление без дополнительных полей
type SimpleNotification struct {
	// Added Дата создания unixtime
	Added *int `json:"added,omitempty"`

	// EntityId Идентификатор связанной сущности
	EntityId *int `json:"entity_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Link Ссылка для перехода
	Link *string `json:"link,omitempty"`
}

// StageNotification defines model for stage_notification.
type StageNotification struct {
	// Added Дата создания unixtime
	Added *int `json:"added,omitempty"`

	// EntityId Идентификатор связанной сущности
	EntityId *int `json:"entity_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// IsOtherUserOnline Онлайн ли другой пользователь
	IsOtherUserOnline *bool `json:"isOtherUserOnline,omitempty"`

	// Link Ссылка для перехода
	Link *string `json:"link,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int `json:"orderId,omitempty"`

	// OrderTitle Название заказа
	OrderTitle *string `json:"orderTitle,omitempty"`

	// OtherUserAvatar Ссылка на изображение аватара другого пользователя
	OtherUserAvatar *string `json:"otherUserAvatar,omitempty"`

	// OtherUserId Идентификатор другого пользователя
	OtherUserId *int `json:"otherUserId,omitempty"`

	// OtherUserName Имя другого пользователя
	OtherUserName *string `json:"otherUserName,omitempty"`

	// StageTitle Название этапа
	StageTitle *string `json:"stageTitle,omitempty"`
}

// Track Сообщение трека
type Track struct {
	// Actions Доступные действия
	Actions *[]struct {
		// Data Данные для построения доступного действия
		Data *map[string]interface{} `json:"data,omitempty"`

		// Id Идентификатор действия
		Id *string `json:"id,omitempty"`
	} `json:"actions,omitempty"`

	// AutoCancelDeadline Дедлайн, для типа трека = 23 и 25
	AutoCancelDeadline *int `json:"auto_cancel_deadline,omitempty"`

	// AutoCompletionTime Дата автопринятия для трека = 32, автоотмены для 22 и 31
	AutoCompletionTime *int `json:"auto_completion_time,omitempty"`

	// ConversationId Сквозной идентификатор сообщения
	ConversationId *int `json:"conversation_id,omitempty"`

	// Extras Доступные доп.опции
	Extras *[]struct {
		// Count Количество опций
		Count *float32 `json:"count,omitempty"`

		// Duration Длительность
		Duration *float32 `json:"duration,omitempty"`

		// Name Наименование опции
		Name *string `json:"name,omitempty"`

		// Price Цена
		Price *float32 `json:"price,omitempty"`
	} `json:"extras,omitempty"`

	// Files Данные об изображениях
	Files *[]struct {
		// ConvertStatus Статус конвертации голосового сообщения
		ConvertStatus *TrackFilesConvertStatus `json:"convert_status,omitempty"`

		// DurationInMs Длительность голосового файла в миллисекундах
		DurationInMs *int `json:"duration_in_ms,omitempty"`

		// FileUrl Абсолютный урл файла на сервере
		FileUrl *string `json:"file_url,omitempty"`

		// Id Идентификатор файла
		Id *int `json:"id,omitempty"`

		// IsHeard Прослушано ли голосовое сообщение
		IsHeard *bool `json:"is_heard,omitempty"`

		// IsVoiceMessage Является ли голосовым сообщением
		IsVoiceMessage *bool `json:"is_voice_message,omitempty"`

		// MiniatureUrl Абсолютный урл миниатюры
		MiniatureUrl *string `json:"miniature_url,omitempty"`

		// Name Имя файла
		Name *int `json:"name,omitempty"`

		// Path Имя в файлохранилище
		Path *string `json:"path,omitempty"`

		// SizeInBytes Размер файла в байтах
		SizeInBytes *int `json:"size_in_bytes,omitempty"`

		// Status Статус файла
		Status *bool `json:"status,omitempty"`
	} `json:"files,omitempty"`

	// FromId Идентификатор отправителя
	FromId *int `json:"from_id"`

	// FromName Имя отправителя
	FromName *string `json:"from_name"`

	// Id Идентификатор сообщения
	Id *int `json:"id,omitempty"`

	// InboxId Идентификатор сообщения чата
	InboxId *int `json:"inbox_id,omitempty"`

	// IsUnread Прочитано ли сообщение
	IsUnread *bool `json:"is_unread,omitempty"`

	// MessageKey Ключ сообщения
	MessageKey *string `json:"message_key,omitempty"`

	// MiscTrackParams Дополнительные параметры
	MiscTrackParams *struct {
		// ArbitrationRating Оценка арбитража
		ArbitrationRating *int `json:"arbitration_rating,omitempty"`

		// IsArbitrationRatingAvailable Возможно сделать оценку по арбитражу
		IsArbitrationRatingAvailable *bool `json:"is_arbitration_rating_available,omitempty"`

		// IsRatingAffected Рейтинг продавца снижен в результате отмены
		IsRatingAffected *bool `json:"is_rating_affected,omitempty"`

		// OrderProgress Прогресс выполнения неэтапного заказа
		OrderProgress *int `json:"order_progress,omitempty"`

		// Portfolio Портфолио
		Portfolio *struct {
			// Crop Crop обложки
			Crop *map[string]interface{} `json:"crop,omitempty"`

			// DuplicateFrom Идентификатор портфолио из которого был создан текущий
			DuplicateFrom *float32 `json:"duplicate_from,omitempty"`

			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// Images Изображения, прикрепленные к портфолио
			Images *[]struct {
				// Link Ссылка на изображение
				Link *string `json:"link,omitempty"`

				// Position Позиция сортировки изображения
				Position *int `json:"position,omitempty"`

				// Thumbnail Ссылка на миниатюру изображения
				Thumbnail *string `json:"thumbnail,omitempty"`
			} `json:"images,omitempty"`

			// Photo Путь к фото
			Photo *string `json:"photo,omitempty"`

			// Title Название работы
			Title *string `json:"title,omitempty"`

			// Type Тип, 'photo' или 'видео'
			Type *string `json:"type,omitempty"`

			// Video Путь к видео
			Video *string `json:"video,omitempty"`

			// Videos Видеоролики, прикрепленные к портфолио
			Videos *[]struct {
				// Link Ссылка на видеоролик
				Link *string `json:"link,omitempty"`

				// Position Позиция сортировки видеоролика
				Position *int `json:"position,omitempty"`
			} `json:"videos,omitempty"`
		} `json:"portfolio,omitempty"`

		// ReasonType Причина отмены заказа
		ReasonType *string `json:"reason_type,omitempty"`

		// Receipt Чек
		Receipt *struct {
			// Error Ошибка
			Error *string `json:"error,omitempty"`

			// ErrorCodes Коды ошибок
			ErrorCodes *[]int `json:"error_codes,omitempty"`

			// Name Наименование услуги
			Name *string `json:"name,omitempty"`

			// Price Цена
			Price *float32 `json:"price,omitempty"`

			// ReceiptId Идентификатор чека
			ReceiptId *int `json:"receipt_id,omitempty"`

			// Status Статус загрузки
			Status *int `json:"status,omitempty"`

			// TaxNumber ИНН покупателя
			TaxNumber *string `json:"tax_number,omitempty"`
		} `json:"receipt,omitempty"`

		// StageOffers Встречное предложение
		StageOffers *[]struct {
			// Amount Сумма
			Amount *int `json:"amount,omitempty"`

			// Id Идентификатор предложения
			Id *int `json:"id,omitempty"`

			// Title Название
			Title *string `json:"title,omitempty"`
		} `json:"stage_offers,omitempty"`

		// StageOffersDurationInDays Количество дней по задачам трека
		StageOffersDurationInDays *int `json:"stage_offers_duration_in_days,omitempty"`

		// Tip Сумма вознаграждения
		Tip *float32 `json:"tip,omitempty"`

		// TipComment Комментарий вознаграждения
		TipComment *string `json:"tip_comment,omitempty"`
	} `json:"misc_track_params,omitempty"`

	// Quote Цитируемое сообщение трека
	Quote *TrackQuote `json:"quote,omitempty"`

	// SentTimestamp Время отправки UnixTime
	SentTimestamp *int `json:"sent_timestamp,omitempty"`

	// Stages Этапы, для трека = 32, 48
	Stages *[]struct {
		// Amount Цена
		Amount *float32 `json:"amount,omitempty"`

		// ArbitrageType В чью пользу разрешен арбитраж, если таковой был
		ArbitrageType *string `json:"arbitrage_type,omitempty"`

		// CurrencyId Идентификатор валюты
		CurrencyId *float32 `json:"currency_id,omitempty"`

		// Id Идентификатор этапа
		Id *float32 `json:"id,omitempty"`

		// Number Номер
		Number *float32 `json:"number,omitempty"`

		// Progress Прогресс
		Progress *float32 `json:"progress,omitempty"`

		// Status Статус
		Status *float32 `json:"status,omitempty"`

		// Title Заголовок
		Title *string `json:"title,omitempty"`
	} `json:"stages,omitempty"`

	// Status Статус
	Status *string `json:"status,omitempty"`

	// Text Текст сообщения
	Text *string `json:"text,omitempty"`

	// Title Заголовок
	Title *string `json:"title,omitempty"`

	// TranscriptionStatus Статус транскрибации, null - если успешно или сообщение не голосовое
	TranscriptionStatus *int `json:"transcription_status,omitempty"`

	// Type Тип сообщения
	Type *int `json:"type,omitempty"`

	// UpdatedAt Время изменения сообщения, UnixTime
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// TrackFilesConvertStatus Статус конвертации голосового сообщения
type TrackFilesConvertStatus string

// TrackFile Файл трека
type TrackFile struct {
	// FileUrl Абсолютный урл файла на сервере
	FileUrl *string `json:"file_url,omitempty"`

	// Id Идентификатор файла
	Id *int `json:"id,omitempty"`

	// MiniatureUrl Абсолютный урл миниатюры
	MiniatureUrl *string `json:"miniature_url,omitempty"`

	// Name Имя файла
	Name *int `json:"name,omitempty"`

	// Path Имя в файлохранилище
	Path *string `json:"path,omitempty"`

	// SizeInBytes Размер файла в байтах
	SizeInBytes *int `json:"size_in_bytes,omitempty"`

	// Status Статус файла
	Status *bool `json:"status,omitempty"`
}

// TrackOrder Данные о заказе
type TrackOrder struct {
	// Color Цвет заказа
	Color *int `json:"color,omitempty"`

	// Id ID заказа
	Id *int `json:"id,omitempty"`

	// Title Название заказа
	Title *string `json:"title,omitempty"`

	// WorkerId ID продавца
	WorkerId *int `json:"worker_id,omitempty"`
}

// TrackQuote Цитируемое сообщение трека
type TrackQuote struct {
	// ConversationId Сквозной идентификатор сообщения
	ConversationId *int `json:"conversation_id,omitempty"`

	// Files Данные об изображениях
	Files *[]TrackFile `json:"files,omitempty"`

	// FromId Идентификатор отправителя
	FromId *int `json:"from_id,omitempty"`

	// Id Идентификатор сообщения
	Id *int `json:"id,omitempty"`

	// Text Текст сообщения
	Text *string `json:"text,omitempty"`
}

// User Публичные данные пользователя
type User struct {
	// AchievmentsList Бейдж пользователя
	AchievmentsList *ProfileBadges `json:"achievments_list,omitempty"`

	// Addtime Дата регистрации
	Addtime *int `json:"addtime,omitempty"`

	// AllowedDialog Разрешено ли писать пользователю
	AllowedDialog *bool `json:"allowedDialog,omitempty"`

	// BadReviews Количество отрицательных отзывов
	BadReviews *int `json:"bad_reviews,omitempty"`

	// BlockedByUser Заблокирован ли диалог с пользователем (всегда false если запрос от неавторизованного пользователя)
	BlockedByUser *bool `json:"blocked_by_user,omitempty"`

	// CompletedOrdersCount Количество выполненных заказов
	CompletedOrdersCount *int `json:"completed_orders_count,omitempty"`

	// Cover Путь к баннеру пользователя
	Cover *string `json:"cover,omitempty"`

	// CustomRequestMinBudget Минимальный бюджет запроса на индивидуальный кворк (представлен только в случае если пользователь авторизован)
	CustomRequestMinBudget *float32 `json:"custom_request_min_budget,omitempty"`

	// Description Текст о себе
	Description *string `json:"description,omitempty"`

	// Fullname Настоящее имя
	Fullname *string `json:"fullname,omitempty"`

	// GoodReviews Количество положительных отзывов
	GoodReviews *int `json:"good_reviews,omitempty"`

	// Id Идентификатор пользователя
	Id *int `json:"id,omitempty"`

	// IsAllowCustomRequest Принимает ли пользователь запросы на индивидуальные кворки
	IsAllowCustomRequest *bool `json:"is_allow_custom_request,omitempty"`

	// IsCashlessPaymentAvailable Может ли работать по эскроу схеме
	IsCashlessPaymentAvailable *bool `json:"is_cashless_payment_available,omitempty"`

	// IsVerifiedWorker Верифицирован ли по паспорту или по адресу
	IsVerifiedWorker *bool `json:"is_verified_worker,omitempty"`

	// Kworks Кворки пользователя
	Kworks *ProfileKworks `json:"kworks,omitempty"`

	// KworksCount Количество активных кворков
	KworksCount *int `json:"kworks_count,omitempty"`

	// LevelDescription Название уровня продавца
	LevelDescription *string `json:"level_description,omitempty"`

	// LiveDate Дата последней активности на сайте
	LiveDate *int `json:"live_date,omitempty"`

	// Location Город или страна
	Location *string `json:"location,omitempty"`

	// Note Заметка о пользователе
	Note *struct {
		// PostedTimestamp Дата публикации
		PostedTimestamp *int `json:"posted_timestamp,omitempty"`

		// Text Текст заметки
		Text *int `json:"text,omitempty"`
	} `json:"note,omitempty"`

	// Online Онлайн ли пользователь
	Online *bool `json:"online,omitempty"`

	// OrderDoneIntimePersent Процент сданных вовремя заказов
	OrderDoneIntimePersent *int `json:"order_done_intime_persent,omitempty"`

	// OrderDonePersent Процент успешно сданных заказов
	OrderDonePersent *int `json:"order_done_persent,omitempty"`

	// OrderDoneRepeatPersent Процент повторных заказов
	OrderDoneRepeatPersent *int `json:"order_done_repeat_persent,omitempty"`

	// PortfolioList Портфолио пользователя
	PortfolioList *ProfilePortfolios `json:"portfolio_list,omitempty"`

	// Profession Специальность пользователя
	Profession *string `json:"profession"`

	// Profilepicture Путь к изображению аватара
	Profilepicture *string `json:"profilepicture,omitempty"`

	// Rating Рейтинг по 5 бальной шкале с 1 десятичным знаком
	Rating *string `json:"rating,omitempty"`

	// RatingCount Количество отзывов
	RatingCount *int `json:"rating_count,omitempty"`

	// Reviews Массив отзывов
	Reviews *[]UserReview `json:"reviews,omitempty"`

	// ReviewsCount Общее количество отзывов
	ReviewsCount *int `json:"reviews_count,omitempty"`

	// Skills Навыки
	Skills *[]struct {
		// Id Идентификатор
		Id *int `json:"id,omitempty"`

		// Name Название
		Name *string `json:"name,omitempty"`
	} `json:"skills,omitempty"`

	// Slogan Слоган - не заполнен
	Slogan *string `json:"slogan,omitempty"`

	// TimezoneId id временной зоны
	TimezoneId *int `json:"timezoneId,omitempty"`

	// Username Имя пользователя
	Username *string `json:"username,omitempty"`
}

// UserAnswer Ответ продавца на отзыв
type UserAnswer struct {
	// Id Идентификатор ответа
	Id *int `json:"id,omitempty"`

	// Profilepicture Ссылка на изображения аватара
	// 	 *     пользователя
	Profilepicture *string `json:"profilepicture,omitempty"`

	// Text Текст ответа
	Text *string `json:"text,omitempty"`

	// TimeAdded Дата ответа UNIXTIME
	TimeAdded *int `json:"time_added,omitempty"`

	// UserId Идентификатор пользователя - продавца
	UserId *int `json:"user_id,omitempty"`

	// Username Имя пользователя
	Username *string `json:"username,omitempty"`
}

// UserReview Отзыв о пользователе
type UserReview struct {
	// Answer Ответ продавца на отзыв
	Answer *UserAnswer `json:"answer,omitempty"`

	// AutoMode Статус автоматического создания отзыва: inwork_time_over - Просрочено время взятия в работу, time_over - Просрочено время выполнения, incorrect_execute - Некорректное выполнение
	AutoMode *string `json:"auto_mode"`

	// Bad Является ли отзыв отрицательным
	Bad *bool `json:"bad,omitempty"`

	// Good Является ли отзыв положительным
	Good *bool `json:"good,omitempty"`

	// Id Идентификатор отзыва. Может быть NULL если это портфолио
	Id *int `json:"id,omitempty"`

	// Kwork Объект кворка
	Kwork *struct {
		// Active Статус активности кворка, 0 - на модерации, 1 - активный, 2 - заблокирован (за штрафные баллы), 3 - удален, 4 - отклонен модератором, 5 - на паузе (за большую очередь),
		Active *int `json:"active,omitempty"`

		// Feat Статус показа кворка
		Feat *bool `json:"feat,omitempty"`

		// Id Идентификатор кворка
		Id *int `json:"id,omitempty"`

		// Title Название кворка
		Title *string `json:"title,omitempty"`
	} `json:"kwork,omitempty"`

	// Portfolio Портфолио
	Portfolio *Portfolio `json:"portfolio,omitempty"`

	// Text Текст отзыва. Может быть NULL если это портфолио
	Text *string `json:"text"`

	// TimeAdded Дата добавления отзыва или портфолио UNIXTIME
	TimeAdded *int `json:"time_added,omitempty"`

	// Writer Краткие данные автора отзыва
	Writer *UserReviewWriter `json:"writer,omitempty"`
}

// UserReviewWriter Краткие данные автора отзыва
type UserReviewWriter struct {
	// Id Идентификатор продавца
	Id *int `json:"id,omitempty"`

	// Profilepicture Ссылка на изображения аватара пользователя
	Profilepicture *string `json:"profilepicture,omitempty"`

	// Username Имя пользователя
	Username *string `json:"username,omitempty"`
}

// UserWorker Данные продавца
type UserWorker struct {
	// Fullname Полное имя пользователя
	Fullname *string `json:"fullname,omitempty"`

	// Id Идентификатор продавца
	Id *int `json:"id,omitempty"`

	// IsOnline Онлайн ли пользователь
	IsOnline *bool `json:"is_online,omitempty"`

	// Profilepicture Путь к аватару
	Profilepicture *string `json:"profilepicture,omitempty"`

	// Rating Рейтинг по пятибальной шкале
	Rating *float32 `json:"rating,omitempty"`

	// RatingCount Количество отзывов
	RatingCount *int `json:"rating_count,omitempty"`

	// ReviewsCount Общее количество отзывов
	ReviewsCount *int `json:"reviews_count,omitempty"`

	// Username Имя пользователя
	Username *string `json:"username,omitempty"`
}

// UserNotification defines model for user_notification.
type UserNotification struct {
	// Added Дата создания unixtime
	Added *int `json:"added,omitempty"`

	// EntityId Идентификатор связанной сущности
	EntityId *int `json:"entity_id,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// IsOtherUserOnline Онлайн ли другой пользователь
	IsOtherUserOnline *bool `json:"isOtherUserOnline,omitempty"`

	// Link Ссылка для перехода
	Link *string `json:"link,omitempty"`

	// OtherUserAvatar Ссылка на изображение аватара другого пользователя
	OtherUserAvatar *string `json:"otherUserAvatar,omitempty"`

	// OtherUserId Идентификатор другого пользователя
	OtherUserId *int `json:"otherUserId,omitempty"`

	// OtherUserName Имя другого пользователя
	OtherUserName *string `json:"otherUserName,omitempty"`
}

// VolumeType Тип числового объема
type VolumeType struct {
	// ContainsId Единица объема для contains_value
	ContainsId *string `json:"contains_id,omitempty"`

	// ContainsValue Количество в других единицах
	ContainsValue *string `json:"contains_value,omitempty"`

	// GroupOrder Сортировка для группы
	GroupOrder *string `json:"group_order,omitempty"`

	// Id Идентификатор
	Id *int `json:"id,omitempty"`

	// Lang Язык
	Lang *VolumeTypeLang `json:"lang,omitempty"`

	// Name Наименование в единственном числе
	Name *string `json:"name,omitempty"`

	// NameAccusative Наименование в винительном падеже
	NameAccusative *string `json:"name_accusative,omitempty"`

	// NamePlural1119 Наименование во множественном числе, от 11 до 19
	NamePlural1119 *string `json:"name_plural_11_19,omitempty"`

	// NamePlural24 Наименование во множественном числе, от 2 до 4
	NamePlural24 *string `json:"name_plural_2_4,omitempty"`

	// NameShort Сокращенное наименование
	NameShort *string `json:"name_short,omitempty"`

	// VolumeTypeGroupId Идентификатор группы объема услуг
	VolumeTypeGroupId *string `json:"volume_type_group_id,omitempty"`
}

// VolumeTypeLang Язык
type VolumeTypeLang string

// WantPayer Проекты для покупателя
type WantPayer struct {
	// AllowHigherPrice Готов ли покупатель рассмотреть предложения с ценой выше
	AllowHigherPrice *bool `json:"allow_higher_price,omitempty"`

	// CategoryBasePrice Базовая стоимость работ в категории запроса
	CategoryBasePrice *int `json:"category_base_price,omitempty"`

	// DateActive Дата активации проекта
	DateActive *int `json:"date_active"`

	// DateCreate Дата создания проекта
	DateCreate *int `json:"date_create"`

	// DateExpire Дата окончания проекта
	DateExpire *int `json:"date_expire"`

	// DateReject Дата отклонения проекта
	DateReject *int `json:"date_reject"`

	// Description Описание проекта
	Description *string `json:"description,omitempty"`

	// Id Идентификатор проекта
	Id *int `json:"id,omitempty"`

	// Offers Количество предложений по проекту
	Offers *int `json:"offers,omitempty"`

	// Orders Количество заказов по проекту
	Orders *int `json:"orders,omitempty"`

	// PossiblePriceLimit Лимит цены предложений с учетом готовности покупателя рассмотреть предложения с ценой выше
	PossiblePriceLimit *int `json:"possible_price_limit,omitempty"`

	// PriceLimit Бюджет проекта
	PriceLimit *int `json:"price_limit,omitempty"`

	// Status Статус проекта
	Status *string `json:"status,omitempty"`

	// Title Заголовок проекта
	Title *string `json:"title,omitempty"`

	// Views Количество просмотров
	Views *int `json:"views,omitempty"`

	// ViewsHistory Массив количества просмотров, сгруппированный по дням
	ViewsHistory *struct {
		// Date Дата группиовки в timestamp
		Date *int `json:"date,omitempty"`

		// ViewCount Количество просмотров в день
		ViewCount *int `json:"view_count,omitempty"`
	} `json:"views_history,omitempty"`

	// WantStatusId Идентификатор статуса (альтернативный статус)
	WantStatusId *int `json:"want_status_id,omitempty"`
}

// WantWorker Поля запроса(проекта) для продавца
type WantWorker struct {
	// AchievementsList Бейджи пользователя
	AchievementsList *Achievements `json:"achievements_list,omitempty"`

	// AllowHigherPrice Готов ли покупатель рассмотреть предложения с ценой выше
	AllowHigherPrice *bool `json:"allow_higher_price,omitempty"`

	// AlreadyWork Статус последнего заказа между пользователями
	AlreadyWork *WantWorkerAlreadyWork `json:"already_work,omitempty"`

	// CategoryBasePrice Базовая стоимость работ в категории запроса
	CategoryBasePrice *int `json:"category_base_price,omitempty"`

	// CategoryId Идентификатор подрубрики проекта
	CategoryId *int `json:"category_id,omitempty"`

	// DateConfirm Дата первого подтверждения модератором (или переподтвержения при перезапуске из архива)
	DateConfirm *int `json:"date_confirm,omitempty"`

	// Description Краткое описание проекта
	Description *string `json:"description,omitempty"`

	// Id ID запроса(проекта)
	Id *int `json:"id,omitempty"`

	// IsViewed Просмотрен ли текущим пользователем
	IsViewed *bool `json:"is_viewed,omitempty"`

	// Offers Количество предложений
	Offers *int `json:"offers,omitempty"`

	// ParentCategoryId Идентификатор рубрики проекта
	ParentCategoryId *int `json:"parent_category_id,omitempty"`

	// PossiblePriceLimit Лимит цены предложений с учетом готовности покупателя рассмотреть предложения с ценой выше
	PossiblePriceLimit *int `json:"possible_price_limit,omitempty"`

	// Price Бюджет проекта
	Price *int `json:"price,omitempty"`

	// ProfilePicture Изображение профиля
	ProfilePicture *string `json:"profile_picture,omitempty"`

	// Status Статус запроса(проекта)
	Status *string `json:"status,omitempty"`

	// TimeLeft Время, оставшееся до закрытия проекта UNIX
	TimeLeft *int `json:"time_left,omitempty"`

	// Title Заголовок
	Title *string `json:"title,omitempty"`

	// UserActiveProjectsCount Количество активных проектов
	UserActiveProjectsCount *int `json:"user_active_projects_count,omitempty"`

	// UserHiredPercent Процент нанятых продавцов на бирже
	UserHiredPercent *int `json:"user_hired_percent,omitempty"`

	// UserId ID пользователя
	UserId *int `json:"user_id,omitempty"`

	// UserNeedPortfolio Кодовое значение необходимости портфолио
	UserNeedPortfolio *int `json:"user_need_portfolio,omitempty"`

	// UserNeedPortfolioRubricName Название рубрики, в которой необходимо портфолио
	UserNeedPortfolioRubricName *string `json:"user_need_portfolio_rubric_name,omitempty"`

	// UserProjectsCount Количество проектов на бирже покупателя
	UserProjectsCount *int `json:"user_projects_count,omitempty"`

	// Username Логин пользователя
	Username *string `json:"username,omitempty"`
}

// WantWorkerAlreadyWork Статус последнего заказа между пользователями
type WantWorkerAlreadyWork int

// WantsFilter Предустановленный фильтр
type WantsFilter struct {
	// Categories Массив объектов рубрик
	Categories *[]FavouriteCategory `json:"categories,omitempty"`

	// HiringTo Процент найма от (не обязательно)
	HiringTo *int `json:"hiring-to,omitempty"`

	// KworksFilterFrom Количество предложений от (не обязательно)
	KworksFilterFrom *int `json:"kworks-filter-from,omitempty"`

	// KworksFilterTo Количество предложений до (не обязательно)
	KworksFilterTo *int `json:"kworks-filter-to,omitempty"`

	// PriceFrom Бюджет от (не обязательно)
	PriceFrom *int `json:"price-from,omitempty"`

	// PriceTo Бюджет до (не обязательно)
	PriceTo *int `json:"price-to,omitempty"`
}

// WantsList Проекты для покупателя сгруппированные по альтернативному статусу
type WantsList struct {
	// Id Идентификатор статуса
	Id *int `json:"id,omitempty"`

	// Order Порядковый номер вкладки
	Order *int `json:"order,omitempty"`

	// ProjectsCount Количество запросов на услугу в статусе
	ProjectsCount *int `json:"projects_count,omitempty"`

	// Title Отображаемое название статуса
	Title *string `json:"title,omitempty"`

	// Tootlip Описание статуса
	Tootlip *string `json:"tootlip,omitempty"`

	// Wants Список заявок на услугу
	Wants *[]WantPayer `json:"wants,omitempty"`
}

// WithTracks defines model for withTracks.
type WithTracks = int

// ErrorResponse Ошибка
type ErrorResponse = Error

// AuthSuccess defines model for auth-success.
type AuthSuccess struct {
	// Response Данные
	Response *struct {
		// Expired Время жизни токена в секундах
		Expired *int `json:"expired,omitempty"`

		// Token Авторизационный токен
		Token *string `json:"token,omitempty"`
	} `json:"response,omitempty"`

	// Success Флаг успешности
	Success *bool `json:"success,omitempty"`
}

// SimpleHtml defines model for simple_html.
type SimpleHtml struct {
	// Response Данные
	Response *struct {
		// Html Html строка
		Html *string `json:"html,omitempty"`
	} `json:"response,omitempty"`

	// Success Флаг успешности
	Success *bool `json:"success,omitempty"`
}

// Success defines model for success.
type Success struct {
	// Success Флаг успешности
	Success *bool `json:"success,omitempty"`
}

// AcceptExtrasParams defines parameters for AcceptExtras.
type AcceptExtrasParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// TrackId Идентификатор трека
	TrackId int `form:"track_id" json:"track_id"`
}

// AcceptStageSuggestionParams defines parameters for AcceptStageSuggestion.
type AcceptStageSuggestionParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// ActorFormdataBody defines parameters for Actor.
type ActorFormdataBody struct {
	// AppPushOnLastShowTime Последняя дата показа предпреждения о включении уведомления
	AppPushOnLastShowTime *string `form:"appPushOnLastShowTime,omitempty" json:"appPushOnLastShowTime,omitempty"`

	// IsAppPushOn Настройка: включены уведомления
	IsAppPushOn *string `form:"isAppPushOn,omitempty" json:"isAppPushOn,omitempty"`

	// IsAppWhiteListed Настройка: находится ли приложение в белом списке
	IsAppWhiteListed *string `form:"isAppWhiteListed,omitempty" json:"isAppWhiteListed,omitempty"`

	// Uad Уникальный идентификатор устройства
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`

	// WhiteListedLastShowTime Последняя дата показа предпреждения о белом списке пользователю
	WhiteListedLastShowTime *string `form:"whiteListedLastShowTime,omitempty" json:"whiteListedLastShowTime,omitempty"`
}

// AddFavoriteCategoriesParams defines parameters for AddFavoriteCategories.
type AddFavoriteCategoriesParams struct {
	// Categories Идентификаторы категорий для добавления в список любимых
	Categories string `form:"categories" json:"categories"`
}

// AddNewPhoneNumberParams defines parameters for AddNewPhoneNumber.
type AddNewPhoneNumberParams struct {
	// Hash Валидационный кеш
	Hash *string `form:"hash,omitempty" json:"hash,omitempty"`

	// Phone Новый номер телефона пользователя
	Phone *string `form:"phone,omitempty" json:"phone,omitempty"`
}

// AddPhoneNumberParams defines parameters for AddPhoneNumber.
type AddPhoneNumberParams struct {
	// Phone Номер телефона пользователя
	Phone *string `form:"phone,omitempty" json:"phone,omitempty"`
}

// AddStageParams defines parameters for AddStage.
type AddStageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// ExtendTime Добавить срок к заказу
	ExtendTime int `form:"extend_time" json:"extend_time"`

	// Stages Параметры этапов
	Stages map[string]map[string]interface{} `form:"stages" json:"stages"`
}

// AllowInboxRequestParams defines parameters for AllowInboxRequest.
type AllowInboxRequestParams struct {
	// InboxId Идентификатор сообщения
	InboxId int `form:"inboxId" json:"inboxId"`

	// IsAccept Разрешение на переписку, 1 - разрешено, 0 - запрещено
	IsAccept int `form:"isAccept" json:"isAccept"`
}

// AllowMobilePushParams defines parameters for AllowMobilePush.
type AllowMobilePushParams struct {
	// Allow Флаг, разрешена ли отправка пуша
	Allow AllowMobilePushParamsAllow `form:"allow" json:"allow"`
}

// AllowMobilePushParamsAllow defines parameters for AllowMobilePush.
type AllowMobilePushParamsAllow int

// AllowOrderPortfolioUploadParams defines parameters for AllowOrderPortfolioUpload.
type AllowOrderPortfolioUploadParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// AllowPushNotificationsSoundParams defines parameters for AllowPushNotificationsSound.
type AllowPushNotificationsSoundParams struct {
	// Allow Значение флага: 0 - выключить звук уведомлений / 1 - включить
	Allow AllowPushNotificationsSoundParamsAllow `form:"allow" json:"allow"`
}

// AllowPushNotificationsSoundParamsAllow defines parameters for AllowPushNotificationsSound.
type AllowPushNotificationsSoundParamsAllow string

// AppleSignInFormdataBody defines parameters for AppleSignIn.
type AppleSignInFormdataBody struct {
	// AppleUserId Идентификатор пользователя Apple
	AppleUserId interface{} `form:"apple_user_id" json:"apple_user_id"`

	// AuthorizationCode Код авторизации
	AuthorizationCode interface{} `form:"authorization_code" json:"authorization_code"`

	// Email Email пользователя
	Email interface{} `form:"email,omitempty" json:"email,omitempty"`

	// Token Токен пользователя в AppleID
	Token interface{} `form:"token" json:"token"`

	// UserType Тип пользователя
	// 	 *                `1` Покупатель
	// 	 *                `2` Продавец
	UserType interface{} `form:"user_type,omitempty" json:"user_type,omitempty"`
}

// ApplyFiltersParams defines parameters for ApplyFilters.
type ApplyFiltersParams struct {
	// Categories Идентификаторы выбранных любимых рубрик
	Categories string `form:"categories" json:"categories"`

	// PriceFrom Бюджет от (включительно)
	PriceFrom *int `form:"price_from,omitempty" json:"price_from,omitempty"`

	// PriceTo Бюджет до (включительно)
	PriceTo *int `form:"price_to,omitempty" json:"price_to,omitempty"`

	// HiringFrom Процент найма от
	HiringFrom *int `form:"hiring_from,omitempty" json:"hiring_from,omitempty"`

	// KworksFilterFrom Количество предложений от (не включительно)
	KworksFilterFrom *int `form:"kworks_filter_from,omitempty" json:"kworks_filter_from,omitempty"`

	// KworksFilterTo Количество предложений до (включительно)
	KworksFilterTo *int `form:"kworks_filter_to,omitempty" json:"kworks_filter_to,omitempty"`

	// Offers Идентификаторы интервалов фильтра предложений через запятую
	Offers *string `form:"offers,omitempty" json:"offers,omitempty"`
}

// ApproveOrderParams defines parameters for ApproveOrder.
type ApproveOrderParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Portfolio Разрешение на загрузку работы в портфолио, 1 - разрешено, 0 - не разрешено
	Portfolio int `form:"portfolio" json:"portfolio"`
}

// ApproveOrderStageParams defines parameters for ApproveOrderStage.
type ApproveOrderStageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// StageIds Идентификаторы этапов
	StageIds *[]int `form:"stageIds[],omitempty" json:"stageIds[],omitempty"`
}

// ArchiveDialogParams defines parameters for ArchiveDialog.
type ArchiveDialogParams struct {
	// ArchiveUserId Идентификатор собеседника
	ArchiveUserId int `form:"archiveUserId" json:"archiveUserId"`
}

// BlockDialogParams defines parameters for BlockDialog.
type BlockDialogParams struct {
	// BlockUserId Идентификатор пользователя
	BlockUserId int `form:"blockUserId" json:"blockUserId"`
}

// CancelOrderAwaitingPaymentParams defines parameters for CancelOrderAwaitingPayment.
type CancelOrderAwaitingPaymentParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// CancelOrderByPayerFormdataBody defines parameters for CancelOrderByPayer.
type CancelOrderByPayerFormdataBody struct {
	// Message Текст сообщения
	Message *string `form:"message,omitempty" json:"message,omitempty"`
}

// CancelOrderByPayerParams defines parameters for CancelOrderByPayer.
type CancelOrderByPayerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Message Комментарий пользователя
	Message *string `form:"message,omitempty" json:"message,omitempty"`

	// ReasonType Тип причины отмены
	ReasonType string `form:"reason_type" json:"reason_type"`

	// HideKworks Нужно ли скрывать пользовательские кворки
	HideKworks *int `form:"hideKworks,omitempty" json:"hideKworks,omitempty"`
}

// CancelOrderByWorkerFormdataBody defines parameters for CancelOrderByWorker.
type CancelOrderByWorkerFormdataBody struct {
	// Message Текст сообщения
	Message *string `form:"message,omitempty" json:"message,omitempty"`
}

// CancelOrderByWorkerParams defines parameters for CancelOrderByWorker.
type CancelOrderByWorkerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// ReasonType Тип причины отмены
	ReasonType string `form:"reason_type" json:"reason_type"`
}

// CatalogCategoriesParams defines parameters for CatalogCategories.
type CatalogCategoriesParams struct {
	// RubricId Идентификатор рубрики
	RubricId int `form:"rubricId" json:"rubricId"`
}

// CatalogFiltersParams defines parameters for CatalogFilters.
type CatalogFiltersParams struct {
	// CategoryId Идентификатор категории
	CategoryId *int `form:"categoryId,omitempty" json:"categoryId,omitempty"`

	// ClassifierId Идентификатор классификации
	ClassifierId *int `form:"classifierId,omitempty" json:"classifierId,omitempty"`

	// IsSearch Получить фильтры для поиска
	IsSearch *CatalogFiltersParamsIsSearch `form:"isSearch,omitempty" json:"isSearch,omitempty"`

	// Query Строка поиска
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Unembedded Id всех выбранных значений в фильтрах с is_unembedded = 1, склеенных в kebab-case
	Unembedded *string `form:"unembedded,omitempty" json:"unembedded,omitempty"`

	// JSONСФильтрами Остальные фильтры, выбранные пользователем. Подробнее https://kworkteam.ru/code/docs/filtry-v-kataloge-metody-api/
	JSONСФильтрами *map[string]interface{} `form:"JSON с фильтрами,omitempty" json:"JSON с фильтрами,omitempty"`
}

// CatalogFiltersParamsIsSearch defines parameters for CatalogFilters.
type CatalogFiltersParamsIsSearch int

// CategoryParams defines parameters for Category.
type CategoryParams struct {
	// CategoryId Идентификатор категории
	CategoryId *int `form:"category_id,omitempty" json:"category_id,omitempty"`

	// AttributeId Массив идентификаторов атрибутов
	AttributeId *[]int `form:"attribute_id,omitempty" json:"attribute_id,omitempty"`
}

// CategoryAttributesParams defines parameters for CategoryAttributes.
type CategoryAttributesParams struct {
	// CategoryId Идентификатор категории
	CategoryId int `form:"category_id" json:"category_id"`
}

// ChangePasswordFormdataBody defines parameters for ChangePassword.
type ChangePasswordFormdataBody struct {
	// Password Новый пароль
	Password string `form:"password" json:"password"`
}

// ChangePayerSubRoleParams defines parameters for ChangePayerSubRole.
type ChangePayerSubRoleParams struct {
	// PayerSubRole Дочерняя роль покупателя
	PayerSubRole int `form:"payerSubRole" json:"payerSubRole"`
}

// ChangeUsernameFormdataBody defines parameters for ChangeUsername.
type ChangeUsernameFormdataBody struct {
	// Username Новый логин пользователя
	Username string `form:"username" json:"username"`
}

// CheckLoginFormdataBody defines parameters for CheckLogin.
type CheckLoginFormdataBody struct {
	// Login Логин пользователя
	Login string `form:"login" json:"login"`
}

// CitiesParams defines parameters for Cities.
type CitiesParams struct {
	// CountryId Идентификатор страны
	CountryId int `form:"countryId" json:"countryId"`
}

// ConfirmCancelOrderRequestByPayerParams defines parameters for ConfirmCancelOrderRequestByPayer.
type ConfirmCancelOrderRequestByPayerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// ReplyType Согласен ли с причиной отмены
	ReplyType ConfirmCancelOrderRequestByPayerParamsReplyType `form:"reply_type" json:"reply_type"`
}

// ConfirmCancelOrderRequestByPayerParamsReplyType defines parameters for ConfirmCancelOrderRequestByPayer.
type ConfirmCancelOrderRequestByPayerParamsReplyType string

// ConfirmCancelOrderRequestByWorkerParams defines parameters for ConfirmCancelOrderRequestByWorker.
type ConfirmCancelOrderRequestByWorkerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// CreateAnswerFormdataBody defines parameters for CreateAnswer.
type CreateAnswerFormdataBody struct {
	// ReviewId Идентификатор отзыва
	ReviewId int `form:"review_id" json:"review_id"`

	// Text Текст отзыва
	Text string `form:"text" json:"text"`
}

// CreateKworkComplainFormdataBody defines parameters for CreateKworkComplain.
type CreateKworkComplainFormdataBody struct {
	// GRecaptchaResponse Данные recaptcha - необходим если ранее пришел код ошибки 118
	GRecaptchaResponse *string `form:"g-recaptcha-response,omitempty" json:"g-recaptcha-response,omitempty"`

	// Message Текст жалобы
	Message *string `form:"message,omitempty" json:"message,omitempty"`
}

// CreateKworkComplainParams defines parameters for CreateKworkComplain.
type CreateKworkComplainParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`

	// CategoryId Идентификатор категории жалобы
	CategoryId int `form:"category_id" json:"category_id"`

	// FilesNew Идентификаторы ранее загруженных файлов через /fileUpload
	FilesNew *[]int `form:"files[new][],omitempty" json:"files[new][],omitempty"`

	// Email Почта отправителя жалобы (для неавторизованного)
	Email *string `form:"email,omitempty" json:"email,omitempty"`
}

// CreatePortfolioParams defines parameters for CreatePortfolio.
type CreatePortfolioParams struct {
	// Title Название
	Title string `form:"title" json:"title"`

	// Images Загруженные картинки
	Images map[string]map[string]interface{} `form:"images" json:"images"`

	// Cover Параметры обложки
	Cover map[string]map[string]interface{} `form:"cover" json:"cover"`

	// AttributesIds Аттрибуты
	AttributesIds *[]int `form:"attributes_ids[],omitempty" json:"attributes_ids[],omitempty"`

	// CategoryId Идентификатор категории, не обязателен, если указан order_id
	CategoryId *int `form:"category_id,omitempty" json:"category_id,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int `form:"order_id,omitempty" json:"order_id,omitempty"`
}

// CreateReviewFormdataBody defines parameters for CreateReview.
type CreateReviewFormdataBody struct {
	// OrderId Идентификатор завершенного заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Text Текст отзыва
	Text string `form:"text" json:"text"`

	// Type Тип отзыва положительный или отрицательный
	Type CreateReviewFormdataBodyType `form:"type" json:"type"`
}

// CreateReviewFormdataBodyType defines parameters for CreateReview.
type CreateReviewFormdataBodyType string

// CreateStageParams defines parameters for CreateStage.
type CreateStageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// ExtendTime Добавить срок к заказу
	ExtendTime int `form:"extend_time" json:"extend_time"`

	// Stages Параметры этапов
	Stages map[string]map[string]interface{} `form:"stages" json:"stages"`
}

// DelFavoriteCategoriesParams defines parameters for DelFavoriteCategories.
type DelFavoriteCategoriesParams struct {
	// Categories Идентификаторы категорий для удаления из списка любимых
	Categories string `form:"categories" json:"categories"`
}

// DeleteCancelOrderRequestByPayerParams defines parameters for DeleteCancelOrderRequestByPayer.
type DeleteCancelOrderRequestByPayerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// DeleteCancelOrderRequestByWorkerParams defines parameters for DeleteCancelOrderRequestByWorker.
type DeleteCancelOrderRequestByWorkerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// DeleteKworkParams defines parameters for DeleteKwork.
type DeleteKworkParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`
}

// DeleteOfferParams defines parameters for DeleteOffer.
type DeleteOfferParams struct {
	// Id Идентификатор предложения к запросу на услугу
	Id int `form:"id" json:"id"`
}

// DeleteOrderNoteParams defines parameters for DeleteOrderNote.
type DeleteOrderNoteParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// DeletePortfolioParams defines parameters for DeletePortfolio.
type DeletePortfolioParams struct {
	// PortfolioId Идентификатор портфолио
	PortfolioId int `form:"portfolio_id" json:"portfolio_id"`

	// Unlink Флаг - следует ли только отвязать портфолио
	Unlink int `form:"unlink" json:"unlink"`
}

// DeleteReviewParams defines parameters for DeleteReview.
type DeleteReviewParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// DeleteStageParams defines parameters for DeleteStage.
type DeleteStageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// StageId Идентификатор этапа
	StageId int `form:"stageId" json:"stageId"`
}

// DeleteUserNoteParams defines parameters for DeleteUserNote.
type DeleteUserNoteParams struct {
	// UserId Идентификатор пользователя
	UserId int `form:"user_id" json:"user_id"`
}

// DeleteWantParams defines parameters for DeleteWant.
type DeleteWantParams struct {
	// Id Идентификатор запроса на услугу (проекта)
	Id int `form:"id" json:"id"`
}

// DialogsParams defines parameters for Dialogs.
type DialogsParams struct {
	// Page Cтраница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// ExcludedIds Исключенные из выборки пользователи
	ExcludedIds *string `form:"excludedIds,omitempty" json:"excludedIds,omitempty"`

	// WithTracks Учитывать треки
	WithTracks *WithTracks `form:"withTracks,omitempty" json:"withTracks,omitempty"`
}

// EditAnswerFormdataBody defines parameters for EditAnswer.
type EditAnswerFormdataBody struct {
	// AnswerId Идентификатор ответа на отзыв
	AnswerId int `form:"answer_id" json:"answer_id"`

	// Text Новый текст ответа на отзыв
	Text string `form:"text" json:"text"`
}

// EditPortfolioParams defines parameters for EditPortfolio.
type EditPortfolioParams struct {
	// Id Идентификатор портфолио
	Id int `form:"id" json:"id"`

	// Title Название
	Title string `form:"title" json:"title"`

	// CategoryId Идентификатор категории
	CategoryId int `form:"category_id" json:"category_id"`

	// Images Загруженные картинки
	Images map[string]map[string]interface{} `form:"images" json:"images"`

	// Cover Параметры обложки
	Cover map[string]map[string]interface{} `form:"cover" json:"cover"`

	// AttributesIds Аттрибуты
	AttributesIds *[]int `form:"attributes_ids[],omitempty" json:"attributes_ids[],omitempty"`

	// KworkId Идентификатор кворка
	KworkId *int `form:"kwork_id,omitempty" json:"kwork_id,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int `form:"order_id,omitempty" json:"order_id,omitempty"`
}

// EditReviewFormdataBody defines parameters for EditReview.
type EditReviewFormdataBody struct {
	// OrderId Идентификатор завершенного заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Text Текст отзыва
	Text string `form:"text" json:"text"`

	// Type Тип отзыва положительный или отрицательный
	Type EditReviewFormdataBodyType `form:"type" json:"type"`
}

// EditReviewFormdataBodyType defines parameters for EditReview.
type EditReviewFormdataBodyType string

// EditStageParams defines parameters for EditStage.
type EditStageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// ExtendTime Добавить срок к заказу
	ExtendTime int `form:"extendTime" json:"extendTime"`

	// Stages Параметры этапов
	Stages map[string]map[string]interface{} `form:"stages" json:"stages"`
}

// EmailVerificationLetterParams defines parameters for EmailVerificationLetter.
type EmailVerificationLetterParams struct {
	// Email Email для смены и последующей отправки на него
	Email *string `form:"email,omitempty" json:"email,omitempty"`
}

// FavoriteKworksParams defines parameters for FavoriteKworks.
type FavoriteKworksParams struct {
	// Page Номер страницы
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// FcmNotificationsReadParams defines parameters for FcmNotificationsRead.
type FcmNotificationsReadParams struct {
	// MessageIds Идентификаторы сообщений FCM
	MessageIds []string `form:"messageIds[]" json:"messageIds[]"`
}

// FcmNotificationsReceivedParams defines parameters for FcmNotificationsReceived.
type FcmNotificationsReceivedParams struct {
	// MessageIds Идентификаторы сообщений FCM
	MessageIds []string `form:"messageIds[]" json:"messageIds[]"`
}

// FcmTokenRequestFailedParams defines parameters for FcmTokenRequestFailed.
type FcmTokenRequestFailedParams struct {
	// Os Тип операционный системы
	Os string `form:"os" json:"os"`

	// OsVersion Версия операционной системы
	OsVersion string `form:"os_version" json:"os_version"`

	// Device Модель устройства
	Device string `form:"device" json:"device"`

	// AppVersion Версия мобильного приложения
	AppVersion string `form:"app_version" json:"app_version"`

	// Uad Уникальный идентификатор устройства
	Uad string `form:"uad" json:"uad"`

	// CancelReason Описание ошибки
	CancelReason string `form:"cancel_reason" json:"cancel_reason"`
}

// FileDeleteParams defines parameters for FileDelete.
type FileDeleteParams struct {
	// FileId Идентификатор удаляемого файла
	FileId int `form:"file_id" json:"file_id"`
}

// FileUploadMultipartBody defines parameters for FileUpload.
type FileUploadMultipartBody struct {
	// UploadFiles Файл
	UploadFiles openapi_types.File `json:"upload_files"`
}

// GetActorInfoFormdataBody defines parameters for GetActorInfo.
type GetActorInfoFormdataBody struct {
	// Uad Уникальный идентификатор устройства
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`
}

// GetArbitrationReasonsParams defines parameters for GetArbitrationReasons.
type GetArbitrationReasonsParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`
}

// GetBadgesInfoFormdataBody defines parameters for GetBadgesInfo.
type GetBadgesInfoFormdataBody struct {
	// Uad Уникальный идентификатор устройства
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`
}

// GetBillRefillUrlParams defines parameters for GetBillRefillUrl.
type GetBillRefillUrlParams struct {
	// Sum Сумма
	Sum *float32 `form:"sum,omitempty" json:"sum,omitempty"`
}

// GetCaptchaStatusParams defines parameters for GetCaptchaStatus.
type GetCaptchaStatusParams struct {
	// Email Почта
	Email *string `form:"email,omitempty" json:"email,omitempty"`
}

// GetChannelParams defines parameters for GetChannel.
type GetChannelParams struct {
	// Uad Уникальный идентификатор устройства
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`
}

// GetCompanyDetailsParams defines parameters for GetCompanyDetails.
type GetCompanyDetailsParams struct {
	// TaxNumber ИНН
	TaxNumber string `form:"tax_number" json:"tax_number"`
}

// GetCustomOptionsPresetsParams defines parameters for GetCustomOptionsPresets.
type GetCustomOptionsPresetsParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// GetDialogParams defines parameters for GetDialog.
type GetDialogParams struct {
	// Id Идентификатор собеседника
	Id int `form:"id" json:"id"`

	// WithTracks Учитывать треки
	WithTracks *WithTracks `form:"withTracks,omitempty" json:"withTracks,omitempty"`
}

// GetExtrasAvailableForOrderParams defines parameters for GetExtrasAvailableForOrder.
type GetExtrasAvailableForOrderParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`
}

// GetHiddenKworksParams defines parameters for GetHiddenKworks.
type GetHiddenKworksParams struct {
	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetInboxTracksParams defines parameters for GetInboxTracks.
type GetInboxTracksParams struct {
	// Username Логин юзера
	Username string `form:"username" json:"username"`

	// Page Страница выдачи (если не задана, то выводится последняя)
	Page *string `form:"page,omitempty" json:"page,omitempty"`

	// LastConversationId Идентификатор сообщения
	LastConversationId *int `form:"lastConversationId,omitempty" json:"lastConversationId,omitempty"`

	// Direction Направление поиска сообщений
	Direction *GetInboxTracksParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Limit Лимит количества сообщений
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetInboxTracksParamsDirection defines parameters for GetInboxTracks.
type GetInboxTracksParamsDirection string

// GetKworkAnswersParams defines parameters for GetKworkAnswers.
type GetKworkAnswersParams struct {
	// Id Идентификатор кворка
	Id *int `form:"id,omitempty" json:"id,omitempty"`
}

// GetKworkDetailsParams defines parameters for GetKworkDetails.
type GetKworkDetailsParams struct {
	// Id Идентификатор кворка
	Id int `form:"id" json:"id"`
}

// GetKworkDetailsExtraParams defines parameters for GetKworkDetailsExtra.
type GetKworkDetailsExtraParams struct {
	// Id Идентификатор кворка
	Id *int `form:"id,omitempty" json:"id,omitempty"`
}

// GetKworkLinksTableParams defines parameters for GetKworkLinksTable.
type GetKworkLinksTableParams struct {
	// Id Идентификатор кворка
	Id int `form:"id" json:"id"`

	// Page Страница
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetKworkLinksTablev2Params defines parameters for GetKworkLinksTablev2.
type GetKworkLinksTablev2Params struct {
	// Id Идентификатор кворка
	Id int `form:"id" json:"id"`

	// Page Страница
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetKworkPortfoliosParams defines parameters for GetKworkPortfolios.
type GetKworkPortfoliosParams struct {
	// Id Идентификатор кворка
	Id int `form:"id" json:"id"`

	// Page Запрашиваемая страница
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetKworkReviewsParams defines parameters for GetKworkReviews.
type GetKworkReviewsParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`

	// Type Тип: positive|negative|all - положительные, отрицательные или все отзывы
	Type GetKworkReviewsParamsType `form:"type" json:"type"`

	// Page Запрашиваемая страница
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetKworkReviewsParamsType defines parameters for GetKworkReviews.
type GetKworkReviewsParamsType string

// GetOrderCancellationReasonsParams defines parameters for GetOrderCancellationReasons.
type GetOrderCancellationReasonsParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`
}

// GetOrderDetailsParams defines parameters for GetOrderDetails.
type GetOrderDetailsParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`
}

// GetOrderFilesParams defines parameters for GetOrderFiles.
type GetOrderFilesParams struct {
	// Id Идентификатор заказа
	Id int `form:"id" json:"id"`
}

// GetOrderHeaderParams defines parameters for GetOrderHeader.
type GetOrderHeaderParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// OrderHash Последний хеш обновления блока заказа
	OrderHash *int `form:"orderHash,omitempty" json:"orderHash,omitempty"`

	// KworkHash Последний хеш обновления блока кворка
	KworkHash *int `form:"kworkHash,omitempty" json:"kworkHash,omitempty"`

	// PayerHash Последний хеш обновления блока покупателя
	PayerHash *int `form:"payerHash,omitempty" json:"payerHash,omitempty"`

	// WorkerHash Последний хеш обновления блока продавца
	WorkerHash *int `form:"workerHash,omitempty" json:"workerHash,omitempty"`
}

// GetOrderProvidedDataParams defines parameters for GetOrderProvidedData.
type GetOrderProvidedDataParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// GetOrderedExtrasParams defines parameters for GetOrderedExtras.
type GetOrderedExtrasParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`
}

// GetPaymentMethodsParams defines parameters for GetPaymentMethods.
type GetPaymentMethodsParams struct {
	// WithCompany Флаг - список пополнений для компании
	WithCompany *GetPaymentMethodsParamsWithCompany `form:"withCompany,omitempty" json:"withCompany,omitempty"`
}

// GetPaymentMethodsParamsWithCompany defines parameters for GetPaymentMethods.
type GetPaymentMethodsParamsWithCompany int

// GetSubscribersStatisticsParams defines parameters for GetSubscribersStatistics.
type GetSubscribersStatisticsParams struct {
	// Id Идентификатор кворка
	Id int `form:"id" json:"id"`
}

// GetTracksParams defines parameters for GetTracks.
type GetTracksParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// TrackId Идентификатор трека
	TrackId *int `form:"trackId,omitempty" json:"trackId,omitempty"`

	// Direction Направление поиска треков
	Direction *GetTracksParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Limit Лимит количества трэков
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTracksParamsDirection defines parameters for GetTracks.
type GetTracksParamsDirection string

// GetUserInfoParams defines parameters for GetUserInfo.
type GetUserInfoParams struct {
	// Id Идентификатор пользователя
	Id *int `form:"id,omitempty" json:"id,omitempty"`

	// Username Никнейм пользователя
	Username *string `form:"username,omitempty" json:"username,omitempty"`
}

// GetUsersLastOrderInfoParams defines parameters for GetUsersLastOrderInfo.
type GetUsersLastOrderInfoParams struct {
	// InterlocutorId Идентификатор собеседника
	InterlocutorId int `form:"interlocutorId" json:"interlocutorId"`
}

// GetVoiceMessageConvertStatusParams defines parameters for GetVoiceMessageConvertStatus.
type GetVoiceMessageConvertStatusParams struct {
	// FileId Идентификатор файла
	FileId int `form:"file_id" json:"file_id"`
}

// GetVoiceMessageTranscriptionParams defines parameters for GetVoiceMessageTranscription.
type GetVoiceMessageTranscriptionParams struct {
	// ConversationId Идентификатор сообщения
	ConversationId int `form:"conversation_id" json:"conversation_id"`
}

// GetWantsCountParams defines parameters for GetWantsCount.
type GetWantsCountParams struct {
	// Categories Список ID рубрик через запятую, либо 'all' - для выборки по всем рубрикам. С пустым значением делает выборку по любимым рубрикам.
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`

	// PriceFrom Бюджет от (включительно)
	PriceFrom *int `form:"price_from,omitempty" json:"price_from,omitempty"`

	// PriceTo Бюджет до (включительно)
	PriceTo *int `form:"price_to,omitempty" json:"price_to,omitempty"`

	// HiringFrom Процент найма от
	HiringFrom *int `form:"hiring_from,omitempty" json:"hiring_from,omitempty"`

	// KworksFilterFrom Количество предложений от (не включительно)
	KworksFilterFrom *int `form:"kworks_filter_from,omitempty" json:"kworks_filter_from,omitempty"`

	// KworksFilterTo Количество предложений до (включительно)
	KworksFilterTo *int `form:"kworks_filter_to,omitempty" json:"kworks_filter_to,omitempty"`

	// Query Поисковая строка
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Attributes Список аттрибутов через запятую
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Offers Идентификаторы интервалов фильтра предложений через запятую
	Offers *string `form:"offers,omitempty" json:"offers,omitempty"`
}

// GetWebAuthTokenParams defines parameters for GetWebAuthToken.
type GetWebAuthTokenParams struct {
	// UrlToRedirect URL, куда будет произведен редирект после входа в веб.
	// 				<br/>Должен начинаться с символа /, т.е. URL должен быть относительным, чтобы ограничить возможность редиректа на другой сайт.
	// 				<br/>Если указан NULL или параметр не указан, будет производится редирект на главную.
	// 				<br/>Иначе будет возвращена ошибка "Некорректные значения параметров" с кодом 101.
	UrlToRedirect *string `form:"url_to_redirect,omitempty" json:"url_to_redirect,omitempty"`
}

// HideDialogParams defines parameters for HideDialog.
type HideDialogParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"userId" json:"userId"`

	// IsRestore Признак что диалог нужно востановить
	IsRestore int `form:"isRestore" json:"isRestore"`
}

// InboxComplainMessageFormdataBody defines parameters for InboxComplainMessage.
type InboxComplainMessageFormdataBody struct {
	// Comment Комментарий к жалобе
	Comment *string `form:"comment,omitempty" json:"comment,omitempty"`
}

// InboxComplainMessageParams defines parameters for InboxComplainMessage.
type InboxComplainMessageParams struct {
	// MessageId Идентификатор сообщения
	MessageId int `form:"message_id" json:"message_id"`

	// ComplainCategoryId Идентификатор причины жалобы
	ComplainCategoryId *int `form:"complain_category_id,omitempty" json:"complain_category_id,omitempty"`
}

// InboxCreateFormdataBody defines parameters for InboxCreate.
type InboxCreateFormdataBody struct {
	// Text Текст сообщения
	Text *string `form:"text,omitempty" json:"text,omitempty"`
}

// InboxCreateParams defines parameters for InboxCreate.
type InboxCreateParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"user_id" json:"user_id"`

	// Uuid UUID для синхронизации в мп, строка
	Uuid *string `form:"uuid,omitempty" json:"uuid,omitempty"`

	// MessageKey Уникальный ключ сообщения
	MessageKey *string `form:"message_key,omitempty" json:"message_key,omitempty"`

	// OrderId Идентификатор заказа
	OrderId *int `form:"order_id,omitempty" json:"order_id,omitempty"`

	// UploadedFiles Массив идентификаторов загруженных файлов
	UploadedFiles *[]int `form:"uploaded_files[],omitempty" json:"uploaded_files[],omitempty"`

	// ReplyMessageId Идентификатор цитаты
	ReplyMessageId *int `form:"reply_message_id,omitempty" json:"reply_message_id,omitempty"`

	// WithTracks Учитывать треки
	WithTracks *WithTracks `form:"withTracks,omitempty" json:"withTracks,omitempty"`
}

// InboxCustomRequestDeclineParams defines parameters for InboxCustomRequestDecline.
type InboxCustomRequestDeclineParams struct {
	// MessageId Идентификатор сообщения
	MessageId int `form:"message_id" json:"message_id"`
}

// InboxDeleteParams defines parameters for InboxDelete.
type InboxDeleteParams struct {
	// Id Идентификатор сообщения
	Id int `form:"id" json:"id"`

	// WithTracks Учитывать треки
	WithTracks *WithTracks `form:"withTracks,omitempty" json:"withTracks,omitempty"`
}

// InboxEditFormdataBody defines parameters for InboxEdit.
type InboxEditFormdataBody struct {
	// Text Новый текст сообщения
	Text *string `form:"text,omitempty" json:"text,omitempty"`
}

// InboxEditParams defines parameters for InboxEdit.
type InboxEditParams struct {
	// Id Идентификатор сообщения
	Id int `form:"id" json:"id"`

	// UploadedFiles Массив идентификаторов загруженных файлов
	UploadedFiles *map[string]int `json:"uploaded_files,omitempty"`

	// ReplyMessageId ID цитаты
	ReplyMessageId *int `form:"reply_message_id,omitempty" json:"reply_message_id,omitempty"`
}

// InboxForwardParams defines parameters for InboxForward.
type InboxForwardParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"userId" json:"userId"`

	// MessageIds Массив идентификаторов пересылаемых сообщений
	MessageIds []int `json:"message_ids"`
}

// InboxMessageParams defines parameters for InboxMessage.
type InboxMessageParams struct {
	// MessageId Идентификатор сообщения
	MessageId int `form:"messageId" json:"messageId"`
}

// InboxPayerDeclineParams defines parameters for InboxPayerDecline.
type InboxPayerDeclineParams struct {
	// MessageId Идентификатор сообщения
	MessageId int `form:"message_id" json:"message_id"`
}

// InboxReadParams defines parameters for InboxRead.
type InboxReadParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"user_id" json:"user_id"`

	// Messages Массив идентификаторов сообщений
	Messages *[]int `json:"messages,omitempty"`
}

// InboxTrackMessageParams defines parameters for InboxTrackMessage.
type InboxTrackMessageParams struct {
	// ConversationId Сквозной идентификатор сообщения для Inbox/Track
	ConversationId int `form:"conversationId" json:"conversationId"`
}

// InboxWorkerDeclineParams defines parameters for InboxWorkerDecline.
type InboxWorkerDeclineParams struct {
	// MessageId Идентификатор сообщения
	MessageId int `form:"message_id" json:"message_id"`
}

// InboxesParams defines parameters for Inboxes.
type InboxesParams struct {
	// Username Логин юзера
	Username string `form:"username" json:"username"`

	// Page Страница выдачи (если не задана, то выводится последняя)
	Page *string `form:"page,omitempty" json:"page,omitempty"`
}

// IsDialogAllowParams defines parameters for IsDialogAllow.
type IsDialogAllowParams struct {
	// ReceiverId Идентификатор собеседника
	ReceiverId int `form:"receiverId" json:"receiverId"`

	// WithTracks Учитывать треки
	WithTracks *WithTracks `form:"withTracks,omitempty" json:"withTracks,omitempty"`
}

// KworksParams defines parameters for Kworks.
type KworksParams struct {
	// Sort Тип сортировки
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// CategoryId Идентификатор категории
	CategoryId *int `form:"categoryId,omitempty" json:"categoryId,omitempty"`

	// ClassifierId Идентификатор классификации
	ClassifierId *int `form:"classifierId,omitempty" json:"classifierId,omitempty"`

	// Excluded Строка идентификаторов кворков которые нужно исключить из выдачи (уже показанных) разделенных запятыми
	Excluded *string `form:"excluded,omitempty" json:"excluded,omitempty"`

	// Unembedded Id всех выбранных значений в фильтрах с is_unembedded = 1, склеенных в kebab-case
	Unembedded *string `form:"unembedded,omitempty" json:"unembedded,omitempty"`

	// Limit Лимит кворков на странице (0 => 10)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// JSONСФильтрами Остальные фильтры, выбранные пользователем. Подробнее https://kworkteam.ru/code/docs/filtry-v-kataloge-metody-api/
	JSONСФильтрами *map[string]interface{} `form:"JSON с фильтрами,omitempty" json:"JSON с фильтрами,omitempty"`
}

// KworksCategoriesListParams defines parameters for KworksCategoriesList.
type KworksCategoriesListParams struct {
	// UserId Идентификатор пользователя
	UserId int `form:"user_id" json:"user_id"`
}

// LogoutParams defines parameters for Logout.
type LogoutParams struct {
	// PushToken Токен регистрации в Firebase Cloud Messaging
	PushToken *string `form:"pushToken,omitempty" json:"pushToken,omitempty"`
}

// MarkInboxTracksAsReadParams defines parameters for MarkInboxTracksAsRead.
type MarkInboxTracksAsReadParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"userId" json:"userId"`

	// ConversationIds Идентификаторы переписки
	ConversationIds []int `form:"conversationIds[]" json:"conversationIds[]"`
}

// MarkKworkAsFavoriteParams defines parameters for MarkKworkAsFavorite.
type MarkKworkAsFavoriteParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`

	// IsFavorite 0 - убрать из избранного, 1 - добавить в избранное
	IsFavorite int `form:"is_favorite" json:"is_favorite"`
}

// MarkKworkAsHiddenParams defines parameters for MarkKworkAsHidden.
type MarkKworkAsHiddenParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`

	// IsHidden Действие над кворком (показать - 0, скрыть - 1)
	IsHidden int `form:"is_hidden" json:"is_hidden"`
}

// MarkKworksBlackFridayParams defines parameters for MarkKworksBlackFriday.
type MarkKworksBlackFridayParams struct {
	// KworkId Идентификатор кворка
	KworkId *int `form:"kworkId,omitempty" json:"kworkId,omitempty"`
}

// MarkVoiceMessageHeardParams defines parameters for MarkVoiceMessageHeard.
type MarkVoiceMessageHeardParams struct {
	// ConversationId Идентификатор сообщения
	ConversationId int `form:"conversation_id" json:"conversation_id"`
}

// MiniatureParams defines parameters for Miniature.
type MiniatureParams struct {
	// Path Путь к миниатюре
	Path string `form:"path" json:"path"`
}

// MyWantsParams defines parameters for MyWants.
type MyWantsParams struct {
	// WantStatusId Альтернативные статусы запросов на услугу (проектов) через запятую. -1 для получения архивных.
	WantStatusId *string `form:"want_status_id,omitempty" json:"want_status_id,omitempty"`

	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// NotificationsFetchParams defines parameters for NotificationsFetch.
type NotificationsFetchParams struct {
	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Uad Уникальный идентификатор устройства
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`
}

// NotificationsReceivedParams defines parameters for NotificationsReceived.
type NotificationsReceivedParams struct {
	// Ids Идентификаторы  сквозных Push-событий
	Ids []int `form:"ids[]" json:"ids[]"`
}

// OfferParams defines parameters for Offer.
type OfferParams struct {
	// Id Идентификатор предложения к запросу на услугу
	Id int `form:"id" json:"id"`
}

// OfferOrderOptionsParams defines parameters for OfferOrderOptions.
type OfferOrderOptionsParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Options Доп.опции
	Options *map[string]int `json:"options,omitempty"`

	// CustomOptions Пользовательские доп.опции
	CustomOptions *map[string]int `json:"customOptions,omitempty"`

	// UpdatedPackage Увеличение пакета кворка
	UpdatedPackage *OfferOrderOptionsParamsUpdatedPackage `form:"updatedPackage,omitempty" json:"updatedPackage,omitempty"`
}

// OfferOrderOptionsParamsUpdatedPackage defines parameters for OfferOrderOptions.
type OfferOrderOptionsParamsUpdatedPackage string

// OffersParams defines parameters for Offers.
type OffersParams struct {
	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// OrderParams defines parameters for Order.
type OrderParams struct {
	// Id Идентификатор заказа
	Id int `form:"id" json:"id"`
}

// OrderKworkParams defines parameters for OrderKwork.
type OrderKworkParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kworkId" json:"kworkId"`

	// KworksCount Количество кворков
	KworksCount *int `form:"kworksCount,omitempty" json:"kworksCount,omitempty"`

	// VolumeTypeId Идентификатор числового объема. Указывается, в случае выбора пользователем
	VolumeTypeId *int `form:"volumeTypeId,omitempty" json:"volumeTypeId,omitempty"`

	// Volume Покупаемый объем
	Volume *float32 `form:"volume,omitempty" json:"volume,omitempty"`

	// PackageId Идентификатор покупатемого пакета
	PackageId *int `form:"packageId,omitempty" json:"packageId,omitempty"`

	// Extras Покупаемые дополнительные пакетные опции [extraId(идентификатора опции) => count(количество)]
	Extras *map[string]interface{} `form:"extras,omitempty" json:"extras,omitempty"`

	// ChannelFormat Формат размещения: 1_24, 2_48, 3_72, not_delete, repost, native
	ChannelFormat *string `form:"channel_format,omitempty" json:"channel_format,omitempty"`
}

// OrderStageParams defines parameters for OrderStage.
type OrderStageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// StageId Идентификатор этапа
	StageId int `form:"stage_id" json:"stage_id"`
}

// OrdersBetweenParams defines parameters for OrdersBetween.
type OrdersBetweenParams struct {
	// UserId ID пользователя
	UserId int `form:"user_id" json:"user_id"`
}

// PauseKworkParams defines parameters for PauseKwork.
type PauseKworkParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`
}

// PayOrderAwaitingPaymentParams defines parameters for PayOrderAwaitingPayment.
type PayOrderAwaitingPaymentParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// PayerBuyExtrasParams defines parameters for PayerBuyExtras.
type PayerBuyExtrasParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Extras Массив заказываемых дополнительных опций [id => count]
	Extras map[string]int `json:"extras"`

	// AsVolume Флаг то что количество заказываемых опций указывается в единицах числового объема
	AsVolume *PayerBuyExtrasParamsAsVolume `form:"as_volume,omitempty" json:"as_volume,omitempty"`
}

// PayerBuyExtrasParamsAsVolume defines parameters for PayerBuyExtras.
type PayerBuyExtrasParamsAsVolume int

// PayerDeclineExtrasParams defines parameters for PayerDeclineExtras.
type PayerDeclineExtrasParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// TrackId Идентификатор трека в котором предложили опции
	TrackId int `form:"track_id" json:"track_id"`
}

// PayerDeclinesExtraRemovalRequestParams defines parameters for PayerDeclinesExtraRemovalRequest.
type PayerDeclinesExtraRemovalRequestParams struct {
	// TrackId Идентификатор трека
	TrackId int `form:"track_id" json:"track_id"`
}

// PayerExtraDeleteParams defines parameters for PayerExtraDelete.
type PayerExtraDeleteParams struct {
	// ExtraId Идентификатор опции
	ExtraId int `form:"extra_id" json:"extra_id"`
}

// PayerOrdersParams defines parameters for PayerOrders.
type PayerOrdersParams struct {
	// Filter фильтр (необязательный) active - В работе, cancelled - Отменено, delivered - На проверке, completed - Выполнено, missing_data - Предоставьте данные, unpaid - Требуется оплаты, all - Все
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Page страница выдачи
	Page *string `form:"page,omitempty" json:"page,omitempty"`

	// CompanyOrders Отображать заказы компании (необязательный параметр)
	CompanyOrders *int `form:"company_orders,omitempty" json:"company_orders,omitempty"`
}

// PayerUpgradePackageParams defines parameters for PayerUpgradePackage.
type PayerUpgradePackageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// PackageType Тип пакета (standard, medium, premium)
	PackageType *string `form:"packageType,omitempty" json:"packageType,omitempty"`
}

// PortfolioCategoriesListParams defines parameters for PortfolioCategoriesList.
type PortfolioCategoriesListParams struct {
	// UserId Идентификатор пользователя
	UserId int `form:"user_id" json:"user_id"`
}

// PortfolioListParams defines parameters for PortfolioList.
type PortfolioListParams struct {
	// UserId Идентификатор пользователя
	UserId int `form:"user_id" json:"user_id"`

	// CategoryId Идентификатор категории, или 'all' для вывода всех
	CategoryId string `form:"category_id" json:"category_id"`

	// Page Номер страницы
	Page int `form:"page" json:"page"`
}

// PositiveReviewsCountParams defines parameters for PositiveReviewsCount.
type PositiveReviewsCountParams struct {
	// CategoryId Идентификатор категории
	CategoryId *int `form:"category_id,omitempty" json:"category_id,omitempty"`

	// AttributeId Массив идентификаторов атрибутов
	AttributeId *[]int `form:"attribute_id,omitempty" json:"attribute_id,omitempty"`
}

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	// Categories Список ID рубрик через запятую, либо 'all' - для выборки по всем рубрикам. С пустым значением делает выборку по любимым рубрикам.
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`

	// PriceFrom Бюджет от (включительно)
	PriceFrom *int `form:"price_from,omitempty" json:"price_from,omitempty"`

	// PriceTo Бюджет до (включительно)
	PriceTo *int `form:"price_to,omitempty" json:"price_to,omitempty"`

	// HiringFrom Процент найма от
	HiringFrom *int `form:"hiring_from,omitempty" json:"hiring_from,omitempty"`

	// KworksFilterFrom Количество предложений от (не включительно)
	KworksFilterFrom *int `form:"kworks_filter_from,omitempty" json:"kworks_filter_from,omitempty"`

	// KworksFilterTo Количество предложений до (включительно)
	KworksFilterTo *int `form:"kworks_filter_to,omitempty" json:"kworks_filter_to,omitempty"`

	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Query Поисковая строка
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Attributes Список аттрибутов через запятую
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Offers Идентификаторы интервалов фильтра предложений через запятую
	Offers *string `form:"offers,omitempty" json:"offers,omitempty"`
}

// PushInAppNotificationLogParams defines parameters for PushInAppNotificationLog.
type PushInAppNotificationLogParams struct {
	// NotificationId ID уведомления
	NotificationId int `form:"notificationId" json:"notificationId"`

	// Action Действие пользователя 0 - закрыл, 1 - подробнее
	Action int `form:"action" json:"action"`

	// PreviousShowDate Время показа прошлого уведомления timestamp
	PreviousShowDate *int `form:"previousShowDate,omitempty" json:"previousShowDate,omitempty"`
}

// RateArbitrationParams defines parameters for RateArbitration.
type RateArbitrationParams struct {
	// Id Идентификатор трека
	Id int `form:"id" json:"id"`

	// Rating Оценка
	Rating int `form:"rating" json:"rating"`
}

// RechargeBalanceParams defines parameters for RechargeBalance.
type RechargeBalanceParams struct {
	// OrderId Идентификатор заказа, если нет - 0
	OrderId *int `form:"orderId,omitempty" json:"orderId,omitempty"`

	// PaymentId Идентификатор платежа
	PaymentId *int `form:"payment_id,omitempty" json:"payment_id,omitempty"`

	// Amount Сумма платежа
	Amount float32 `form:"amount" json:"amount"`

	// PaymentType Тип платежа
	PaymentType string `form:"paymentType" json:"paymentType"`

	// CountryGroupCode Код группы стран
	CountryGroupCode *string `form:"country_group_code,omitempty" json:"country_group_code,omitempty"`
}

// RegisterCloudTokenParams defines parameters for RegisterCloudToken.
type RegisterCloudTokenParams struct {
	// CloudToken Токен FCM
	CloudToken string `form:"cloud_token" json:"cloud_token"`

	// Os Тип операционный системы
	Os *RegisterCloudTokenParamsOs `form:"os,omitempty" json:"os,omitempty"`

	// OsVersion Версия операционной системы
	OsVersion *string `form:"os_version,omitempty" json:"os_version,omitempty"`

	// Device Модель устройства
	Device *string `form:"device,omitempty" json:"device,omitempty"`

	// AppVersion Версия мобильного приложения
	AppVersion *string `form:"app_version,omitempty" json:"app_version,omitempty"`

	// Uad Уникальный идентификатор устройства
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`
}

// RegisterCloudTokenParamsOs defines parameters for RegisterCloudToken.
type RegisterCloudTokenParamsOs string

// RejectCancelOrderRequestByPayerParams defines parameters for RejectCancelOrderRequestByPayer.
type RejectCancelOrderRequestByPayerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// RejectCancelOrderRequestByWorkerParams defines parameters for RejectCancelOrderRequestByWorker.
type RejectCancelOrderRequestByWorkerParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// RejectStageSuggestionParams defines parameters for RejectStageSuggestion.
type RejectStageSuggestionParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// RepeatOrderParams defines parameters for RepeatOrder.
type RepeatOrderParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`
}

// ReportAppVersionParams defines parameters for ReportAppVersion.
type ReportAppVersionParams struct {
	// CloudToken Токен FCM
	CloudToken string `form:"cloud_token" json:"cloud_token"`

	// AppVersion Версия мобильного приложения в формате x.x.x.x
	AppVersion string `form:"app_version" json:"app_version"`
}

// RequestPhoneChangingParams defines parameters for RequestPhoneChanging.
type RequestPhoneChangingParams struct {
	// PhoneLast Последние 4 цифры телефона пользователя
	PhoneLast *string `form:"phone_last,omitempty" json:"phone_last,omitempty"`

	// Password Пароль пользователя
	Password *string `form:"password,omitempty" json:"password,omitempty"`
}

// ResetPasswordFormdataBody defines parameters for ResetPassword.
type ResetPasswordFormdataBody struct {
	// Email Почта
	Email string `form:"email" json:"email"`

	// GRecaptchaResponse Данные recaptcha - необходим если ранее пришел код ошибки 118
	GRecaptchaResponse *string `form:"g-recaptcha-response,omitempty" json:"g-recaptcha-response,omitempty"`
}

// RestartWantParams defines parameters for RestartWant.
type RestartWantParams struct {
	// Id Идентификатор запроса на услугу (проекта)
	Id int `form:"id" json:"id"`
}

// SaveOrderNoteFormdataBody defines parameters for SaveOrderNote.
type SaveOrderNoteFormdataBody struct {
	// Note Текст сообщения
	Note *string `form:"note,omitempty" json:"note,omitempty"`
}

// SaveOrderNoteParams defines parameters for SaveOrderNote.
type SaveOrderNoteParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`
}

// SaveUserNoteFormdataBody defines parameters for SaveUserNote.
type SaveUserNoteFormdataBody struct {
	// Note Текст сообщения
	Note *string `form:"note,omitempty" json:"note,omitempty"`
}

// SaveUserNoteParams defines parameters for SaveUserNote.
type SaveUserNoteParams struct {
	// UserId Идентификатор пользователя
	UserId int `form:"user_id" json:"user_id"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Query Строка поиска
	Query string `form:"query" json:"query"`

	// CategoryId ID категории
	CategoryId *int `form:"categoryId,omitempty" json:"categoryId,omitempty"`

	// ClassifierId ID классификации (не работает без указания categoryId)
	ClassifierId *string `form:"classifierId,omitempty" json:"classifierId,omitempty"`

	// Excluded Строка идентификаторов кворков которые нужно исключить из выдачи (уже показанных) разделенных запятыми
	Excluded *string `form:"excluded,omitempty" json:"excluded,omitempty"`

	// Unembedded Id всех выбранных значений в фильтрах с is_unembedded = 1, склеенных в kebab-case
	Unembedded *string `form:"unembedded,omitempty" json:"unembedded,omitempty"`

	// JSONСФильтрами Остальные фильтры, выбранные пользователем. Подробнее https://kworkteam.ru/code/docs/filtry-v-kataloge-metody-api/
	JSONСФильтрами *map[string]interface{} `form:"JSON с фильтрами,omitempty" json:"JSON с фильтрами,omitempty"`

	// Page Номер страницы результатов
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Количество на странице
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Тип сортировки,
	// 	 *         Сортировка по релевантности - x;
	// 	 *         Сортировка по новизне - new;
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// SearchDialogsParams defines parameters for SearchDialogs.
type SearchDialogsParams struct {
	// Query Поисковая строка (от двух символов)
	Query string `form:"query" json:"query"`

	// Page Cтраница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// ExcludedIds Исключенные из выборки пользователи
	ExcludedIds *string `form:"excludedIds,omitempty" json:"excludedIds,omitempty"`

	// WithTracks Учитывать треки
	WithTracks *WithTracks `form:"withTracks,omitempty" json:"withTracks,omitempty"`
}

// SearchInboxesParams defines parameters for SearchInboxes.
type SearchInboxesParams struct {
	// Query Поисковая строка
	Query string `form:"query" json:"query"`

	// UserId Идентификатор пользователя-собеседника, по которому осуществляется поиск
	UserId *int `form:"userId,omitempty" json:"userId,omitempty"`

	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// SearchKworksCatalogQueryParams defines parameters for SearchKworksCatalogQuery.
type SearchKworksCatalogQueryParams struct {
	// Query Строка поиска
	Query string `form:"query" json:"query"`
}

// SearchMessagesParams defines parameters for SearchMessages.
type SearchMessagesParams struct {
	// Text Поисковая строка
	Text string `form:"text" json:"text"`

	// UserId Идентификатор пользователя-собеседника, по которому осуществляется поиск
	UserId int `form:"userId" json:"userId"`

	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// SearchOrderTracksParams defines parameters for SearchOrderTracks.
type SearchOrderTracksParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Text Поисковая строка
	Text string `form:"text" json:"text"`

	// Page Страница
	Page int `form:"page" json:"page"`
}

// SearchTracksParams defines parameters for SearchTracks.
type SearchTracksParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Text Поисковая строка
	Text string `form:"text" json:"text"`
}

// SendBonusParams defines parameters for SendBonus.
type SendBonusParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Bonus Сумма бонуса
	Bonus int `form:"bonus" json:"bonus"`

	// Comment Комментарий
	Comment *string `form:"comment,omitempty" json:"comment,omitempty"`
}

// SendCompanyForVerificationParams defines parameters for SendCompanyForVerification.
type SendCompanyForVerificationParams struct {
	// TaxNumber ИНН
	TaxNumber string `form:"tax_number" json:"tax_number"`

	// Address Адрес для ИП
	Address *string `form:"address,omitempty" json:"address,omitempty"`
}

// SendOrderForApprovalParams defines parameters for SendOrderForApproval.
type SendOrderForApprovalParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Metrics Идентификаторы файлов отчета
	Metrics *[]int `form:"metrics[],omitempty" json:"metrics[],omitempty"`

	// StageIds Идентификаторы этапов, передаваемых на проверку
	StageIds *[]int `form:"stageIds[],omitempty" json:"stageIds[],omitempty"`

	// FilesIds Идентификаторы файлов
	FilesIds *[]int `form:"filesIds[],omitempty" json:"filesIds[],omitempty"`
}

// SendOrderForArbitrationParams defines parameters for SendOrderForArbitration.
type SendOrderForArbitrationParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// ReasonId Идентификатор причины арбитража
	ReasonId int `form:"reasonId" json:"reasonId"`

	// StageIds Идентификаторы этапов для арбитража
	StageIds *[]int `form:"stageIds[],omitempty" json:"stageIds[],omitempty"`

	// Comments Комментарии
	Comments string `form:"comments" json:"comments"`

	// Files Файлы
	Files *[]int `form:"files[],omitempty" json:"files[],omitempty"`
}

// SendOrderForRevisionParams defines parameters for SendOrderForRevision.
type SendOrderForRevisionParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Revision Сообщение при отклонении заказа
	Revision *string `form:"revision,omitempty" json:"revision,omitempty"`

	// Files Идентификаторы приклепленных файлов
	Files *[]int `form:"files[],omitempty" json:"files[],omitempty"`

	// StageIds Идентификаторы этапов, передаваемых на проверку
	StageIds *[]int `form:"stageIds[],omitempty" json:"stageIds[],omitempty"`
}

// SendOrderReceiptLinkForVerificationParams defines parameters for SendOrderReceiptLinkForVerification.
type SendOrderReceiptLinkForVerificationParams struct {
	// ReceiptId Идентификатор чека
	ReceiptId int `form:"receiptId" json:"receiptId"`

	// ReceiptLink Ссылка на чек
	ReceiptLink string `form:"receiptLink" json:"receiptLink"`
}

// SendOrderRequirementsParams defines parameters for SendOrderRequirements.
type SendOrderRequirementsParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Requirements Информация о заказе
	Requirements *string `form:"requirements,omitempty" json:"requirements,omitempty"`

	// Files Прикрепляемые файлы
	Files *[]int `form:"files[],omitempty" json:"files[],omitempty"`

	// Metrics Прикрепляемые метрики
	Metrics *[]int `form:"metrics[],omitempty" json:"metrics[],omitempty"`
}

// SendReportParams defines parameters for SendReport.
type SendReportParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Progress Прогресс по задаче (10, 20, 30 и т.д.)
	Progress int `form:"progress" json:"progress"`

	// Comment Комментарий (минимум 2 символа, максимум 350 символов)
	Comment string `form:"comment" json:"comment"`

	// TrackId Идентификатор трека, если это редактирование
	TrackId *string `form:"track_id,omitempty" json:"track_id,omitempty"`
}

// SendSelfEmployedSurveyResultParams defines parameters for SendSelfEmployedSurveyResult.
type SendSelfEmployedSurveyResultParams struct {
	// Answer Ответ
	Answer int `form:"answer" json:"answer"`
}

// SendUserStatusParams defines parameters for SendUserStatus.
type SendUserStatusParams struct {
	// UserId Идентификатор получателя
	UserId int `form:"user_id" json:"user_id"`

	// Status Статус (typing - печатает, audio - записывает голосовое)
	Status string `form:"status" json:"status"`

	// OrderId Идентификатор заказа (если поле заполнено, статус отправляется в заказ, если поле пустое, в чат)
	OrderId *int `form:"order_id,omitempty" json:"order_id,omitempty"`
}

// SendWhatsAppCodeParams defines parameters for SendWhatsAppCode.
type SendWhatsAppCodeParams struct {
	// Phone Номер телефона пользователя
	Phone *string `form:"phone,omitempty" json:"phone,omitempty"`

	// Hash Валидационный кеш
	Hash *string `form:"hash,omitempty" json:"hash,omitempty"`
}

// SetAvailableAtWeekendsParams defines parameters for SetAvailableAtWeekends.
type SetAvailableAtWeekendsParams struct {
	// Available Значение флага: true - кворки доступны на выходных / false - кворки не доступны на выходных
	Available SetAvailableAtWeekendsParamsAvailable `form:"available" json:"available"`
}

// SetAvailableAtWeekendsParamsAvailable defines parameters for SetAvailableAtWeekends.
type SetAvailableAtWeekendsParamsAvailable string

// SetDialogStarredParams defines parameters for SetDialogStarred.
type SetDialogStarredParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"userId" json:"userId"`

	// IsStarred Признак избранного диалога
	IsStarred int `form:"isStarred" json:"isStarred"`
}

// SetFavoriteParams defines parameters for SetFavorite.
type SetFavoriteParams struct {
	// Categories Идентификаторы категорий для назначения в список любимых
	Categories string `form:"categories" json:"categories"`

	// Attributes Идентификаторы аттрибутов для назначения в список любимых
	Attributes string `form:"attributes" json:"attributes"`
}

// SetOrderRatingParams defines parameters for SetOrderRating.
type SetOrderRatingParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Speed Скорость (от 1 до 5)
	Speed int `form:"speed" json:"speed"`

	// Quality Качество (от 1 до 5)
	Quality int `form:"quality" json:"quality"`

	// Communication Коммуникация (от 1 до 5)
	Communication int `form:"communication" json:"communication"`
}

// SetTakingOrdersParams defines parameters for SetTakingOrders.
type SetTakingOrdersParams struct {
	// Status Статус занятости (free - свободен, busy - занят)
	Status string `form:"status" json:"status"`

	// SwitchAll Активировать все кворки или только те, которые были активны до включения статуса «Занят» (1 - да, 0 - нет, любое другое значение игнорится и ставится значение умолчанию из поля worker_status_switch_all)
	SwitchAll *string `form:"switchAll,omitempty" json:"switchAll,omitempty"`
}

// SetUserTypeParams defines parameters for SetUserType.
type SetUserTypeParams struct {
	// Type Значение флага: 0 - покупатель / 1 - продавец
	Type SetUserTypeParamsType `form:"type" json:"type"`
}

// SetUserTypeParamsType defines parameters for SetUserType.
type SetUserTypeParamsType string

// SetVoiceMessageReceivingParams defines parameters for SetVoiceMessageReceiving.
type SetVoiceMessageReceivingParams struct {
	// IsAllowed 0 - запрещено, 1 - разрешено
	IsAllowed *int `form:"is_allowed,omitempty" json:"is_allowed,omitempty"`
}

// SetVoiceMessageSpeedParams defines parameters for SetVoiceMessageSpeed.
type SetVoiceMessageSpeedParams struct {
	// Speed Код подтверждения
	Speed *float32 `form:"speed,omitempty" json:"speed,omitempty"`
}

// SignInFormdataBody defines parameters for SignIn.
type SignInFormdataBody struct {
	// GRecaptchaResponse Данные recaptcha - необходим если ранее пришел код ошибки 118
	GRecaptchaResponse *string `form:"g-recaptcha-response,omitempty" json:"g-recaptcha-response,omitempty"`

	// Login Логин или e-mail пользователя
	Login string `form:"login" json:"login"`

	// Password Пароль пользователя
	Password string `form:"password" json:"password"`

	// PhoneLast Последние 4 цифры номера телефона
	PhoneLast *string `form:"phone_last,omitempty" json:"phone_last,omitempty"`

	// RecaptchaPassToken Токен для пропуска капчи
	RecaptchaPassToken *string `form:"recaptcha_pass_token,omitempty" json:"recaptcha_pass_token,omitempty"`

	// Uad Уникальный идентификатор устройства/приложения/браузера
	Uad *string `form:"uad,omitempty" json:"uad,omitempty"`
}

// SignUpFormdataBody defines parameters for SignUp.
type SignUpFormdataBody struct {
	// Email Email пользователя
	Email interface{} `form:"email" json:"email"`

	// GRecaptchaResponse Данные recaptcha - необходим если ранее пришел код ошибки 118
	GRecaptchaResponse interface{} `form:"g-recaptcha-response,omitempty" json:"g-recaptcha-response,omitempty"`

	// Password Пароль пользователя
	Password interface{} `form:"password" json:"password"`

	// Promocode Промокод
	Promocode interface{} `form:"promocode,omitempty" json:"promocode,omitempty"`

	// Type Тип пользователя
	// 	 * `payer` Покупатель
	// 	 * `worker` Продавец
	Type interface{} `form:"type,omitempty" json:"type,omitempty"`

	// Username Логин пользователя
	Username interface{} `form:"username" json:"username"`
}

// SocialSignInFormdataBody defines parameters for SocialSignIn.
type SocialSignInFormdataBody struct {
	// Code Авторизационный код возвращаемый провайдером
	Code interface{} `form:"code" json:"code"`

	// Provider Тип провайдера (соц. сеть)
	// 	 * `vk`: ВКонтакте
	// 	 * `fb`: Facebook
	// 	 * `google`: Google
	Provider interface{} `form:"provider" json:"provider"`

	// RedirectUri Адрес предоставляемый провайдеру при авторизации для обратного редиректа
	RedirectUri interface{} `form:"redirect_uri" json:"redirect_uri"`

	// UserType Тип пользователя
	// 	 * `1` Покупатель
	// 	 * `2` Продавец
	UserType interface{} `form:"user_type,omitempty" json:"user_type,omitempty"`
}

// SocialSignInByTokenFormdataBody defines parameters for SocialSignInByToken.
type SocialSignInByTokenFormdataBody struct {
	// Email Email пользователя
	Email interface{} `form:"email,omitempty" json:"email,omitempty"`

	// Provider Тип провайдера (соц. сеть)
	// 	 * `vk`: ВКонтакте
	// 	 * `fb`: Facebook
	Provider interface{} `form:"provider" json:"provider"`

	// Token Авторизационный токен возвращаемый провайдером
	Token interface{} `form:"token" json:"token"`

	// UserType Тип пользователя
	// 	 * `1` Покупатель
	// 	 * `2` Продавец
	UserType interface{} `form:"user_type,omitempty" json:"user_type,omitempty"`
}

// SocialSignInByTokenv2FormdataBody defines parameters for SocialSignInByTokenv2.
type SocialSignInByTokenv2FormdataBody struct {
	// Email Email пользователя
	Email interface{} `form:"email,omitempty" json:"email,omitempty"`

	// Provider Тип провайдера (соц. сеть)
	// 	 * `vk`: ВКонтакте
	// 	 * `fb`: Facebook
	// 	 * `google`: Google
	// 	 * `google_id`: Google по id_token
	Provider interface{} `form:"provider" json:"provider"`

	// Token Авторизационный токен возвращаемый провайдером
	Token interface{} `form:"token" json:"token"`
}

// SocialSignUpFormdataBody defines parameters for SocialSignUp.
type SocialSignUpFormdataBody struct {
	// Code Авторизационный код возвращаемый провайдером
	Code interface{} `form:"code" json:"code"`

	// Email Email пользователя
	Email interface{} `form:"email" json:"email"`

	// Provider Тип провайдера (соц. сеть)
	// 	 * `vk`: ВКонтакте
	// 	 * `fb`: Facebook
	// 	 * `google`: Google
	Provider interface{} `form:"provider" json:"provider"`

	// RedirectUri Адрес предоставляемый провайдеру при авторизации для обратного редиректа
	RedirectUri interface{} `form:"redirectUri" json:"redirectUri"`

	// UserType Тип пользователя
	// 	 * `1` Покупатель
	// 	 * `2` Продавец
	UserType interface{} `form:"user_type,omitempty" json:"user_type,omitempty"`
}

// SocialSignUpByTokenFormdataBody defines parameters for SocialSignUpByToken.
type SocialSignUpByTokenFormdataBody struct {
	// Email Email пользователя
	Email interface{} `form:"email" json:"email"`

	// Promocode Промокод
	Promocode interface{} `form:"promocode,omitempty" json:"promocode,omitempty"`

	// Provider Тип провайдера (соц. сеть)
	// 	 * `vk`: ВКонтакте
	// 	 * `fb`: Facebook
	// 	 * `google`: Google
	// 	 * `google_id`: Google по id_token
	Provider interface{} `form:"provider" json:"provider"`

	// Token Авторизационный токен возвращаемый провайдером
	Token interface{} `form:"token" json:"token"`

	// UserType Тип пользователя
	// 	 * `1` Покупатель
	// 	 * `2` Продавец
	UserType interface{} `form:"user_type,omitempty" json:"user_type,omitempty"`
}

// StartKworkParams defines parameters for StartKwork.
type StartKworkParams struct {
	// KworkId Идентификатор кворка
	KworkId int `form:"kwork_id" json:"kwork_id"`
}

// StopWantParams defines parameters for StopWant.
type StopWantParams struct {
	// Id Идентификатор запроса на услугу (проекта)
	Id int `form:"id" json:"id"`
}

// SuggestStagesParams defines parameters for SuggestStages.
type SuggestStagesParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// Days Количество дней
	Days int `form:"days" json:"days"`

	// Message Сообщение
	Message string `form:"message" json:"message"`

	// Stages Параметры этапов
	Stages map[string]map[string]interface{} `form:"stages" json:"stages"`
}

// TrackDeleteParams defines parameters for TrackDelete.
type TrackDeleteParams struct {
	// Id Идентификатор трека
	Id int `form:"id" json:"id"`
}

// TrackEditFormdataBody defines parameters for TrackEdit.
type TrackEditFormdataBody struct {
	// Text Новый текст сообщения
	Text *string `form:"text,omitempty" json:"text,omitempty"`
}

// TrackEditParams defines parameters for TrackEdit.
type TrackEditParams struct {
	// Id Идентификатор трека
	Id int `form:"id" json:"id"`

	// UploadedFiles Массив идентификаторов загруженных файлов, если массив пустой или переменная не передана, то файлы удаляются
	UploadedFiles *map[string]int `json:"uploadedFiles,omitempty"`

	// QuoteId ID цитаты
	QuoteId *int `form:"quoteId,omitempty" json:"quoteId,omitempty"`
}

// TrackMessageParams defines parameters for TrackMessage.
type TrackMessageParams struct {
	// Id Идентификатор трека
	Id int `form:"id" json:"id"`
}

// TrackReadParams defines parameters for TrackRead.
type TrackReadParams struct {
	// Ids Идентификаторы трека
	Ids []int `form:"ids[]" json:"ids[]"`
}

// TypingParams defines parameters for Typing.
type TypingParams struct {
	// RecipientId Идентификатор получателя
	RecipientId int `form:"recipientId" json:"recipientId"`

	// OrderId Идентификатор заказа (если текст набирается в заказе)
	OrderId *int `form:"orderId,omitempty" json:"orderId,omitempty"`
}

// UnarchiveDialogParams defines parameters for UnarchiveDialog.
type UnarchiveDialogParams struct {
	// ArchiveUserId Идентификатор собеседника
	ArchiveUserId int `form:"archiveUserId" json:"archiveUserId"`
}

// UnblockDialogParams defines parameters for UnblockDialog.
type UnblockDialogParams struct {
	// BlockUserId Идентификатор пользователя
	BlockUserId int `form:"blockUserId" json:"blockUserId"`
}

// UnreadDialogParams defines parameters for UnreadDialog.
type UnreadDialogParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"user_id" json:"user_id"`
}

// UpdateAvatarMultipartBody defines parameters for UpdateAvatar.
type UpdateAvatarMultipartBody struct {
	// Avatar Файл аватара
	Avatar *openapi_types.File `json:"avatar,omitempty"`
}

// UpdateChatDraftMessageParams defines parameters for UpdateChatDraftMessage.
type UpdateChatDraftMessageParams struct {
	// UserId Идентификатор собеседника
	UserId int `form:"userId" json:"userId"`

	// Message Текст черновика
	Message *string `form:"message,omitempty" json:"message,omitempty"`

	// Files Список идентификаторов файлов для черновика
	Files *[]int `form:"files[],omitempty" json:"files[],omitempty"`
}

// UpdateOrderDraftMessageParams defines parameters for UpdateOrderDraftMessage.
type UpdateOrderDraftMessageParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"orderId" json:"orderId"`

	// Message Текст черновика
	Message *string `form:"message,omitempty" json:"message,omitempty"`

	// Files Список идентификаторов файлов для черновика
	Files *[]int `form:"files[],omitempty" json:"files[],omitempty"`
}

// UpdateSettingsMultipartBody defines parameters for UpdateSettings.
type UpdateSettingsMultipartBody struct {
	// AvatarPhoto0 Файл аватара
	AvatarPhoto0 *openapi_types.File `json:"avatar-photo[0],omitempty"`
}

// UpdateSettingsParams defines parameters for UpdateSettings.
type UpdateSettingsParams struct {
	// Username Имя пользователя
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Email Электропочта
	Email *string `form:"email,omitempty" json:"email,omitempty"`

	// Fullname Настоящее имя пользователя - по русски
	Fullname *string `form:"fullname,omitempty" json:"fullname,omitempty"`

	// TimezoneId Идентификатор часового пояса integer
	TimezoneId *int `form:"timezoneId,omitempty" json:"timezoneId,omitempty"`

	// Details Информация о продавце
	Details *string `form:"details,omitempty" json:"details,omitempty"`

	// AvatarPhotoSize Массив данных о ресайзе аватара
	AvatarPhotoSize *Resize `json:"avatarPhotoSize,omitempty"`

	// CountryId Идентификатор страны
	CountryId *int `form:"countryId,omitempty" json:"countryId,omitempty"`

	// CityId Идентификатор города
	CityId *int `form:"cityId,omitempty" json:"cityId,omitempty"`

	// Profession Специальность пользователя
	Profession *string `form:"profession,omitempty" json:"profession,omitempty"`

	// WorkHoursFrom Время работы с
	WorkHoursFrom *int `form:"workHoursFrom,omitempty" json:"workHoursFrom,omitempty"`

	// WorkHoursTo Время работы по
	WorkHoursTo *int `form:"workHoursTo,omitempty" json:"workHoursTo,omitempty"`
}

// UpdateStageProgressParams defines parameters for UpdateStageProgress.
type UpdateStageProgressParams struct {
	// OrderId Идентификатор заказа (либо 0)
	OrderId int `form:"order_id" json:"order_id"`

	// Stages Прогресс по задаче stages[stage_id]:progress
	Stages map[string]map[string]interface{} `form:"stages" json:"stages"`

	// Comment Комментарий (минимум 2 символа, максимум 350 символов)
	Comment string `form:"comment" json:"comment"`

	// Metrics Идентификаторы файлов отчета
	Metrics *[]int `form:"metrics[],omitempty" json:"metrics[],omitempty"`

	// TrackId Идентификатор трека
	TrackId *int `form:"trackId,omitempty" json:"trackId,omitempty"`
}

// UploadCoverMultipartBody defines parameters for UploadCover.
type UploadCoverMultipartBody struct {
	// Cover Файл баннера
	Cover *openapi_types.File `json:"cover,omitempty"`
}

// UploadCoverParams defines parameters for UploadCover.
type UploadCoverParams struct {
	// CoverSize Массив данных о ресайзе баннера
	CoverSize *Resize `json:"coverSize,omitempty"`
}

// UploadLogMultipartBody defines parameters for UploadLog.
type UploadLogMultipartBody struct {
	// DeviceId Идентификатор устройства
	DeviceId string `json:"deviceId"`

	// UploadFiles Файл
	UploadFiles openapi_types.File `json:"upload_files"`
}

// UploadPortfolioFileMultipartBody defines parameters for UploadPortfolioFile.
type UploadPortfolioFileMultipartBody struct {
	// File Файл
	File openapi_types.File `json:"file"`
}

// UploadPortfolioFileParams defines parameters for UploadPortfolioFile.
type UploadPortfolioFileParams struct {
	// Hashes Идентификаторы хешей для проверки на дубли
	Hashes *[]int `form:"hashes[],omitempty" json:"hashes[],omitempty"`
}

// UploadedFileParams defines parameters for UploadedFile.
type UploadedFileParams struct {
	// Path Путь к файлу
	Path string `form:"path" json:"path"`
}

// UserParams defines parameters for User.
type UserParams struct {
	// Id Идентификатор пользователя
	Id int `form:"id" json:"id"`

	// WithHidden Отображать скрытые значения полей
	WithHidden *int `form:"with_hidden,omitempty" json:"with_hidden,omitempty"`
}

// UserByUsernameParams defines parameters for UserByUsername.
type UserByUsernameParams struct {
	// Username Имя пользователя
	Username string `form:"username" json:"username"`

	// WithHidden Отображать скрытые значения полей
	WithHidden *int `form:"with_hidden,omitempty" json:"with_hidden,omitempty"`
}

// UserKworksParams defines parameters for UserKworks.
type UserKworksParams struct {
	// UserId Идентификатор пользователя-продавца кворка
	UserId int `form:"user_id" json:"user_id"`

	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// CategoryId Идентификатор категории
	CategoryId *int `form:"category_id,omitempty" json:"category_id,omitempty"`

	// StatusId Идентификатор статуса
	StatusId *int `form:"status_id,omitempty" json:"status_id,omitempty"`
}

// UserReviewsParams defines parameters for UserReviews.
type UserReviewsParams struct {
	// UserId ID пользователя
	UserId int `form:"user_id" json:"user_id"`

	// Type Тип: positive|negative|all - положительные, отрицательные или все отзывы
	Type UserReviewsParamsType `form:"type" json:"type"`

	// Page страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// UserReviewsParamsType defines parameters for UserReviews.
type UserReviewsParamsType string

// UserSearchParams defines parameters for UserSearch.
type UserSearchParams struct {
	// Query Строка поиска
	Query string `form:"query" json:"query"`

	// Page Номер страницы результатов
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// VerifyPhoneActivationCodeParams defines parameters for VerifyPhoneActivationCode.
type VerifyPhoneActivationCodeParams struct {
	// Code Код подтверждения
	Code *string `form:"code,omitempty" json:"code,omitempty"`
}

// VerifySmsCodeForAccountDeletingParams defines parameters for VerifySmsCodeForAccountDeleting.
type VerifySmsCodeForAccountDeletingParams struct {
	// Code Код подтверждения
	Code *int `form:"code,omitempty" json:"code,omitempty"`
}

// ViewedCatalogKworksParams defines parameters for ViewedCatalogKworks.
type ViewedCatalogKworksParams struct {
	// Page Страница выдачи
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// VoiceUploadMultipartBody defines parameters for VoiceUpload.
type VoiceUploadMultipartBody struct {
	// UploadFiles Файл
	UploadFiles openapi_types.File `json:"upload_files"`
}

// VoiceUploadParams defines parameters for VoiceUpload.
type VoiceUploadParams struct {
	// VoicePeaks Пики аудиодороги
	VoicePeaks *[]float32 `form:"voice_peaks,omitempty" json:"voice_peaks,omitempty"`
}

// WantParams defines parameters for Want.
type WantParams struct {
	// Id Идентификатор запроса на услугу
	Id int `form:"id" json:"id"`
}

// WorkerConfirmsExtraRemovalRequestParams defines parameters for WorkerConfirmsExtraRemovalRequest.
type WorkerConfirmsExtraRemovalRequestParams struct {
	// TrackId Идентификатор трека
	TrackId int `form:"track_id" json:"track_id"`
}

// WorkerDeclineExtrasParams defines parameters for WorkerDeclineExtras.
type WorkerDeclineExtrasParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// TrackId Идентификатор трека в котором предложили опции
	TrackId int `form:"track_id" json:"track_id"`
}

// WorkerDeclinesExtraRemovalRequestParams defines parameters for WorkerDeclinesExtraRemovalRequest.
type WorkerDeclinesExtraRemovalRequestParams struct {
	// TrackId Идентификатор трека
	TrackId int `form:"track_id" json:"track_id"`
}

// WorkerExtraDeleteParams defines parameters for WorkerExtraDelete.
type WorkerExtraDeleteParams struct {
	// ExtraId Идентификатор опции
	ExtraId int `form:"extra_id" json:"extra_id"`
}

// WorkerInprogressParams defines parameters for WorkerInprogress.
type WorkerInprogressParams struct {
	// OrderId Идентификатор заказа
	OrderId int `form:"order_id" json:"order_id"`

	// ContractsAgreement Согласие с изменениями в документах
	ContractsAgreement *bool `form:"contracts_agreement,omitempty" json:"contracts_agreement,omitempty"`
}

// WorkerOrdersParams defines parameters for WorkerOrders.
type WorkerOrdersParams struct {
	// Filter фильтр (необязательный) active - В работе, cancelled - Отменено, delivered - На проверке, completed - Выполнено, unpaid - Ожидает оплаты, awaiting_receipt - Ожидается чек, all - Все
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Page страница выдачи
	Page *string `form:"page,omitempty" json:"page,omitempty"`
}

// ActorFormdataRequestBody defines body for Actor for application/x-www-form-urlencoded ContentType.
type ActorFormdataRequestBody ActorFormdataBody

// AppleSignInFormdataRequestBody defines body for AppleSignIn for application/x-www-form-urlencoded ContentType.
type AppleSignInFormdataRequestBody AppleSignInFormdataBody

// CancelOrderByPayerFormdataRequestBody defines body for CancelOrderByPayer for application/x-www-form-urlencoded ContentType.
type CancelOrderByPayerFormdataRequestBody CancelOrderByPayerFormdataBody

// CancelOrderByWorkerFormdataRequestBody defines body for CancelOrderByWorker for application/x-www-form-urlencoded ContentType.
type CancelOrderByWorkerFormdataRequestBody CancelOrderByWorkerFormdataBody

// ChangePasswordFormdataRequestBody defines body for ChangePassword for application/x-www-form-urlencoded ContentType.
type ChangePasswordFormdataRequestBody ChangePasswordFormdataBody

// ChangeUsernameFormdataRequestBody defines body for ChangeUsername for application/x-www-form-urlencoded ContentType.
type ChangeUsernameFormdataRequestBody ChangeUsernameFormdataBody

// CheckLoginFormdataRequestBody defines body for CheckLogin for application/x-www-form-urlencoded ContentType.
type CheckLoginFormdataRequestBody CheckLoginFormdataBody

// CreateAnswerFormdataRequestBody defines body for CreateAnswer for application/x-www-form-urlencoded ContentType.
type CreateAnswerFormdataRequestBody CreateAnswerFormdataBody

// CreateKworkComplainFormdataRequestBody defines body for CreateKworkComplain for application/x-www-form-urlencoded ContentType.
type CreateKworkComplainFormdataRequestBody CreateKworkComplainFormdataBody

// CreateReviewFormdataRequestBody defines body for CreateReview for application/x-www-form-urlencoded ContentType.
type CreateReviewFormdataRequestBody CreateReviewFormdataBody

// EditAnswerFormdataRequestBody defines body for EditAnswer for application/x-www-form-urlencoded ContentType.
type EditAnswerFormdataRequestBody EditAnswerFormdataBody

// EditReviewFormdataRequestBody defines body for EditReview for application/x-www-form-urlencoded ContentType.
type EditReviewFormdataRequestBody EditReviewFormdataBody

// FileUploadMultipartRequestBody defines body for FileUpload for multipart/form-data ContentType.
type FileUploadMultipartRequestBody FileUploadMultipartBody

// GetActorInfoFormdataRequestBody defines body for GetActorInfo for application/x-www-form-urlencoded ContentType.
type GetActorInfoFormdataRequestBody GetActorInfoFormdataBody

// GetBadgesInfoFormdataRequestBody defines body for GetBadgesInfo for application/x-www-form-urlencoded ContentType.
type GetBadgesInfoFormdataRequestBody GetBadgesInfoFormdataBody

// InboxComplainMessageFormdataRequestBody defines body for InboxComplainMessage for application/x-www-form-urlencoded ContentType.
type InboxComplainMessageFormdataRequestBody InboxComplainMessageFormdataBody

// InboxCreateFormdataRequestBody defines body for InboxCreate for application/x-www-form-urlencoded ContentType.
type InboxCreateFormdataRequestBody InboxCreateFormdataBody

// InboxEditFormdataRequestBody defines body for InboxEdit for application/x-www-form-urlencoded ContentType.
type InboxEditFormdataRequestBody InboxEditFormdataBody

// ResetPasswordFormdataRequestBody defines body for ResetPassword for application/x-www-form-urlencoded ContentType.
type ResetPasswordFormdataRequestBody ResetPasswordFormdataBody

// SaveOrderNoteFormdataRequestBody defines body for SaveOrderNote for application/x-www-form-urlencoded ContentType.
type SaveOrderNoteFormdataRequestBody SaveOrderNoteFormdataBody

// SaveUserNoteFormdataRequestBody defines body for SaveUserNote for application/x-www-form-urlencoded ContentType.
type SaveUserNoteFormdataRequestBody SaveUserNoteFormdataBody

// SignInFormdataRequestBody defines body for SignIn for application/x-www-form-urlencoded ContentType.
type SignInFormdataRequestBody SignInFormdataBody

// SignUpFormdataRequestBody defines body for SignUp for application/x-www-form-urlencoded ContentType.
type SignUpFormdataRequestBody SignUpFormdataBody

// SocialSignInFormdataRequestBody defines body for SocialSignIn for application/x-www-form-urlencoded ContentType.
type SocialSignInFormdataRequestBody SocialSignInFormdataBody

// SocialSignInByTokenFormdataRequestBody defines body for SocialSignInByToken for application/x-www-form-urlencoded ContentType.
type SocialSignInByTokenFormdataRequestBody SocialSignInByTokenFormdataBody

// SocialSignInByTokenv2FormdataRequestBody defines body for SocialSignInByTokenv2 for application/x-www-form-urlencoded ContentType.
type SocialSignInByTokenv2FormdataRequestBody SocialSignInByTokenv2FormdataBody

// SocialSignUpFormdataRequestBody defines body for SocialSignUp for application/x-www-form-urlencoded ContentType.
type SocialSignUpFormdataRequestBody SocialSignUpFormdataBody

// SocialSignUpByTokenFormdataRequestBody defines body for SocialSignUpByToken for application/x-www-form-urlencoded ContentType.
type SocialSignUpByTokenFormdataRequestBody SocialSignUpByTokenFormdataBody

// TrackEditFormdataRequestBody defines body for TrackEdit for application/x-www-form-urlencoded ContentType.
type TrackEditFormdataRequestBody TrackEditFormdataBody

// UpdateAvatarMultipartRequestBody defines body for UpdateAvatar for multipart/form-data ContentType.
type UpdateAvatarMultipartRequestBody UpdateAvatarMultipartBody

// UpdateSettingsMultipartRequestBody defines body for UpdateSettings for multipart/form-data ContentType.
type UpdateSettingsMultipartRequestBody UpdateSettingsMultipartBody

// UploadCoverMultipartRequestBody defines body for UploadCover for multipart/form-data ContentType.
type UploadCoverMultipartRequestBody UploadCoverMultipartBody

// UploadLogMultipartRequestBody defines body for UploadLog for multipart/form-data ContentType.
type UploadLogMultipartRequestBody UploadLogMultipartBody

// UploadPortfolioFileMultipartRequestBody defines body for UploadPortfolioFile for multipart/form-data ContentType.
type UploadPortfolioFileMultipartRequestBody UploadPortfolioFileMultipartBody

// VoiceUploadMultipartRequestBody defines body for VoiceUpload for multipart/form-data ContentType.
type VoiceUploadMultipartRequestBody VoiceUploadMultipartBody

// AsSimpleNotification returns the union data inside the Notification as a SimpleNotification
func (t Notification) AsSimpleNotification() (SimpleNotification, error) {
	var body SimpleNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleNotification overwrites any union data inside the Notification as the provided SimpleNotification
func (t *Notification) FromSimpleNotification(v SimpleNotification) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleNotification performs a merge with any union data inside the Notification, using the provided SimpleNotification
func (t *Notification) MergeSimpleNotification(v SimpleNotification) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKworkNotification returns the union data inside the Notification as a KworkNotification
func (t Notification) AsKworkNotification() (KworkNotification, error) {
	var body KworkNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKworkNotification overwrites any union data inside the Notification as the provided KworkNotification
func (t *Notification) FromKworkNotification(v KworkNotification) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKworkNotification performs a merge with any union data inside the Notification, using the provided KworkNotification
func (t *Notification) MergeKworkNotification(v KworkNotification) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserNotification returns the union data inside the Notification as a UserNotification
func (t Notification) AsUserNotification() (UserNotification, error) {
	var body UserNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserNotification overwrites any union data inside the Notification as the provided UserNotification
func (t *Notification) FromUserNotification(v UserNotification) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserNotification performs a merge with any union data inside the Notification, using the provided UserNotification
func (t *Notification) MergeUserNotification(v UserNotification) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderNotification returns the union data inside the Notification as a OrderNotification
func (t Notification) AsOrderNotification() (OrderNotification, error) {
	var body OrderNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderNotification overwrites any union data inside the Notification as the provided OrderNotification
func (t *Notification) FromOrderNotification(v OrderNotification) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderNotification performs a merge with any union data inside the Notification, using the provided OrderNotification
func (t *Notification) MergeOrderNotification(v OrderNotification) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStageNotification returns the union data inside the Notification as a StageNotification
func (t Notification) AsStageNotification() (StageNotification, error) {
	var body StageNotification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStageNotification overwrites any union data inside the Notification as the provided StageNotification
func (t *Notification) FromStageNotification(v StageNotification) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStageNotification performs a merge with any union data inside the Notification, using the provided StageNotification
func (t *Notification) MergeStageNotification(v StageNotification) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Notification) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Notification) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AcceptExtras request
	AcceptExtras(ctx context.Context, params *AcceptExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptStageSuggestion request
	AcceptStageSuggestion(ctx context.Context, params *AcceptStageSuggestionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActorWithBody request with any body
	ActorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActorWithFormdataBody(ctx context.Context, body ActorFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFavoriteCategories request
	AddFavoriteCategories(ctx context.Context, params *AddFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddNewPhoneNumber request
	AddNewPhoneNumber(ctx context.Context, params *AddNewPhoneNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPhoneNumber request
	AddPhoneNumber(ctx context.Context, params *AddPhoneNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddStage request
	AddStage(ctx context.Context, params *AddStageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllowInboxRequest request
	AllowInboxRequest(ctx context.Context, params *AllowInboxRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllowMobilePush request
	AllowMobilePush(ctx context.Context, params *AllowMobilePushParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllowOrderPortfolioUpload request
	AllowOrderPortfolioUpload(ctx context.Context, params *AllowOrderPortfolioUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllowPushNotificationsSound request
	AllowPushNotificationsSound(ctx context.Context, params *AllowPushNotificationsSoundParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppleSignInWithBody request with any body
	AppleSignInWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppleSignInWithFormdataBody(ctx context.Context, body AppleSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApplyFilters request
	ApplyFilters(ctx context.Context, params *ApplyFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveOrder request
	ApproveOrder(ctx context.Context, params *ApproveOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveOrderStage request
	ApproveOrderStage(ctx context.Context, params *ApproveOrderStageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveDialog request
	ArchiveDialog(ctx context.Context, params *ArchiveDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockDialog request
	BlockDialog(ctx context.Context, params *BlockDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedDialogList request
	BlockedDialogList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelOrderAwaitingPayment request
	CancelOrderAwaitingPayment(ctx context.Context, params *CancelOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelOrderByPayerWithBody request with any body
	CancelOrderByPayerWithBody(ctx context.Context, params *CancelOrderByPayerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelOrderByPayerWithFormdataBody(ctx context.Context, params *CancelOrderByPayerParams, body CancelOrderByPayerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelOrderByWorkerWithBody request with any body
	CancelOrderByWorkerWithBody(ctx context.Context, params *CancelOrderByWorkerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelOrderByWorkerWithFormdataBody(ctx context.Context, params *CancelOrderByWorkerParams, body CancelOrderByWorkerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CatalogCategories request
	CatalogCategories(ctx context.Context, params *CatalogCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CatalogFilters request
	CatalogFilters(ctx context.Context, params *CatalogFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CatalogMain request
	CatalogMain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CatalogMainv2 request
	CatalogMainv2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CatalogRubrics request
	CatalogRubrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Categories request
	Categories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Category request
	Category(ctx context.Context, params *CategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CategoryAttributes request
	CategoryAttributes(ctx context.Context, params *CategoryAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePasswordWithBody request with any body
	ChangePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePasswordWithFormdataBody(ctx context.Context, body ChangePasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePayerSubRole request
	ChangePayerSubRole(ctx context.Context, params *ChangePayerSubRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeUsernameWithBody request with any body
	ChangeUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeUsernameWithFormdataBody(ctx context.Context, body ChangeUsernameFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckLoginWithBody request with any body
	CheckLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckLoginWithFormdataBody(ctx context.Context, body CheckLoginFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cities request
	Cities(ctx context.Context, params *CitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearFilters request
	ClearFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmCancelOrderRequestByPayer request
	ConfirmCancelOrderRequestByPayer(ctx context.Context, params *ConfirmCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmCancelOrderRequestByWorker request
	ConfirmCancelOrderRequestByWorker(ctx context.Context, params *ConfirmCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Countries request
	Countries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAnswerWithBody request with any body
	CreateAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAnswerWithFormdataBody(ctx context.Context, body CreateAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKworkComplainWithBody request with any body
	CreateKworkComplainWithBody(ctx context.Context, params *CreateKworkComplainParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKworkComplainWithFormdataBody(ctx context.Context, params *CreateKworkComplainParams, body CreateKworkComplainFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePortfolio request
	CreatePortfolio(ctx context.Context, params *CreatePortfolioParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReviewWithBody request with any body
	CreateReviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReviewWithFormdataBody(ctx context.Context, body CreateReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStage request
	CreateStage(ctx context.Context, params *CreateStageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelFavoriteCategories request
	DelFavoriteCategories(ctx context.Context, params *DelFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccount request
	DeleteAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCancelOrderRequestByPayer request
	DeleteCancelOrderRequestByPayer(ctx context.Context, params *DeleteCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCancelOrderRequestByWorker request
	DeleteCancelOrderRequestByWorker(ctx context.Context, params *DeleteCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCover request
	DeleteCover(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKwork request
	DeleteKwork(ctx context.Context, params *DeleteKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOffer request
	DeleteOffer(ctx context.Context, params *DeleteOfferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderNote request
	DeleteOrderNote(ctx context.Context, params *DeleteOrderNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePortfolio request
	DeletePortfolio(ctx context.Context, params *DeletePortfolioParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReview request
	DeleteReview(ctx context.Context, params *DeleteReviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStage request
	DeleteStage(ctx context.Context, params *DeleteStageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserNote request
	DeleteUserNote(ctx context.Context, params *DeleteUserNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWant request
	DeleteWant(ctx context.Context, params *DeleteWantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dialogs request
	Dialogs(ctx context.Context, params *DialogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAnswerWithBody request with any body
	EditAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditAnswerWithFormdataBody(ctx context.Context, body EditAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditPortfolio request
	EditPortfolio(ctx context.Context, params *EditPortfolioParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditReviewWithBody request with any body
	EditReviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditReviewWithFormdataBody(ctx context.Context, body EditReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditStage request
	EditStage(ctx context.Context, params *EditStageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailVerificationLetter request
	EmailVerificationLetter(ctx context.Context, params *EmailVerificationLetterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeInfo request
	ExchangeInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FavoriteCategories request
	FavoriteCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FavoriteKworks request
	FavoriteKworks(ctx context.Context, params *FavoriteKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FcmNotificationsRead request
	FcmNotificationsRead(ctx context.Context, params *FcmNotificationsReadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FcmNotificationsReceived request
	FcmNotificationsReceived(ctx context.Context, params *FcmNotificationsReceivedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FcmTokenRequestFailed request
	FcmTokenRequestFailed(ctx context.Context, params *FcmTokenRequestFailedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileDelete request
	FileDelete(ctx context.Context, params *FileDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileUploadWithBody request with any body
	FileUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActorInfoWithBody request with any body
	GetActorInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetActorInfoWithFormdataBody(ctx context.Context, body GetActorInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArbitrationReasons request
	GetArbitrationReasons(ctx context.Context, params *GetArbitrationReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableFeatures request
	GetAvailableFeatures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBadgesInfoWithBody request with any body
	GetBadgesInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBadgesInfoWithFormdataBody(ctx context.Context, body GetBadgesInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillRefillUrl request
	GetBillRefillUrl(ctx context.Context, params *GetBillRefillUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaptchaStatus request
	GetCaptchaStatus(ctx context.Context, params *GetCaptchaStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannel request
	GetChannel(ctx context.Context, params *GetChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanyDetails request
	GetCompanyDetails(ctx context.Context, params *GetCompanyDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplainCategories request
	GetComplainCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCookie request
	GetCookie(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentVersions request
	GetCurrentVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomOptionsPresets request
	GetCustomOptionsPresets(ctx context.Context, params *GetCustomOptionsPresetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDialog request
	GetDialog(ctx context.Context, params *GetDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtrasAvailableForOrder request
	GetExtrasAvailableForOrder(ctx context.Context, params *GetExtrasAvailableForOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFishingTutorialQuestions request
	GetFishingTutorialQuestions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHiddenKworks request
	GetHiddenKworks(ctx context.Context, params *GetHiddenKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInboxTracks request
	GetInboxTracks(ctx context.Context, params *GetInboxTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkAnswers request
	GetKworkAnswers(ctx context.Context, params *GetKworkAnswersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkDetails request
	GetKworkDetails(ctx context.Context, params *GetKworkDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkDetailsExtra request
	GetKworkDetailsExtra(ctx context.Context, params *GetKworkDetailsExtraParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkLinksTable request
	GetKworkLinksTable(ctx context.Context, params *GetKworkLinksTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkLinksTablev2 request
	GetKworkLinksTablev2(ctx context.Context, params *GetKworkLinksTablev2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkPortfolios request
	GetKworkPortfolios(ctx context.Context, params *GetKworkPortfoliosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKworkReviews request
	GetKworkReviews(ctx context.Context, params *GetKworkReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderCancellationReasons request
	GetOrderCancellationReasons(ctx context.Context, params *GetOrderCancellationReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderDetails request
	GetOrderDetails(ctx context.Context, params *GetOrderDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderFiles request
	GetOrderFiles(ctx context.Context, params *GetOrderFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderHeader request
	GetOrderHeader(ctx context.Context, params *GetOrderHeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderProvidedData request
	GetOrderProvidedData(ctx context.Context, params *GetOrderProvidedDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderedExtras request
	GetOrderedExtras(ctx context.Context, params *GetOrderedExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayerCompanyModalUrl request
	GetPayerCompanyModalUrl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentMethods request
	GetPaymentMethods(ctx context.Context, params *GetPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityUserData request
	GetSecurityUserData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscribersStatistics request
	GetSubscribersStatistics(ctx context.Context, params *GetSubscribersStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracks request
	GetTracks(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersLastOrderInfo request
	GetUsersLastOrderInfo(ctx context.Context, params *GetUsersLastOrderInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceMessageConvertStatus request
	GetVoiceMessageConvertStatus(ctx context.Context, params *GetVoiceMessageConvertStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceMessageTranscription request
	GetVoiceMessageTranscription(ctx context.Context, params *GetVoiceMessageTranscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWantsCount request
	GetWantsCount(ctx context.Context, params *GetWantsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebAuthToken request
	GetWebAuthToken(ctx context.Context, params *GetWebAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HideDialog request
	HideDialog(ctx context.Context, params *HideDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HideSelfEmployedNotification request
	HideSelfEmployedNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HideVoiceMessageSettingsPopup request
	HideVoiceMessageSettingsPopup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxComplainMessageWithBody request with any body
	InboxComplainMessageWithBody(ctx context.Context, params *InboxComplainMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InboxComplainMessageWithFormdataBody(ctx context.Context, params *InboxComplainMessageParams, body InboxComplainMessageFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxCreateWithBody request with any body
	InboxCreateWithBody(ctx context.Context, params *InboxCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InboxCreateWithFormdataBody(ctx context.Context, params *InboxCreateParams, body InboxCreateFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxCustomRequestDecline request
	InboxCustomRequestDecline(ctx context.Context, params *InboxCustomRequestDeclineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxDelete request
	InboxDelete(ctx context.Context, params *InboxDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxEditWithBody request with any body
	InboxEditWithBody(ctx context.Context, params *InboxEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InboxEditWithFormdataBody(ctx context.Context, params *InboxEditParams, body InboxEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxForward request
	InboxForward(ctx context.Context, params *InboxForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxMessage request
	InboxMessage(ctx context.Context, params *InboxMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxPayerDecline request
	InboxPayerDecline(ctx context.Context, params *InboxPayerDeclineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxRead request
	InboxRead(ctx context.Context, params *InboxReadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxTrackMessage request
	InboxTrackMessage(ctx context.Context, params *InboxTrackMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InboxWorkerDecline request
	InboxWorkerDecline(ctx context.Context, params *InboxWorkerDeclineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Inboxes request
	Inboxes(ctx context.Context, params *InboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsDialogAllow request
	IsDialogAllow(ctx context.Context, params *IsDialogAllowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Kworks request
	Kworks(ctx context.Context, params *KworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KworksCategoriesList request
	KworksCategoriesList(ctx context.Context, params *KworksCategoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// KworksStatusList request
	KworksStatusList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkInboxTracksAsRead request
	MarkInboxTracksAsRead(ctx context.Context, params *MarkInboxTracksAsReadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkKworkAsFavorite request
	MarkKworkAsFavorite(ctx context.Context, params *MarkKworkAsFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkKworkAsHidden request
	MarkKworkAsHidden(ctx context.Context, params *MarkKworkAsHiddenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkKworksBlackFriday request
	MarkKworksBlackFriday(ctx context.Context, params *MarkKworksBlackFridayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkVoiceMessageHeard request
	MarkVoiceMessageHeard(ctx context.Context, params *MarkVoiceMessageHeardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Miniature request
	Miniature(ctx context.Context, params *MiniatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MyWants request
	MyWants(ctx context.Context, params *MyWantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Notifications request
	Notifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsFetch request
	NotificationsFetch(ctx context.Context, params *NotificationsFetchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationsReceived request
	NotificationsReceived(ctx context.Context, params *NotificationsReceivedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Offer request
	Offer(ctx context.Context, params *OfferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OfferOrderOptions request
	OfferOrderOptions(ctx context.Context, params *OfferOrderOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Offers request
	Offers(ctx context.Context, params *OffersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Offline request
	Offline(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Order request
	Order(ctx context.Context, params *OrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrderKwork request
	OrderKwork(ctx context.Context, params *OrderKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrderStage request
	OrderStage(ctx context.Context, params *OrderStageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrdersBetween request
	OrdersBetween(ctx context.Context, params *OrdersBetweenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseKwork request
	PauseKwork(ctx context.Context, params *PauseKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayOrderAwaitingPayment request
	PayOrderAwaitingPayment(ctx context.Context, params *PayOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayerBuyExtras request
	PayerBuyExtras(ctx context.Context, params *PayerBuyExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayerDeclineExtras request
	PayerDeclineExtras(ctx context.Context, params *PayerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayerDeclinesExtraRemovalRequest request
	PayerDeclinesExtraRemovalRequest(ctx context.Context, params *PayerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayerExtraDelete request
	PayerExtraDelete(ctx context.Context, params *PayerExtraDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayerOrders request
	PayerOrders(ctx context.Context, params *PayerOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayerUpgradePackage request
	PayerUpgradePackage(ctx context.Context, params *PayerUpgradePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PortfolioCategoriesList request
	PortfolioCategoriesList(ctx context.Context, params *PortfolioCategoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PortfolioList request
	PortfolioList(ctx context.Context, params *PortfolioListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PositiveReviewsCount request
	PositiveReviewsCount(ctx context.Context, params *PositiveReviewsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Privacy request
	Privacy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Projects request
	Projects(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushInAppNotificationLog request
	PushInAppNotificationLog(ctx context.Context, params *PushInAppNotificationLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RateArbitration request
	RateArbitration(ctx context.Context, params *RateArbitrationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RechargeBalance request
	RechargeBalance(ctx context.Context, params *RechargeBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterCloudToken request
	RegisterCloudToken(ctx context.Context, params *RegisterCloudTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectCancelOrderRequestByPayer request
	RejectCancelOrderRequestByPayer(ctx context.Context, params *RejectCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectCancelOrderRequestByWorker request
	RejectCancelOrderRequestByWorker(ctx context.Context, params *RejectCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectStageSuggestion request
	RejectStageSuggestion(ctx context.Context, params *RejectStageSuggestionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepeatOrder request
	RepeatOrder(ctx context.Context, params *RepeatOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportAppVersion request
	ReportAppVersion(ctx context.Context, params *ReportAppVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestPhoneChanging request
	RequestPhoneChanging(ctx context.Context, params *RequestPhoneChangingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPasswordWithFormdataBody(ctx context.Context, body ResetPasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Resolution request
	Resolution(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartWant request
	RestartWant(ctx context.Context, params *RestartWantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveOrderNoteWithBody request with any body
	SaveOrderNoteWithBody(ctx context.Context, params *SaveOrderNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveOrderNoteWithFormdataBody(ctx context.Context, params *SaveOrderNoteParams, body SaveOrderNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserNoteWithBody request with any body
	SaveUserNoteWithBody(ctx context.Context, params *SaveUserNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserNoteWithFormdataBody(ctx context.Context, params *SaveUserNoteParams, body SaveUserNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDialogs request
	SearchDialogs(ctx context.Context, params *SearchDialogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchInboxes request
	SearchInboxes(ctx context.Context, params *SearchInboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchKworksCatalogQuery request
	SearchKworksCatalogQuery(ctx context.Context, params *SearchKworksCatalogQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMessages request
	SearchMessages(ctx context.Context, params *SearchMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchOrderTracks request
	SearchOrderTracks(ctx context.Context, params *SearchOrderTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTracks request
	SearchTracks(ctx context.Context, params *SearchTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendBonus request
	SendBonus(ctx context.Context, params *SendBonusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendCompanyForVerification request
	SendCompanyForVerification(ctx context.Context, params *SendCompanyForVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendOrderForApproval request
	SendOrderForApproval(ctx context.Context, params *SendOrderForApprovalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendOrderForArbitration request
	SendOrderForArbitration(ctx context.Context, params *SendOrderForArbitrationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendOrderForRevision request
	SendOrderForRevision(ctx context.Context, params *SendOrderForRevisionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendOrderReceiptLinkForVerification request
	SendOrderReceiptLinkForVerification(ctx context.Context, params *SendOrderReceiptLinkForVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendOrderRequirements request
	SendOrderRequirements(ctx context.Context, params *SendOrderRequirementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendReport request
	SendReport(ctx context.Context, params *SendReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendSelfEmployedSurveyResult request
	SendSelfEmployedSurveyResult(ctx context.Context, params *SendSelfEmployedSurveyResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendUserStatus request
	SendUserStatus(ctx context.Context, params *SendUserStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendWhatsAppCode request
	SendWhatsAppCode(ctx context.Context, params *SendWhatsAppCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAvailableAtWeekends request
	SetAvailableAtWeekends(ctx context.Context, params *SetAvailableAtWeekendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDialogStarred request
	SetDialogStarred(ctx context.Context, params *SetDialogStarredParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFavorite request
	SetFavorite(ctx context.Context, params *SetFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFishingTutorialStatus request
	SetFishingTutorialStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOrderRating request
	SetOrderRating(ctx context.Context, params *SetOrderRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetTakingOrders request
	SetTakingOrders(ctx context.Context, params *SetTakingOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetUserType request
	SetUserType(ctx context.Context, params *SetUserTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVoiceMessageReceiving request
	SetVoiceMessageReceiving(ctx context.Context, params *SetVoiceMessageReceivingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVoiceMessageSpeed request
	SetVoiceMessageSpeed(ctx context.Context, params *SetVoiceMessageSpeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignInWithBody request with any body
	SignInWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignInWithFormdataBody(ctx context.Context, body SignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignUpWithBody request with any body
	SignUpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignUpWithFormdataBody(ctx context.Context, body SignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialSignInWithBody request with any body
	SocialSignInWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SocialSignInWithFormdataBody(ctx context.Context, body SocialSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialSignInByTokenWithBody request with any body
	SocialSignInByTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SocialSignInByTokenWithFormdataBody(ctx context.Context, body SocialSignInByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialSignInByTokenv2WithBody request with any body
	SocialSignInByTokenv2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SocialSignInByTokenv2WithFormdataBody(ctx context.Context, body SocialSignInByTokenv2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialSignUpWithBody request with any body
	SocialSignUpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SocialSignUpWithFormdataBody(ctx context.Context, body SocialSignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialSignUpByTokenWithBody request with any body
	SocialSignUpByTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SocialSignUpByTokenWithFormdataBody(ctx context.Context, body SocialSignUpByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartKwork request
	StartKwork(ctx context.Context, params *StartKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopWant request
	StopWant(ctx context.Context, params *StopWantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuggestStages request
	SuggestStages(ctx context.Context, params *SuggestStagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Terms request
	Terms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TermsOfService request
	TermsOfService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Timezones request
	Timezones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackDelete request
	TrackDelete(ctx context.Context, params *TrackDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackEditWithBody request with any body
	TrackEditWithBody(ctx context.Context, params *TrackEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TrackEditWithFormdataBody(ctx context.Context, params *TrackEditParams, body TrackEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackMessage request
	TrackMessage(ctx context.Context, params *TrackMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackRead request
	TrackRead(ctx context.Context, params *TrackReadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TranslationLanguages request
	TranslationLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Typing request
	Typing(ctx context.Context, params *TypingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveDialog request
	UnarchiveDialog(ctx context.Context, params *UnarchiveDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnblockDialog request
	UnblockDialog(ctx context.Context, params *UnblockDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnreadDialog request
	UnreadDialog(ctx context.Context, params *UnreadDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAvatarWithBody request with any body
	UpdateAvatarWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChatDraftMessage request
	UpdateChatDraftMessage(ctx context.Context, params *UpdateChatDraftMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrderDraftMessage request
	UpdateOrderDraftMessage(ctx context.Context, params *UpdateOrderDraftMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSettingsWithBody request with any body
	UpdateSettingsWithBody(ctx context.Context, params *UpdateSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStageProgress request
	UpdateStageProgress(ctx context.Context, params *UpdateStageProgressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCoverWithBody request with any body
	UploadCoverWithBody(ctx context.Context, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLogWithBody request with any body
	UploadLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPortfolioFileWithBody request with any body
	UploadPortfolioFileWithBody(ctx context.Context, params *UploadPortfolioFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadedFile request
	UploadedFile(ctx context.Context, params *UploadedFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// User request
	User(ctx context.Context, params *UserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserByUsername request
	UserByUsername(ctx context.Context, params *UserByUsernameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserKworks request
	UserKworks(ctx context.Context, params *UserKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserReviews request
	UserReviews(ctx context.Context, params *UserReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSearch request
	UserSearch(ctx context.Context, params *UserSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyPhoneActivationCode request
	VerifyPhoneActivationCode(ctx context.Context, params *VerifyPhoneActivationCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifySmsCodeForAccountDeleting request
	VerifySmsCodeForAccountDeleting(ctx context.Context, params *VerifySmsCodeForAccountDeletingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ViewedCatalogKworks request
	ViewedCatalogKworks(ctx context.Context, params *ViewedCatalogKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VoiceUploadWithBody request with any body
	VoiceUploadWithBody(ctx context.Context, params *VoiceUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Want request
	Want(ctx context.Context, params *WantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WantsStatusList request
	WantsStatusList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerConfirmsExtraRemovalRequest request
	WorkerConfirmsExtraRemovalRequest(ctx context.Context, params *WorkerConfirmsExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerDeclineExtras request
	WorkerDeclineExtras(ctx context.Context, params *WorkerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerDeclinesExtraRemovalRequest request
	WorkerDeclinesExtraRemovalRequest(ctx context.Context, params *WorkerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerExtraDelete request
	WorkerExtraDelete(ctx context.Context, params *WorkerExtraDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerInprogress request
	WorkerInprogress(ctx context.Context, params *WorkerInprogressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerOrders request
	WorkerOrders(ctx context.Context, params *WorkerOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AcceptExtras(ctx context.Context, params *AcceptExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptExtrasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptStageSuggestion(ctx context.Context, params *AcceptStageSuggestionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptStageSuggestionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActorRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActorWithFormdataBody(ctx context.Context, body ActorFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActorRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFavoriteCategories(ctx context.Context, params *AddFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFavoriteCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNewPhoneNumber(ctx context.Context, params *AddNewPhoneNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNewPhoneNumberRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPhoneNumber(ctx context.Context, params *AddPhoneNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPhoneNumberRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddStage(ctx context.Context, params *AddStageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddStageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllowInboxRequest(ctx context.Context, params *AllowInboxRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllowInboxRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllowMobilePush(ctx context.Context, params *AllowMobilePushParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllowMobilePushRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllowOrderPortfolioUpload(ctx context.Context, params *AllowOrderPortfolioUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllowOrderPortfolioUploadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllowPushNotificationsSound(ctx context.Context, params *AllowPushNotificationsSoundParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllowPushNotificationsSoundRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppleSignInWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppleSignInRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppleSignInWithFormdataBody(ctx context.Context, body AppleSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppleSignInRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplyFilters(ctx context.Context, params *ApplyFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveOrder(ctx context.Context, params *ApproveOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveOrderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveOrderStage(ctx context.Context, params *ApproveOrderStageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveOrderStageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDialog(ctx context.Context, params *ArchiveDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockDialog(ctx context.Context, params *BlockDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockedDialogList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedDialogListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelOrderAwaitingPayment(ctx context.Context, params *CancelOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelOrderAwaitingPaymentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelOrderByPayerWithBody(ctx context.Context, params *CancelOrderByPayerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelOrderByPayerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelOrderByPayerWithFormdataBody(ctx context.Context, params *CancelOrderByPayerParams, body CancelOrderByPayerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelOrderByPayerRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelOrderByWorkerWithBody(ctx context.Context, params *CancelOrderByWorkerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelOrderByWorkerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelOrderByWorkerWithFormdataBody(ctx context.Context, params *CancelOrderByWorkerParams, body CancelOrderByWorkerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelOrderByWorkerRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CatalogCategories(ctx context.Context, params *CatalogCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCatalogCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CatalogFilters(ctx context.Context, params *CatalogFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCatalogFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CatalogMain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCatalogMainRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CatalogMainv2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCatalogMainv2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CatalogRubrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCatalogRubricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Categories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Category(ctx context.Context, params *CategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CategoryAttributes(ctx context.Context, params *CategoryAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCategoryAttributesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordWithFormdataBody(ctx context.Context, body ChangePasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePayerSubRole(ctx context.Context, params *ChangePayerSubRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePayerSubRoleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeUsernameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeUsernameWithFormdataBody(ctx context.Context, body ChangeUsernameFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeUsernameRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckLoginWithFormdataBody(ctx context.Context, body CheckLoginFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckLoginRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cities(ctx context.Context, params *CitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmCancelOrderRequestByPayer(ctx context.Context, params *ConfirmCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmCancelOrderRequestByPayerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmCancelOrderRequestByWorker(ctx context.Context, params *ConfirmCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmCancelOrderRequestByWorkerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Countries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnswerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAnswerWithFormdataBody(ctx context.Context, body CreateAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAnswerRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKworkComplainWithBody(ctx context.Context, params *CreateKworkComplainParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKworkComplainRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKworkComplainWithFormdataBody(ctx context.Context, params *CreateKworkComplainParams, body CreateKworkComplainFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKworkComplainRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortfolio(ctx context.Context, params *CreatePortfolioParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortfolioRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReviewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReviewWithFormdataBody(ctx context.Context, body CreateReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReviewRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStage(ctx context.Context, params *CreateStageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DelFavoriteCategories(ctx context.Context, params *DelFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelFavoriteCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCancelOrderRequestByPayer(ctx context.Context, params *DeleteCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCancelOrderRequestByPayerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCancelOrderRequestByWorker(ctx context.Context, params *DeleteCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCancelOrderRequestByWorkerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCover(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCoverRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKwork(ctx context.Context, params *DeleteKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKworkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOffer(ctx context.Context, params *DeleteOfferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOfferRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderNote(ctx context.Context, params *DeleteOrderNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderNoteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePortfolio(ctx context.Context, params *DeletePortfolioParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePortfolioRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReview(ctx context.Context, params *DeleteReviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReviewRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStage(ctx context.Context, params *DeleteStageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserNote(ctx context.Context, params *DeleteUserNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserNoteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWant(ctx context.Context, params *DeleteWantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWantRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dialogs(ctx context.Context, params *DialogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDialogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAnswerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAnswerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAnswerWithFormdataBody(ctx context.Context, body EditAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAnswerRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPortfolio(ctx context.Context, params *EditPortfolioParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPortfolioRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditReviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditReviewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditReviewWithFormdataBody(ctx context.Context, body EditReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditReviewRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditStage(ctx context.Context, params *EditStageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditStageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailVerificationLetter(ctx context.Context, params *EmailVerificationLetterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailVerificationLetterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FavoriteCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFavoriteCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FavoriteKworks(ctx context.Context, params *FavoriteKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFavoriteKworksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FcmNotificationsRead(ctx context.Context, params *FcmNotificationsReadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFcmNotificationsReadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FcmNotificationsReceived(ctx context.Context, params *FcmNotificationsReceivedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFcmNotificationsReceivedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FcmTokenRequestFailed(ctx context.Context, params *FcmTokenRequestFailedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFcmTokenRequestFailedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileDelete(ctx context.Context, params *FileDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActorInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActorInfoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActorInfoWithFormdataBody(ctx context.Context, body GetActorInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActorInfoRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArbitrationReasons(ctx context.Context, params *GetArbitrationReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArbitrationReasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableFeatures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableFeaturesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBadgesInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBadgesInfoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBadgesInfoWithFormdataBody(ctx context.Context, body GetBadgesInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBadgesInfoRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillRefillUrl(ctx context.Context, params *GetBillRefillUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillRefillUrlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptchaStatus(ctx context.Context, params *GetCaptchaStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptchaStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannel(ctx context.Context, params *GetChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompanyDetails(ctx context.Context, params *GetCompanyDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplainCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplainCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCookie(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCookieRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomOptionsPresets(ctx context.Context, params *GetCustomOptionsPresetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomOptionsPresetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDialog(ctx context.Context, params *GetDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtrasAvailableForOrder(ctx context.Context, params *GetExtrasAvailableForOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtrasAvailableForOrderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFishingTutorialQuestions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFishingTutorialQuestionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHiddenKworks(ctx context.Context, params *GetHiddenKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHiddenKworksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInboxTracks(ctx context.Context, params *GetInboxTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInboxTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkAnswers(ctx context.Context, params *GetKworkAnswersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkAnswersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkDetails(ctx context.Context, params *GetKworkDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkDetailsExtra(ctx context.Context, params *GetKworkDetailsExtraParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkDetailsExtraRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkLinksTable(ctx context.Context, params *GetKworkLinksTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkLinksTableRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkLinksTablev2(ctx context.Context, params *GetKworkLinksTablev2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkLinksTablev2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkPortfolios(ctx context.Context, params *GetKworkPortfoliosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkPortfoliosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKworkReviews(ctx context.Context, params *GetKworkReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKworkReviewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderCancellationReasons(ctx context.Context, params *GetOrderCancellationReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderCancellationReasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderDetails(ctx context.Context, params *GetOrderDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderFiles(ctx context.Context, params *GetOrderFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderHeader(ctx context.Context, params *GetOrderHeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderHeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderProvidedData(ctx context.Context, params *GetOrderProvidedDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderProvidedDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderedExtras(ctx context.Context, params *GetOrderedExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderedExtrasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayerCompanyModalUrl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayerCompanyModalUrlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentMethods(ctx context.Context, params *GetPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityUserData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityUserDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscribersStatistics(ctx context.Context, params *GetSubscribersStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscribersStatisticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracks(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersLastOrderInfo(ctx context.Context, params *GetUsersLastOrderInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersLastOrderInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceMessageConvertStatus(ctx context.Context, params *GetVoiceMessageConvertStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceMessageConvertStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceMessageTranscription(ctx context.Context, params *GetVoiceMessageTranscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceMessageTranscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWantsCount(ctx context.Context, params *GetWantsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWantsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebAuthToken(ctx context.Context, params *GetWebAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebAuthTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideDialog(ctx context.Context, params *HideDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideSelfEmployedNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideSelfEmployedNotificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideVoiceMessageSettingsPopup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideVoiceMessageSettingsPopupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxComplainMessageWithBody(ctx context.Context, params *InboxComplainMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxComplainMessageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxComplainMessageWithFormdataBody(ctx context.Context, params *InboxComplainMessageParams, body InboxComplainMessageFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxComplainMessageRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxCreateWithBody(ctx context.Context, params *InboxCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxCreateWithFormdataBody(ctx context.Context, params *InboxCreateParams, body InboxCreateFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxCreateRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxCustomRequestDecline(ctx context.Context, params *InboxCustomRequestDeclineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxCustomRequestDeclineRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxDelete(ctx context.Context, params *InboxDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxEditWithBody(ctx context.Context, params *InboxEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxEditRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxEditWithFormdataBody(ctx context.Context, params *InboxEditParams, body InboxEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxEditRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxForward(ctx context.Context, params *InboxForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxForwardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxMessage(ctx context.Context, params *InboxMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxMessageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxPayerDecline(ctx context.Context, params *InboxPayerDeclineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxPayerDeclineRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxRead(ctx context.Context, params *InboxReadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxReadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxTrackMessage(ctx context.Context, params *InboxTrackMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxTrackMessageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InboxWorkerDecline(ctx context.Context, params *InboxWorkerDeclineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxWorkerDeclineRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Inboxes(ctx context.Context, params *InboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsDialogAllow(ctx context.Context, params *IsDialogAllowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsDialogAllowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Kworks(ctx context.Context, params *KworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKworksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KworksCategoriesList(ctx context.Context, params *KworksCategoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKworksCategoriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) KworksStatusList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewKworksStatusListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkInboxTracksAsRead(ctx context.Context, params *MarkInboxTracksAsReadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkInboxTracksAsReadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkKworkAsFavorite(ctx context.Context, params *MarkKworkAsFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkKworkAsFavoriteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkKworkAsHidden(ctx context.Context, params *MarkKworkAsHiddenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkKworkAsHiddenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkKworksBlackFriday(ctx context.Context, params *MarkKworksBlackFridayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkKworksBlackFridayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkVoiceMessageHeard(ctx context.Context, params *MarkVoiceMessageHeardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkVoiceMessageHeardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Miniature(ctx context.Context, params *MiniatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMiniatureRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MyWants(ctx context.Context, params *MyWantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMyWantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Notifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsFetch(ctx context.Context, params *NotificationsFetchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsFetchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationsReceived(ctx context.Context, params *NotificationsReceivedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationsReceivedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Offer(ctx context.Context, params *OfferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfferRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OfferOrderOptions(ctx context.Context, params *OfferOrderOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfferOrderOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Offers(ctx context.Context, params *OffersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOffersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Offline(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfflineRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Order(ctx context.Context, params *OrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrderKwork(ctx context.Context, params *OrderKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderKworkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrderStage(ctx context.Context, params *OrderStageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderStageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrdersBetween(ctx context.Context, params *OrdersBetweenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrdersBetweenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseKwork(ctx context.Context, params *PauseKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseKworkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayOrderAwaitingPayment(ctx context.Context, params *PayOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayOrderAwaitingPaymentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayerBuyExtras(ctx context.Context, params *PayerBuyExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayerBuyExtrasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayerDeclineExtras(ctx context.Context, params *PayerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayerDeclineExtrasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayerDeclinesExtraRemovalRequest(ctx context.Context, params *PayerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayerDeclinesExtraRemovalRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayerExtraDelete(ctx context.Context, params *PayerExtraDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayerExtraDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayerOrders(ctx context.Context, params *PayerOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayerOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayerUpgradePackage(ctx context.Context, params *PayerUpgradePackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayerUpgradePackageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PortfolioCategoriesList(ctx context.Context, params *PortfolioCategoriesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPortfolioCategoriesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PortfolioList(ctx context.Context, params *PortfolioListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPortfolioListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PositiveReviewsCount(ctx context.Context, params *PositiveReviewsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPositiveReviewsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Privacy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrivacyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Projects(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushInAppNotificationLog(ctx context.Context, params *PushInAppNotificationLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushInAppNotificationLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RateArbitration(ctx context.Context, params *RateArbitrationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRateArbitrationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RechargeBalance(ctx context.Context, params *RechargeBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRechargeBalanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterCloudToken(ctx context.Context, params *RegisterCloudTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterCloudTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectCancelOrderRequestByPayer(ctx context.Context, params *RejectCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectCancelOrderRequestByPayerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectCancelOrderRequestByWorker(ctx context.Context, params *RejectCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectCancelOrderRequestByWorkerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectStageSuggestion(ctx context.Context, params *RejectStageSuggestionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectStageSuggestionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepeatOrder(ctx context.Context, params *RepeatOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepeatOrderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportAppVersion(ctx context.Context, params *ReportAppVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportAppVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestPhoneChanging(ctx context.Context, params *RequestPhoneChangingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestPhoneChangingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithFormdataBody(ctx context.Context, body ResetPasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Resolution(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolutionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartWant(ctx context.Context, params *RestartWantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartWantRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveOrderNoteWithBody(ctx context.Context, params *SaveOrderNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveOrderNoteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveOrderNoteWithFormdataBody(ctx context.Context, params *SaveOrderNoteParams, body SaveOrderNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveOrderNoteRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserNoteWithBody(ctx context.Context, params *SaveUserNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserNoteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserNoteWithFormdataBody(ctx context.Context, params *SaveUserNoteParams, body SaveUserNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserNoteRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDialogs(ctx context.Context, params *SearchDialogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDialogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchInboxes(ctx context.Context, params *SearchInboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchInboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchKworksCatalogQuery(ctx context.Context, params *SearchKworksCatalogQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchKworksCatalogQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMessages(ctx context.Context, params *SearchMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchOrderTracks(ctx context.Context, params *SearchOrderTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchOrderTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTracks(ctx context.Context, params *SearchTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendBonus(ctx context.Context, params *SendBonusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendBonusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendCompanyForVerification(ctx context.Context, params *SendCompanyForVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendCompanyForVerificationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOrderForApproval(ctx context.Context, params *SendOrderForApprovalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOrderForApprovalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOrderForArbitration(ctx context.Context, params *SendOrderForArbitrationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOrderForArbitrationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOrderForRevision(ctx context.Context, params *SendOrderForRevisionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOrderForRevisionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOrderReceiptLinkForVerification(ctx context.Context, params *SendOrderReceiptLinkForVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOrderReceiptLinkForVerificationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendOrderRequirements(ctx context.Context, params *SendOrderRequirementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendOrderRequirementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReport(ctx context.Context, params *SendReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendSelfEmployedSurveyResult(ctx context.Context, params *SendSelfEmployedSurveyResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendSelfEmployedSurveyResultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendUserStatus(ctx context.Context, params *SendUserStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendWhatsAppCode(ctx context.Context, params *SendWhatsAppCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendWhatsAppCodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAvailableAtWeekends(ctx context.Context, params *SetAvailableAtWeekendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAvailableAtWeekendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDialogStarred(ctx context.Context, params *SetDialogStarredParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDialogStarredRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFavorite(ctx context.Context, params *SetFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFavoriteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFishingTutorialStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFishingTutorialStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOrderRating(ctx context.Context, params *SetOrderRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOrderRatingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetTakingOrders(ctx context.Context, params *SetTakingOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetTakingOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUserType(ctx context.Context, params *SetUserTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUserTypeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVoiceMessageReceiving(ctx context.Context, params *SetVoiceMessageReceivingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVoiceMessageReceivingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVoiceMessageSpeed(ctx context.Context, params *SetVoiceMessageSpeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVoiceMessageSpeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignInWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignInRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignInWithFormdataBody(ctx context.Context, body SignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignInRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignUpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignUpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignUpWithFormdataBody(ctx context.Context, body SignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignUpRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignInWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignInRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignInWithFormdataBody(ctx context.Context, body SocialSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignInRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignInByTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignInByTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignInByTokenWithFormdataBody(ctx context.Context, body SocialSignInByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignInByTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignInByTokenv2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignInByTokenv2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignInByTokenv2WithFormdataBody(ctx context.Context, body SocialSignInByTokenv2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignInByTokenv2RequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignUpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignUpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignUpWithFormdataBody(ctx context.Context, body SocialSignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignUpRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignUpByTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignUpByTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialSignUpByTokenWithFormdataBody(ctx context.Context, body SocialSignUpByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialSignUpByTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartKwork(ctx context.Context, params *StartKworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartKworkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopWant(ctx context.Context, params *StopWantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopWantRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuggestStages(ctx context.Context, params *SuggestStagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuggestStagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Terms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTermsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TermsOfService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTermsOfServiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Timezones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimezonesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackDelete(ctx context.Context, params *TrackDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackEditWithBody(ctx context.Context, params *TrackEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackEditRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackEditWithFormdataBody(ctx context.Context, params *TrackEditParams, body TrackEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackEditRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackMessage(ctx context.Context, params *TrackMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackMessageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackRead(ctx context.Context, params *TrackReadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackReadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TranslationLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTranslationLanguagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Typing(ctx context.Context, params *TypingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTypingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDialog(ctx context.Context, params *UnarchiveDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnblockDialog(ctx context.Context, params *UnblockDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnblockDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnreadDialog(ctx context.Context, params *UnreadDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnreadDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAvatarWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAvatarRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChatDraftMessage(ctx context.Context, params *UpdateChatDraftMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatDraftMessageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrderDraftMessage(ctx context.Context, params *UpdateOrderDraftMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrderDraftMessageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsWithBody(ctx context.Context, params *UpdateSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStageProgress(ctx context.Context, params *UpdateStageProgressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStageProgressRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCoverWithBody(ctx context.Context, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCoverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPortfolioFileWithBody(ctx context.Context, params *UploadPortfolioFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPortfolioFileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadedFile(ctx context.Context, params *UploadedFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadedFileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) User(ctx context.Context, params *UserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserByUsername(ctx context.Context, params *UserByUsernameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserByUsernameRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserKworks(ctx context.Context, params *UserKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserKworksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserReviews(ctx context.Context, params *UserReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserReviewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSearch(ctx context.Context, params *UserSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyPhoneActivationCode(ctx context.Context, params *VerifyPhoneActivationCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyPhoneActivationCodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifySmsCodeForAccountDeleting(ctx context.Context, params *VerifySmsCodeForAccountDeletingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifySmsCodeForAccountDeletingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViewedCatalogKworks(ctx context.Context, params *ViewedCatalogKworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViewedCatalogKworksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoiceUploadWithBody(ctx context.Context, params *VoiceUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoiceUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Want(ctx context.Context, params *WantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWantRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WantsStatusList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWantsStatusListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerConfirmsExtraRemovalRequest(ctx context.Context, params *WorkerConfirmsExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerConfirmsExtraRemovalRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerDeclineExtras(ctx context.Context, params *WorkerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerDeclineExtrasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerDeclinesExtraRemovalRequest(ctx context.Context, params *WorkerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerDeclinesExtraRemovalRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerExtraDelete(ctx context.Context, params *WorkerExtraDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerExtraDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerInprogress(ctx context.Context, params *WorkerInprogressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerInprogressRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerOrders(ctx context.Context, params *WorkerOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAcceptExtrasRequest generates requests for AcceptExtras
func NewAcceptExtrasRequest(server string, params *AcceptExtrasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/acceptExtras")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, params.TrackId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptStageSuggestionRequest generates requests for AcceptStageSuggestion
func NewAcceptStageSuggestionRequest(server string, params *AcceptStageSuggestionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/acceptStageSuggestion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActorRequestWithFormdataBody calls the generic Actor builder with application/x-www-form-urlencoded body
func NewActorRequestWithFormdataBody(server string, body ActorFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewActorRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewActorRequestWithBody generates requests for Actor with any type of body
func NewActorRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/actor")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddFavoriteCategoriesRequest generates requests for AddFavoriteCategories
func NewAddFavoriteCategoriesRequest(server string, params *AddFavoriteCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addFavoriteCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, params.Categories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddNewPhoneNumberRequest generates requests for AddNewPhoneNumber
func NewAddNewPhoneNumberRequest(server string, params *AddNewPhoneNumberParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addNewPhoneNumber")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Hash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, *params.Hash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Phone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone", runtime.ParamLocationQuery, *params.Phone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPhoneNumberRequest generates requests for AddPhoneNumber
func NewAddPhoneNumberRequest(server string, params *AddPhoneNumberParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addPhoneNumber")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Phone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone", runtime.ParamLocationQuery, *params.Phone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddStageRequest generates requests for AddStage
func NewAddStageRequest(server string, params *AddStageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addStage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extend_time", runtime.ParamLocationQuery, params.ExtendTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stages", runtime.ParamLocationQuery, params.Stages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllowInboxRequestRequest generates requests for AllowInboxRequest
func NewAllowInboxRequestRequest(server string, params *AllowInboxRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/allowInboxRequest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboxId", runtime.ParamLocationQuery, params.InboxId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isAccept", runtime.ParamLocationQuery, params.IsAccept); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllowMobilePushRequest generates requests for AllowMobilePush
func NewAllowMobilePushRequest(server string, params *AllowMobilePushParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/allowMobilePush")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow", runtime.ParamLocationQuery, params.Allow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllowOrderPortfolioUploadRequest generates requests for AllowOrderPortfolioUpload
func NewAllowOrderPortfolioUploadRequest(server string, params *AllowOrderPortfolioUploadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/allowOrderPortfolioUpload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllowPushNotificationsSoundRequest generates requests for AllowPushNotificationsSound
func NewAllowPushNotificationsSoundRequest(server string, params *AllowPushNotificationsSoundParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/allowPushNotificationsSound")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow", runtime.ParamLocationQuery, params.Allow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppleSignInRequestWithFormdataBody calls the generic AppleSignIn builder with application/x-www-form-urlencoded body
func NewAppleSignInRequestWithFormdataBody(server string, body AppleSignInFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAppleSignInRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewAppleSignInRequestWithBody generates requests for AppleSignIn with any type of body
func NewAppleSignInRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appleSignIn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApplyFiltersRequest generates requests for ApplyFilters
func NewApplyFiltersRequest(server string, params *ApplyFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applyFilters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, params.Categories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PriceFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_from", runtime.ParamLocationQuery, *params.PriceFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to", runtime.ParamLocationQuery, *params.PriceTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HiringFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hiring_from", runtime.ParamLocationQuery, *params.HiringFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworksFilterFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworks_filter_from", runtime.ParamLocationQuery, *params.KworksFilterFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworksFilterTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworks_filter_to", runtime.ParamLocationQuery, *params.KworksFilterTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offers", runtime.ParamLocationQuery, *params.Offers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveOrderRequest generates requests for ApproveOrder
func NewApproveOrderRequest(server string, params *ApproveOrderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/approveOrder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portfolio", runtime.ParamLocationQuery, params.Portfolio); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveOrderStageRequest generates requests for ApproveOrderStage
func NewApproveOrderStageRequest(server string, params *ApproveOrderStageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/approveOrderStage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stageIds[]", runtime.ParamLocationQuery, *params.StageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveDialogRequest generates requests for ArchiveDialog
func NewArchiveDialogRequest(server string, params *ArchiveDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/archiveDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveUserId", runtime.ParamLocationQuery, params.ArchiveUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockDialogRequest generates requests for BlockDialog
func NewBlockDialogRequest(server string, params *BlockDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockUserId", runtime.ParamLocationQuery, params.BlockUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedDialogListRequest generates requests for BlockedDialogList
func NewBlockedDialogListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blockedDialogList")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelOrderAwaitingPaymentRequest generates requests for CancelOrderAwaitingPayment
func NewCancelOrderAwaitingPaymentRequest(server string, params *CancelOrderAwaitingPaymentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cancelOrderAwaitingPayment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelOrderByPayerRequestWithFormdataBody calls the generic CancelOrderByPayer builder with application/x-www-form-urlencoded body
func NewCancelOrderByPayerRequestWithFormdataBody(server string, params *CancelOrderByPayerParams, body CancelOrderByPayerFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCancelOrderByPayerRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewCancelOrderByPayerRequestWithBody generates requests for CancelOrderByPayer with any type of body
func NewCancelOrderByPayerRequestWithBody(server string, params *CancelOrderByPayerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cancelOrderByPayer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason_type", runtime.ParamLocationQuery, params.ReasonType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.HideKworks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hideKworks", runtime.ParamLocationQuery, *params.HideKworks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelOrderByWorkerRequestWithFormdataBody calls the generic CancelOrderByWorker builder with application/x-www-form-urlencoded body
func NewCancelOrderByWorkerRequestWithFormdataBody(server string, params *CancelOrderByWorkerParams, body CancelOrderByWorkerFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCancelOrderByWorkerRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewCancelOrderByWorkerRequestWithBody generates requests for CancelOrderByWorker with any type of body
func NewCancelOrderByWorkerRequestWithBody(server string, params *CancelOrderByWorkerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cancelOrderByWorker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason_type", runtime.ParamLocationQuery, params.ReasonType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCatalogCategoriesRequest generates requests for CatalogCategories
func NewCatalogCategoriesRequest(server string, params *CatalogCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rubricId", runtime.ParamLocationQuery, params.RubricId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCatalogFiltersRequest generates requests for CatalogFilters
func NewCatalogFiltersRequest(server string, params *CatalogFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogFilters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categoryId", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClassifierId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classifierId", runtime.ParamLocationQuery, *params.ClassifierId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSearch", runtime.ParamLocationQuery, *params.IsSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unembedded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unembedded", runtime.ParamLocationQuery, *params.Unembedded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JSONСФильтрами != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "JSON с фильтрами", runtime.ParamLocationQuery, *params.JSONСФильтрами); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCatalogMainRequest generates requests for CatalogMain
func NewCatalogMainRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogMain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCatalogMainv2Request generates requests for CatalogMainv2
func NewCatalogMainv2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogMainv2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCatalogRubricsRequest generates requests for CatalogRubrics
func NewCatalogRubricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogRubrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCategoriesRequest generates requests for Categories
func NewCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCategoryRequest generates requests for Category
func NewCategoryRequest(server string, params *CategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AttributeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "attribute_id", runtime.ParamLocationQuery, *params.AttributeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCategoryAttributesRequest generates requests for CategoryAttributes
func NewCategoryAttributesRequest(server string, params *CategoryAttributesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categoryAttributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, params.CategoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangePasswordRequestWithFormdataBody calls the generic ChangePassword builder with application/x-www-form-urlencoded body
func NewChangePasswordRequestWithFormdataBody(server string, body ChangePasswordFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewChangePasswordRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewChangePasswordRequestWithBody generates requests for ChangePassword with any type of body
func NewChangePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/changePassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangePayerSubRoleRequest generates requests for ChangePayerSubRole
func NewChangePayerSubRoleRequest(server string, params *ChangePayerSubRoleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/changePayerSubRole")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payerSubRole", runtime.ParamLocationQuery, params.PayerSubRole); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeUsernameRequestWithFormdataBody calls the generic ChangeUsername builder with application/x-www-form-urlencoded body
func NewChangeUsernameRequestWithFormdataBody(server string, body ChangeUsernameFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewChangeUsernameRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewChangeUsernameRequestWithBody generates requests for ChangeUsername with any type of body
func NewChangeUsernameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/changeUsername")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckLoginRequestWithFormdataBody calls the generic CheckLogin builder with application/x-www-form-urlencoded body
func NewCheckLoginRequestWithFormdataBody(server string, body CheckLoginFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCheckLoginRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCheckLoginRequestWithBody generates requests for CheckLogin with any type of body
func NewCheckLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/checkLogin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCitiesRequest generates requests for Cities
func NewCitiesRequest(server string, params *CitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryId", runtime.ParamLocationQuery, params.CountryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearFiltersRequest generates requests for ClearFilters
func NewClearFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clearFilters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmCancelOrderRequestByPayerRequest generates requests for ConfirmCancelOrderRequestByPayer
func NewConfirmCancelOrderRequestByPayerRequest(server string, params *ConfirmCancelOrderRequestByPayerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/confirmCancelOrderRequestByPayer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reply_type", runtime.ParamLocationQuery, params.ReplyType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmCancelOrderRequestByWorkerRequest generates requests for ConfirmCancelOrderRequestByWorker
func NewConfirmCancelOrderRequestByWorkerRequest(server string, params *ConfirmCancelOrderRequestByWorkerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/confirmCancelOrderRequestByWorker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountriesRequest generates requests for Countries
func NewCountriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/countries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAnswerRequestWithFormdataBody calls the generic CreateAnswer builder with application/x-www-form-urlencoded body
func NewCreateAnswerRequestWithFormdataBody(server string, body CreateAnswerFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateAnswerRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateAnswerRequestWithBody generates requests for CreateAnswer with any type of body
func NewCreateAnswerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createAnswer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateKworkComplainRequestWithFormdataBody calls the generic CreateKworkComplain builder with application/x-www-form-urlencoded body
func NewCreateKworkComplainRequestWithFormdataBody(server string, params *CreateKworkComplainParams, body CreateKworkComplainFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateKworkComplainRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateKworkComplainRequestWithBody generates requests for CreateKworkComplain with any type of body
func NewCreateKworkComplainRequestWithBody(server string, params *CreateKworkComplainParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createKworkComplain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, params.CategoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FilesNew != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files[new][]", runtime.ParamLocationQuery, *params.FilesNew); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePortfolioRequest generates requests for CreatePortfolio
func NewCreatePortfolioRequest(server string, params *CreatePortfolioParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createPortfolio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "images", runtime.ParamLocationQuery, params.Images); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cover", runtime.ParamLocationQuery, params.Cover); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AttributesIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes_ids[]", runtime.ParamLocationQuery, *params.AttributesIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReviewRequestWithFormdataBody calls the generic CreateReview builder with application/x-www-form-urlencoded body
func NewCreateReviewRequestWithFormdataBody(server string, body CreateReviewFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateReviewRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateReviewRequestWithBody generates requests for CreateReview with any type of body
func NewCreateReviewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createReview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateStageRequest generates requests for CreateStage
func NewCreateStageRequest(server string, params *CreateStageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/createStage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extend_time", runtime.ParamLocationQuery, params.ExtendTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stages", runtime.ParamLocationQuery, params.Stages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDelFavoriteCategoriesRequest generates requests for DelFavoriteCategories
func NewDelFavoriteCategoriesRequest(server string, params *DelFavoriteCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/delFavoriteCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, params.Categories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAccountRequest generates requests for DeleteAccount
func NewDeleteAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteAccount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCancelOrderRequestByPayerRequest generates requests for DeleteCancelOrderRequestByPayer
func NewDeleteCancelOrderRequestByPayerRequest(server string, params *DeleteCancelOrderRequestByPayerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteCancelOrderRequestByPayer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCancelOrderRequestByWorkerRequest generates requests for DeleteCancelOrderRequestByWorker
func NewDeleteCancelOrderRequestByWorkerRequest(server string, params *DeleteCancelOrderRequestByWorkerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteCancelOrderRequestByWorker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCoverRequest generates requests for DeleteCover
func NewDeleteCoverRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteCover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteKworkRequest generates requests for DeleteKwork
func NewDeleteKworkRequest(server string, params *DeleteKworkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteKwork")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOfferRequest generates requests for DeleteOffer
func NewDeleteOfferRequest(server string, params *DeleteOfferParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteOffer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOrderNoteRequest generates requests for DeleteOrderNote
func NewDeleteOrderNoteRequest(server string, params *DeleteOrderNoteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteOrderNote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePortfolioRequest generates requests for DeletePortfolio
func NewDeletePortfolioRequest(server string, params *DeletePortfolioParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deletePortfolio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portfolio_id", runtime.ParamLocationQuery, params.PortfolioId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unlink", runtime.ParamLocationQuery, params.Unlink); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReviewRequest generates requests for DeleteReview
func NewDeleteReviewRequest(server string, params *DeleteReviewParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteReview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStageRequest generates requests for DeleteStage
func NewDeleteStageRequest(server string, params *DeleteStageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteStage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stageId", runtime.ParamLocationQuery, params.StageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserNoteRequest generates requests for DeleteUserNote
func NewDeleteUserNoteRequest(server string, params *DeleteUserNoteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteUserNote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWantRequest generates requests for DeleteWant
func NewDeleteWantRequest(server string, params *DeleteWantParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deleteWant")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDialogsRequest generates requests for Dialogs
func NewDialogsRequest(server string, params *DialogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dialogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedIds", runtime.ParamLocationQuery, *params.ExcludedIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTracks", runtime.ParamLocationQuery, *params.WithTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditAnswerRequestWithFormdataBody calls the generic EditAnswer builder with application/x-www-form-urlencoded body
func NewEditAnswerRequestWithFormdataBody(server string, body EditAnswerFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewEditAnswerRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewEditAnswerRequestWithBody generates requests for EditAnswer with any type of body
func NewEditAnswerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editAnswer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditPortfolioRequest generates requests for EditPortfolio
func NewEditPortfolioRequest(server string, params *EditPortfolioParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editPortfolio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, params.Title); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, params.CategoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "images", runtime.ParamLocationQuery, params.Images); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cover", runtime.ParamLocationQuery, params.Cover); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AttributesIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes_ids[]", runtime.ParamLocationQuery, *params.AttributesIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworkId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, *params.KworkId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditReviewRequestWithFormdataBody calls the generic EditReview builder with application/x-www-form-urlencoded body
func NewEditReviewRequestWithFormdataBody(server string, body EditReviewFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewEditReviewRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewEditReviewRequestWithBody generates requests for EditReview with any type of body
func NewEditReviewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editReview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditStageRequest generates requests for EditStage
func NewEditStageRequest(server string, params *EditStageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editStage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extendTime", runtime.ParamLocationQuery, params.ExtendTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stages", runtime.ParamLocationQuery, params.Stages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailVerificationLetterRequest generates requests for EmailVerificationLetter
func NewEmailVerificationLetterRequest(server string, params *EmailVerificationLetterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emailVerificationLetter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeInfoRequest generates requests for ExchangeInfo
func NewExchangeInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchangeInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFavoriteCategoriesRequest generates requests for FavoriteCategories
func NewFavoriteCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFavoriteKworksRequest generates requests for FavoriteKworks
func NewFavoriteKworksRequest(server string, params *FavoriteKworksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteKworks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFcmNotificationsReadRequest generates requests for FcmNotificationsRead
func NewFcmNotificationsReadRequest(server string, params *FcmNotificationsReadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fcmNotificationsRead")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageIds[]", runtime.ParamLocationQuery, params.MessageIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFcmNotificationsReceivedRequest generates requests for FcmNotificationsReceived
func NewFcmNotificationsReceivedRequest(server string, params *FcmNotificationsReceivedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fcmNotificationsReceived")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageIds[]", runtime.ParamLocationQuery, params.MessageIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFcmTokenRequestFailedRequest generates requests for FcmTokenRequestFailed
func NewFcmTokenRequestFailedRequest(server string, params *FcmTokenRequestFailedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fcmTokenRequestFailed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "os", runtime.ParamLocationQuery, params.Os); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "os_version", runtime.ParamLocationQuery, params.OsVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device", runtime.ParamLocationQuery, params.Device); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_version", runtime.ParamLocationQuery, params.AppVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uad", runtime.ParamLocationQuery, params.Uad); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cancel_reason", runtime.ParamLocationQuery, params.CancelReason); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileDeleteRequest generates requests for FileDelete
func NewFileDeleteRequest(server string, params *FileDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fileDelete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_id", runtime.ParamLocationQuery, params.FileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileUploadRequestWithBody generates requests for FileUpload with any type of body
func NewFileUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fileUpload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActorInfoRequestWithFormdataBody calls the generic GetActorInfo builder with application/x-www-form-urlencoded body
func NewGetActorInfoRequestWithFormdataBody(server string, body GetActorInfoFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetActorInfoRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetActorInfoRequestWithBody generates requests for GetActorInfo with any type of body
func NewGetActorInfoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getActorInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArbitrationReasonsRequest generates requests for GetArbitrationReasons
func NewGetArbitrationReasonsRequest(server string, params *GetArbitrationReasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getArbitrationReasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailableFeaturesRequest generates requests for GetAvailableFeatures
func NewGetAvailableFeaturesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getAvailableFeatures")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBadgesInfoRequestWithFormdataBody calls the generic GetBadgesInfo builder with application/x-www-form-urlencoded body
func NewGetBadgesInfoRequestWithFormdataBody(server string, body GetBadgesInfoFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetBadgesInfoRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetBadgesInfoRequestWithBody generates requests for GetBadgesInfo with any type of body
func NewGetBadgesInfoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getBadgesInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBillRefillUrlRequest generates requests for GetBillRefillUrl
func NewGetBillRefillUrlRequest(server string, params *GetBillRefillUrlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getBillRefillUrl")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sum != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sum", runtime.ParamLocationQuery, *params.Sum); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptchaStatusRequest generates requests for GetCaptchaStatus
func NewGetCaptchaStatusRequest(server string, params *GetCaptchaStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getCaptchaStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelRequest generates requests for GetChannel
func NewGetChannelRequest(server string, params *GetChannelParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getChannel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Uad != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uad", runtime.ParamLocationQuery, *params.Uad); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyDetailsRequest generates requests for GetCompanyDetails
func NewGetCompanyDetailsRequest(server string, params *GetCompanyDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getCompanyDetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_number", runtime.ParamLocationQuery, params.TaxNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplainCategoriesRequest generates requests for GetComplainCategories
func NewGetComplainCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getComplainCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCookieRequest generates requests for GetCookie
func NewGetCookieRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getCookie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentVersionsRequest generates requests for GetCurrentVersions
func NewGetCurrentVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getCurrentVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomOptionsPresetsRequest generates requests for GetCustomOptionsPresets
func NewGetCustomOptionsPresetsRequest(server string, params *GetCustomOptionsPresetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getCustomOptionsPresets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDialogRequest generates requests for GetDialog
func NewGetDialogRequest(server string, params *GetDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WithTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTracks", runtime.ParamLocationQuery, *params.WithTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExtrasAvailableForOrderRequest generates requests for GetExtrasAvailableForOrder
func NewGetExtrasAvailableForOrderRequest(server string, params *GetExtrasAvailableForOrderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getExtrasAvailableForOrder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFishingTutorialQuestionsRequest generates requests for GetFishingTutorialQuestions
func NewGetFishingTutorialQuestionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getFishingTutorialQuestions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHiddenKworksRequest generates requests for GetHiddenKworks
func NewGetHiddenKworksRequest(server string, params *GetHiddenKworksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getHiddenKworks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInboxTracksRequest generates requests for GetInboxTracks
func NewGetInboxTracksRequest(server string, params *GetInboxTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getInboxTracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastConversationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastConversationId", runtime.ParamLocationQuery, *params.LastConversationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkAnswersRequest generates requests for GetKworkAnswers
func NewGetKworkAnswersRequest(server string, params *GetKworkAnswersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkAnswers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkDetailsRequest generates requests for GetKworkDetails
func NewGetKworkDetailsRequest(server string, params *GetKworkDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkDetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkDetailsExtraRequest generates requests for GetKworkDetailsExtra
func NewGetKworkDetailsExtraRequest(server string, params *GetKworkDetailsExtraParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkDetailsExtra")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkLinksTableRequest generates requests for GetKworkLinksTable
func NewGetKworkLinksTableRequest(server string, params *GetKworkLinksTableParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkLinksTable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkLinksTablev2Request generates requests for GetKworkLinksTablev2
func NewGetKworkLinksTablev2Request(server string, params *GetKworkLinksTablev2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkLinksTablev2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkPortfoliosRequest generates requests for GetKworkPortfolios
func NewGetKworkPortfoliosRequest(server string, params *GetKworkPortfoliosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkPortfolios")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKworkReviewsRequest generates requests for GetKworkReviews
func NewGetKworkReviewsRequest(server string, params *GetKworkReviewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getKworkReviews")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderCancellationReasonsRequest generates requests for GetOrderCancellationReasons
func NewGetOrderCancellationReasonsRequest(server string, params *GetOrderCancellationReasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getOrderCancellationReasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderDetailsRequest generates requests for GetOrderDetails
func NewGetOrderDetailsRequest(server string, params *GetOrderDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getOrderDetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderFilesRequest generates requests for GetOrderFiles
func NewGetOrderFilesRequest(server string, params *GetOrderFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getOrderFiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderHeaderRequest generates requests for GetOrderHeader
func NewGetOrderHeaderRequest(server string, params *GetOrderHeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getOrderHeader")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrderHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderHash", runtime.ParamLocationQuery, *params.OrderHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworkHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworkHash", runtime.ParamLocationQuery, *params.KworkHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PayerHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payerHash", runtime.ParamLocationQuery, *params.PayerHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkerHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerHash", runtime.ParamLocationQuery, *params.WorkerHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderProvidedDataRequest generates requests for GetOrderProvidedData
func NewGetOrderProvidedDataRequest(server string, params *GetOrderProvidedDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getOrderProvidedData")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderedExtrasRequest generates requests for GetOrderedExtras
func NewGetOrderedExtrasRequest(server string, params *GetOrderedExtrasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getOrderedExtras")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPayerCompanyModalUrlRequest generates requests for GetPayerCompanyModalUrl
func NewGetPayerCompanyModalUrlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getPayerCompanyModalUrl")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentMethodsRequest generates requests for GetPaymentMethods
func NewGetPaymentMethodsRequest(server string, params *GetPaymentMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getPaymentMethods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithCompany != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withCompany", runtime.ParamLocationQuery, *params.WithCompany); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecurityUserDataRequest generates requests for GetSecurityUserData
func NewGetSecurityUserDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getSecurityUserData")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscribersStatisticsRequest generates requests for GetSubscribersStatistics
func NewGetSubscribersStatisticsRequest(server string, params *GetSubscribersStatisticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getSubscribersStatistics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracksRequest generates requests for GetTracks
func NewGetTracksRequest(server string, params *GetTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getTracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TrackId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trackId", runtime.ParamLocationQuery, *params.TrackId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string, params *GetUserInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getUserInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersLastOrderInfoRequest generates requests for GetUsersLastOrderInfo
func NewGetUsersLastOrderInfoRequest(server string, params *GetUsersLastOrderInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getUsersLastOrderInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interlocutorId", runtime.ParamLocationQuery, params.InterlocutorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoiceMessageConvertStatusRequest generates requests for GetVoiceMessageConvertStatus
func NewGetVoiceMessageConvertStatusRequest(server string, params *GetVoiceMessageConvertStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getVoiceMessageConvertStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_id", runtime.ParamLocationQuery, params.FileId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoiceMessageTranscriptionRequest generates requests for GetVoiceMessageTranscription
func NewGetVoiceMessageTranscriptionRequest(server string, params *GetVoiceMessageTranscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getVoiceMessageTranscription")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "conversation_id", runtime.ParamLocationQuery, params.ConversationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWantsCountRequest generates requests for GetWantsCount
func NewGetWantsCountRequest(server string, params *GetWantsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getWantsCount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_from", runtime.ParamLocationQuery, *params.PriceFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to", runtime.ParamLocationQuery, *params.PriceTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HiringFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hiring_from", runtime.ParamLocationQuery, *params.HiringFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworksFilterFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworks_filter_from", runtime.ParamLocationQuery, *params.KworksFilterFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworksFilterTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworks_filter_to", runtime.ParamLocationQuery, *params.KworksFilterTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offers", runtime.ParamLocationQuery, *params.Offers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebAuthTokenRequest generates requests for GetWebAuthToken
func NewGetWebAuthTokenRequest(server string, params *GetWebAuthTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/getWebAuthToken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UrlToRedirect != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url_to_redirect", runtime.ParamLocationQuery, *params.UrlToRedirect); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHideDialogRequest generates requests for HideDialog
func NewHideDialogRequest(server string, params *HideDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hideDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isRestore", runtime.ParamLocationQuery, params.IsRestore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHideSelfEmployedNotificationRequest generates requests for HideSelfEmployedNotification
func NewHideSelfEmployedNotificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hideSelfEmployedNotification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHideVoiceMessageSettingsPopupRequest generates requests for HideVoiceMessageSettingsPopup
func NewHideVoiceMessageSettingsPopupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hideVoiceMessageSettingsPopup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxComplainMessageRequestWithFormdataBody calls the generic InboxComplainMessage builder with application/x-www-form-urlencoded body
func NewInboxComplainMessageRequestWithFormdataBody(server string, params *InboxComplainMessageParams, body InboxComplainMessageFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewInboxComplainMessageRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewInboxComplainMessageRequestWithBody generates requests for InboxComplainMessage with any type of body
func NewInboxComplainMessageRequestWithBody(server string, params *InboxComplainMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxComplainMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_id", runtime.ParamLocationQuery, params.MessageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ComplainCategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complain_category_id", runtime.ParamLocationQuery, *params.ComplainCategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInboxCreateRequestWithFormdataBody calls the generic InboxCreate builder with application/x-www-form-urlencoded body
func NewInboxCreateRequestWithFormdataBody(server string, params *InboxCreateParams, body InboxCreateFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewInboxCreateRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewInboxCreateRequestWithBody generates requests for InboxCreate with any type of body
func NewInboxCreateRequestWithBody(server string, params *InboxCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxCreate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Uuid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uuid", runtime.ParamLocationQuery, *params.Uuid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MessageKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_key", runtime.ParamLocationQuery, *params.MessageKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UploadedFiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploaded_files[]", runtime.ParamLocationQuery, *params.UploadedFiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReplyMessageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reply_message_id", runtime.ParamLocationQuery, *params.ReplyMessageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTracks", runtime.ParamLocationQuery, *params.WithTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInboxCustomRequestDeclineRequest generates requests for InboxCustomRequestDecline
func NewInboxCustomRequestDeclineRequest(server string, params *InboxCustomRequestDeclineParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxCustomRequestDecline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_id", runtime.ParamLocationQuery, params.MessageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxDeleteRequest generates requests for InboxDelete
func NewInboxDeleteRequest(server string, params *InboxDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxDelete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WithTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTracks", runtime.ParamLocationQuery, *params.WithTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxEditRequestWithFormdataBody calls the generic InboxEdit builder with application/x-www-form-urlencoded body
func NewInboxEditRequestWithFormdataBody(server string, params *InboxEditParams, body InboxEditFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewInboxEditRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewInboxEditRequestWithBody generates requests for InboxEdit with any type of body
func NewInboxEditRequestWithBody(server string, params *InboxEditParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxEdit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UploadedFiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "uploaded_files", runtime.ParamLocationQuery, *params.UploadedFiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReplyMessageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reply_message_id", runtime.ParamLocationQuery, *params.ReplyMessageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInboxForwardRequest generates requests for InboxForward
func NewInboxForwardRequest(server string, params *InboxForwardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxForward")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "message_ids", runtime.ParamLocationQuery, params.MessageIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxMessageRequest generates requests for InboxMessage
func NewInboxMessageRequest(server string, params *InboxMessageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageId", runtime.ParamLocationQuery, params.MessageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxPayerDeclineRequest generates requests for InboxPayerDecline
func NewInboxPayerDeclineRequest(server string, params *InboxPayerDeclineParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxPayerDecline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_id", runtime.ParamLocationQuery, params.MessageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxReadRequest generates requests for InboxRead
func NewInboxReadRequest(server string, params *InboxReadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxRead")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Messages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "messages", runtime.ParamLocationQuery, *params.Messages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxTrackMessageRequest generates requests for InboxTrackMessage
func NewInboxTrackMessageRequest(server string, params *InboxTrackMessageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxTrackMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "conversationId", runtime.ParamLocationQuery, params.ConversationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxWorkerDeclineRequest generates requests for InboxWorkerDecline
func NewInboxWorkerDeclineRequest(server string, params *InboxWorkerDeclineParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxWorkerDecline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_id", runtime.ParamLocationQuery, params.MessageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInboxesRequest generates requests for Inboxes
func NewInboxesRequest(server string, params *InboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsDialogAllowRequest generates requests for IsDialogAllow
func NewIsDialogAllowRequest(server string, params *IsDialogAllowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/isDialogAllow")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "receiverId", runtime.ParamLocationQuery, params.ReceiverId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WithTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTracks", runtime.ParamLocationQuery, *params.WithTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKworksRequest generates requests for Kworks
func NewKworksRequest(server string, params *KworksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kworks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categoryId", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClassifierId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classifierId", runtime.ParamLocationQuery, *params.ClassifierId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Excluded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded", runtime.ParamLocationQuery, *params.Excluded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unembedded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unembedded", runtime.ParamLocationQuery, *params.Unembedded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JSONСФильтрами != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "JSON с фильтрами", runtime.ParamLocationQuery, *params.JSONСФильтрами); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKworksCategoriesListRequest generates requests for KworksCategoriesList
func NewKworksCategoriesListRequest(server string, params *KworksCategoriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kworksCategoriesList")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewKworksStatusListRequest generates requests for KworksStatusList
func NewKworksStatusListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kworksStatusList")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PushToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pushToken", runtime.ParamLocationQuery, *params.PushToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkInboxTracksAsReadRequest generates requests for MarkInboxTracksAsRead
func NewMarkInboxTracksAsReadRequest(server string, params *MarkInboxTracksAsReadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markInboxTracksAsRead")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "conversationIds[]", runtime.ParamLocationQuery, params.ConversationIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkKworkAsFavoriteRequest generates requests for MarkKworkAsFavorite
func NewMarkKworkAsFavoriteRequest(server string, params *MarkKworkAsFavoriteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markKworkAsFavorite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_favorite", runtime.ParamLocationQuery, params.IsFavorite); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkKworkAsHiddenRequest generates requests for MarkKworkAsHidden
func NewMarkKworkAsHiddenRequest(server string, params *MarkKworkAsHiddenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markKworkAsHidden")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_hidden", runtime.ParamLocationQuery, params.IsHidden); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkKworksBlackFridayRequest generates requests for MarkKworksBlackFriday
func NewMarkKworksBlackFridayRequest(server string, params *MarkKworksBlackFridayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markKworksBlackFriday")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KworkId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworkId", runtime.ParamLocationQuery, *params.KworkId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkVoiceMessageHeardRequest generates requests for MarkVoiceMessageHeard
func NewMarkVoiceMessageHeardRequest(server string, params *MarkVoiceMessageHeardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markVoiceMessageHeard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "conversation_id", runtime.ParamLocationQuery, params.ConversationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMiniatureRequest generates requests for Miniature
func NewMiniatureRequest(server string, params *MiniatureParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/miniature")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMyWantsRequest generates requests for MyWants
func NewMyWantsRequest(server string, params *MyWantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/myWants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WantStatusId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "want_status_id", runtime.ParamLocationQuery, *params.WantStatusId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationsRequest generates requests for Notifications
func NewNotificationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationsFetchRequest generates requests for NotificationsFetch
func NewNotificationsFetchRequest(server string, params *NotificationsFetchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationsFetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uad != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uad", runtime.ParamLocationQuery, *params.Uad); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationsReceivedRequest generates requests for NotificationsReceived
func NewNotificationsReceivedRequest(server string, params *NotificationsReceivedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationsReceived")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfferRequest generates requests for Offer
func NewOfferRequest(server string, params *OfferParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfferOrderOptionsRequest generates requests for OfferOrderOptions
func NewOfferOrderOptionsRequest(server string, params *OfferOrderOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offerOrderOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Options != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "options", runtime.ParamLocationQuery, *params.Options); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "customOptions", runtime.ParamLocationQuery, *params.CustomOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedPackage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedPackage", runtime.ParamLocationQuery, *params.UpdatedPackage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOffersRequest generates requests for Offers
func NewOffersRequest(server string, params *OffersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfflineRequest generates requests for Offline
func NewOfflineRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrderRequest generates requests for Order
func NewOrderRequest(server string, params *OrderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/order")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrderKworkRequest generates requests for OrderKwork
func NewOrderKworkRequest(server string, params *OrderKworkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orderKwork")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworkId", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.KworksCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworksCount", runtime.ParamLocationQuery, *params.KworksCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeTypeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeTypeId", runtime.ParamLocationQuery, *params.VolumeTypeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Volume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volume", runtime.ParamLocationQuery, *params.Volume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PackageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageId", runtime.ParamLocationQuery, *params.PackageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extras != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extras", runtime.ParamLocationQuery, *params.Extras); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_format", runtime.ParamLocationQuery, *params.ChannelFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrderStageRequest generates requests for OrderStage
func NewOrderStageRequest(server string, params *OrderStageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orderStage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stage_id", runtime.ParamLocationQuery, params.StageId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrdersBetweenRequest generates requests for OrdersBetween
func NewOrdersBetweenRequest(server string, params *OrdersBetweenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ordersBetween")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseKworkRequest generates requests for PauseKwork
func NewPauseKworkRequest(server string, params *PauseKworkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pauseKwork")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayOrderAwaitingPaymentRequest generates requests for PayOrderAwaitingPayment
func NewPayOrderAwaitingPaymentRequest(server string, params *PayOrderAwaitingPaymentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payOrderAwaitingPayment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayerBuyExtrasRequest generates requests for PayerBuyExtras
func NewPayerBuyExtrasRequest(server string, params *PayerBuyExtrasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payerBuyExtras")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "extras", runtime.ParamLocationQuery, params.Extras); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AsVolume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "as_volume", runtime.ParamLocationQuery, *params.AsVolume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayerDeclineExtrasRequest generates requests for PayerDeclineExtras
func NewPayerDeclineExtrasRequest(server string, params *PayerDeclineExtrasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payerDeclineExtras")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, params.TrackId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayerDeclinesExtraRemovalRequestRequest generates requests for PayerDeclinesExtraRemovalRequest
func NewPayerDeclinesExtraRemovalRequestRequest(server string, params *PayerDeclinesExtraRemovalRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payerDeclinesExtraRemovalRequest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, params.TrackId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayerExtraDeleteRequest generates requests for PayerExtraDelete
func NewPayerExtraDeleteRequest(server string, params *PayerExtraDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payerExtraDelete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extra_id", runtime.ParamLocationQuery, params.ExtraId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayerOrdersRequest generates requests for PayerOrders
func NewPayerOrdersRequest(server string, params *PayerOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payerOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompanyOrders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company_orders", runtime.ParamLocationQuery, *params.CompanyOrders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayerUpgradePackageRequest generates requests for PayerUpgradePackage
func NewPayerUpgradePackageRequest(server string, params *PayerUpgradePackageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payerUpgradePackage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PackageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageType", runtime.ParamLocationQuery, *params.PackageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPortfolioCategoriesListRequest generates requests for PortfolioCategoriesList
func NewPortfolioCategoriesListRequest(server string, params *PortfolioCategoriesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portfolioCategoriesList")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPortfolioListRequest generates requests for PortfolioList
func NewPortfolioListRequest(server string, params *PortfolioListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portfolioList")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, params.CategoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPositiveReviewsCountRequest generates requests for PositiveReviewsCount
func NewPositiveReviewsCountRequest(server string, params *PositiveReviewsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/positiveReviewsCount")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AttributeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "attribute_id", runtime.ParamLocationQuery, *params.AttributeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrivacyRequest generates requests for Privacy
func NewPrivacyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/privacy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsRequest generates requests for Projects
func NewProjectsRequest(server string, params *ProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_from", runtime.ParamLocationQuery, *params.PriceFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_to", runtime.ParamLocationQuery, *params.PriceTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HiringFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hiring_from", runtime.ParamLocationQuery, *params.HiringFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworksFilterFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworks_filter_from", runtime.ParamLocationQuery, *params.KworksFilterFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KworksFilterTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kworks_filter_to", runtime.ParamLocationQuery, *params.KworksFilterTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offers", runtime.ParamLocationQuery, *params.Offers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPushInAppNotificationLogRequest generates requests for PushInAppNotificationLog
func NewPushInAppNotificationLogRequest(server string, params *PushInAppNotificationLogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pushInAppNotificationLog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notificationId", runtime.ParamLocationQuery, params.NotificationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PreviousShowDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "previousShowDate", runtime.ParamLocationQuery, *params.PreviousShowDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRateArbitrationRequest generates requests for RateArbitration
func NewRateArbitrationRequest(server string, params *RateArbitrationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rateArbitration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating", runtime.ParamLocationQuery, params.Rating); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRechargeBalanceRequest generates requests for RechargeBalance
func NewRechargeBalanceRequest(server string, params *RechargeBalanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rechargeBalance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_id", runtime.ParamLocationQuery, *params.PaymentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paymentType", runtime.ParamLocationQuery, params.PaymentType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.CountryGroupCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country_group_code", runtime.ParamLocationQuery, *params.CountryGroupCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterCloudTokenRequest generates requests for RegisterCloudToken
func NewRegisterCloudTokenRequest(server string, params *RegisterCloudTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registerCloudToken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cloud_token", runtime.ParamLocationQuery, params.CloudToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Os != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "os", runtime.ParamLocationQuery, *params.Os); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OsVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "os_version", runtime.ParamLocationQuery, *params.OsVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Device != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device", runtime.ParamLocationQuery, *params.Device); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_version", runtime.ParamLocationQuery, *params.AppVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uad != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uad", runtime.ParamLocationQuery, *params.Uad); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectCancelOrderRequestByPayerRequest generates requests for RejectCancelOrderRequestByPayer
func NewRejectCancelOrderRequestByPayerRequest(server string, params *RejectCancelOrderRequestByPayerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rejectCancelOrderRequestByPayer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectCancelOrderRequestByWorkerRequest generates requests for RejectCancelOrderRequestByWorker
func NewRejectCancelOrderRequestByWorkerRequest(server string, params *RejectCancelOrderRequestByWorkerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rejectCancelOrderRequestByWorker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectStageSuggestionRequest generates requests for RejectStageSuggestion
func NewRejectStageSuggestionRequest(server string, params *RejectStageSuggestionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rejectStageSuggestion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepeatOrderRequest generates requests for RepeatOrder
func NewRepeatOrderRequest(server string, params *RepeatOrderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repeatOrder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReportAppVersionRequest generates requests for ReportAppVersion
func NewReportAppVersionRequest(server string, params *ReportAppVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reportAppVersion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cloud_token", runtime.ParamLocationQuery, params.CloudToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_version", runtime.ParamLocationQuery, params.AppVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestPhoneChangingRequest generates requests for RequestPhoneChanging
func NewRequestPhoneChangingRequest(server string, params *RequestPhoneChangingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requestPhoneChanging")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PhoneLast != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone_last", runtime.ParamLocationQuery, *params.PhoneLast); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequestWithFormdataBody calls the generic ResetPassword builder with application/x-www-form-urlencoded body
func NewResetPasswordRequestWithFormdataBody(server string, body ResetPasswordFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewResetPasswordRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resetPassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResolutionRequest generates requests for Resolution
func NewResolutionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resolution")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartWantRequest generates requests for RestartWant
func NewRestartWantRequest(server string, params *RestartWantParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restartWant")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveOrderNoteRequestWithFormdataBody calls the generic SaveOrderNote builder with application/x-www-form-urlencoded body
func NewSaveOrderNoteRequestWithFormdataBody(server string, params *SaveOrderNoteParams, body SaveOrderNoteFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSaveOrderNoteRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewSaveOrderNoteRequestWithBody generates requests for SaveOrderNote with any type of body
func NewSaveOrderNoteRequestWithBody(server string, params *SaveOrderNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saveOrderNote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSaveUserNoteRequestWithFormdataBody calls the generic SaveUserNote builder with application/x-www-form-urlencoded body
func NewSaveUserNoteRequestWithFormdataBody(server string, params *SaveUserNoteParams, body SaveUserNoteFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSaveUserNoteRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewSaveUserNoteRequestWithBody generates requests for SaveUserNote with any type of body
func NewSaveUserNoteRequestWithBody(server string, params *SaveUserNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saveUserNote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categoryId", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClassifierId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classifierId", runtime.ParamLocationQuery, *params.ClassifierId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Excluded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excluded", runtime.ParamLocationQuery, *params.Excluded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unembedded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unembedded", runtime.ParamLocationQuery, *params.Unembedded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JSONСФильтрами != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "JSON с фильтрами", runtime.ParamLocationQuery, *params.JSONСФильтрами); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDialogsRequest generates requests for SearchDialogs
func NewSearchDialogsRequest(server string, params *SearchDialogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchDialogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedIds", runtime.ParamLocationQuery, *params.ExcludedIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTracks", runtime.ParamLocationQuery, *params.WithTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchInboxesRequest generates requests for SearchInboxes
func NewSearchInboxesRequest(server string, params *SearchInboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchInboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchKworksCatalogQueryRequest generates requests for SearchKworksCatalogQuery
func NewSearchKworksCatalogQueryRequest(server string, params *SearchKworksCatalogQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchKworksCatalogQuery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMessagesRequest generates requests for SearchMessages
func NewSearchMessagesRequest(server string, params *SearchMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchMessages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchOrderTracksRequest generates requests for SearchOrderTracks
func NewSearchOrderTracksRequest(server string, params *SearchOrderTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchOrderTracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchTracksRequest generates requests for SearchTracks
func NewSearchTracksRequest(server string, params *SearchTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchTracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendBonusRequest generates requests for SendBonus
func NewSendBonusRequest(server string, params *SendBonusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendBonus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bonus", runtime.ParamLocationQuery, params.Bonus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Comment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment", runtime.ParamLocationQuery, *params.Comment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendCompanyForVerificationRequest generates requests for SendCompanyForVerification
func NewSendCompanyForVerificationRequest(server string, params *SendCompanyForVerificationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendCompanyForVerification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_number", runtime.ParamLocationQuery, params.TaxNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Address != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, *params.Address); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendOrderForApprovalRequest generates requests for SendOrderForApproval
func NewSendOrderForApprovalRequest(server string, params *SendOrderForApprovalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendOrderForApproval")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics[]", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stageIds[]", runtime.ParamLocationQuery, *params.StageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilesIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filesIds[]", runtime.ParamLocationQuery, *params.FilesIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendOrderForArbitrationRequest generates requests for SendOrderForArbitration
func NewSendOrderForArbitrationRequest(server string, params *SendOrderForArbitrationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendOrderForArbitration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reasonId", runtime.ParamLocationQuery, params.ReasonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stageIds[]", runtime.ParamLocationQuery, *params.StageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comments", runtime.ParamLocationQuery, params.Comments); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files[]", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendOrderForRevisionRequest generates requests for SendOrderForRevision
func NewSendOrderForRevisionRequest(server string, params *SendOrderForRevisionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendOrderForRevision")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Revision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revision", runtime.ParamLocationQuery, *params.Revision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files[]", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stageIds[]", runtime.ParamLocationQuery, *params.StageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendOrderReceiptLinkForVerificationRequest generates requests for SendOrderReceiptLinkForVerification
func NewSendOrderReceiptLinkForVerificationRequest(server string, params *SendOrderReceiptLinkForVerificationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendOrderReceiptLinkForVerification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "receiptId", runtime.ParamLocationQuery, params.ReceiptId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "receiptLink", runtime.ParamLocationQuery, params.ReceiptLink); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendOrderRequirementsRequest generates requests for SendOrderRequirements
func NewSendOrderRequirementsRequest(server string, params *SendOrderRequirementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendOrderRequirements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Requirements != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requirements", runtime.ParamLocationQuery, *params.Requirements); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files[]", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics[]", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendReportRequest generates requests for SendReport
func NewSendReportRequest(server string, params *SendReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendReport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "progress", runtime.ParamLocationQuery, params.Progress); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment", runtime.ParamLocationQuery, params.Comment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TrackId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, *params.TrackId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendSelfEmployedSurveyResultRequest generates requests for SendSelfEmployedSurveyResult
func NewSendSelfEmployedSurveyResultRequest(server string, params *SendSelfEmployedSurveyResultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendSelfEmployedSurveyResult")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "answer", runtime.ParamLocationQuery, params.Answer); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendUserStatusRequest generates requests for SendUserStatus
func NewSendUserStatusRequest(server string, params *SendUserStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendUserStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendWhatsAppCodeRequest generates requests for SendWhatsAppCode
func NewSendWhatsAppCodeRequest(server string, params *SendWhatsAppCodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendWhatsAppCode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Phone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone", runtime.ParamLocationQuery, *params.Phone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, *params.Hash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAvailableAtWeekendsRequest generates requests for SetAvailableAtWeekends
func NewSetAvailableAtWeekendsRequest(server string, params *SetAvailableAtWeekendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setAvailableAtWeekends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "available", runtime.ParamLocationQuery, params.Available); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDialogStarredRequest generates requests for SetDialogStarred
func NewSetDialogStarredRequest(server string, params *SetDialogStarredParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setDialogStarred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isStarred", runtime.ParamLocationQuery, params.IsStarred); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFavoriteRequest generates requests for SetFavorite
func NewSetFavoriteRequest(server string, params *SetFavoriteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setFavorite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, params.Categories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, params.Attributes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFishingTutorialStatusRequest generates requests for SetFishingTutorialStatus
func NewSetFishingTutorialStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setFishingTutorialStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOrderRatingRequest generates requests for SetOrderRating
func NewSetOrderRatingRequest(server string, params *SetOrderRatingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setOrderRating")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "speed", runtime.ParamLocationQuery, params.Speed); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, params.Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "communication", runtime.ParamLocationQuery, params.Communication); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetTakingOrdersRequest generates requests for SetTakingOrders
func NewSetTakingOrdersRequest(server string, params *SetTakingOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setTakingOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SwitchAll != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "switchAll", runtime.ParamLocationQuery, *params.SwitchAll); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetUserTypeRequest generates requests for SetUserType
func NewSetUserTypeRequest(server string, params *SetUserTypeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setUserType")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVoiceMessageReceivingRequest generates requests for SetVoiceMessageReceiving
func NewSetVoiceMessageReceivingRequest(server string, params *SetVoiceMessageReceivingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setVoiceMessageReceiving")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsAllowed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_allowed", runtime.ParamLocationQuery, *params.IsAllowed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVoiceMessageSpeedRequest generates requests for SetVoiceMessageSpeed
func NewSetVoiceMessageSpeedRequest(server string, params *SetVoiceMessageSpeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setVoiceMessageSpeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Speed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "speed", runtime.ParamLocationQuery, *params.Speed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSignInRequestWithFormdataBody calls the generic SignIn builder with application/x-www-form-urlencoded body
func NewSignInRequestWithFormdataBody(server string, body SignInFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSignInRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSignInRequestWithBody generates requests for SignIn with any type of body
func NewSignInRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/signIn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSignUpRequestWithFormdataBody calls the generic SignUp builder with application/x-www-form-urlencoded body
func NewSignUpRequestWithFormdataBody(server string, body SignUpFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSignUpRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSignUpRequestWithBody generates requests for SignUp with any type of body
func NewSignUpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/signUp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSocialSignInRequestWithFormdataBody calls the generic SocialSignIn builder with application/x-www-form-urlencoded body
func NewSocialSignInRequestWithFormdataBody(server string, body SocialSignInFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSocialSignInRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSocialSignInRequestWithBody generates requests for SocialSignIn with any type of body
func NewSocialSignInRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socialSignIn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSocialSignInByTokenRequestWithFormdataBody calls the generic SocialSignInByToken builder with application/x-www-form-urlencoded body
func NewSocialSignInByTokenRequestWithFormdataBody(server string, body SocialSignInByTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSocialSignInByTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSocialSignInByTokenRequestWithBody generates requests for SocialSignInByToken with any type of body
func NewSocialSignInByTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socialSignInByToken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSocialSignInByTokenv2RequestWithFormdataBody calls the generic SocialSignInByTokenv2 builder with application/x-www-form-urlencoded body
func NewSocialSignInByTokenv2RequestWithFormdataBody(server string, body SocialSignInByTokenv2FormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSocialSignInByTokenv2RequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSocialSignInByTokenv2RequestWithBody generates requests for SocialSignInByTokenv2 with any type of body
func NewSocialSignInByTokenv2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socialSignInByTokenv2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSocialSignUpRequestWithFormdataBody calls the generic SocialSignUp builder with application/x-www-form-urlencoded body
func NewSocialSignUpRequestWithFormdataBody(server string, body SocialSignUpFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSocialSignUpRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSocialSignUpRequestWithBody generates requests for SocialSignUp with any type of body
func NewSocialSignUpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socialSignUp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSocialSignUpByTokenRequestWithFormdataBody calls the generic SocialSignUpByToken builder with application/x-www-form-urlencoded body
func NewSocialSignUpByTokenRequestWithFormdataBody(server string, body SocialSignUpByTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSocialSignUpByTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSocialSignUpByTokenRequestWithBody generates requests for SocialSignUpByToken with any type of body
func NewSocialSignUpByTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socialSignUpByToken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartKworkRequest generates requests for StartKwork
func NewStartKworkRequest(server string, params *StartKworkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startKwork")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kwork_id", runtime.ParamLocationQuery, params.KworkId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopWantRequest generates requests for StopWant
func NewStopWantRequest(server string, params *StopWantParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stopWant")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSuggestStagesRequest generates requests for SuggestStages
func NewSuggestStagesRequest(server string, params *SuggestStagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/suggestStages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, params.Message); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stages", runtime.ParamLocationQuery, params.Stages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTermsRequest generates requests for Terms
func NewTermsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTermsOfServiceRequest generates requests for TermsOfService
func NewTermsOfServiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/termsOfService")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTimezonesRequest generates requests for Timezones
func NewTimezonesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timezones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackDeleteRequest generates requests for TrackDelete
func NewTrackDeleteRequest(server string, params *TrackDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trackDelete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackEditRequestWithFormdataBody calls the generic TrackEdit builder with application/x-www-form-urlencoded body
func NewTrackEditRequestWithFormdataBody(server string, params *TrackEditParams, body TrackEditFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTrackEditRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewTrackEditRequestWithBody generates requests for TrackEdit with any type of body
func NewTrackEditRequestWithBody(server string, params *TrackEditParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trackEdit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UploadedFiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "uploadedFiles", runtime.ParamLocationQuery, *params.UploadedFiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QuoteId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quoteId", runtime.ParamLocationQuery, *params.QuoteId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTrackMessageRequest generates requests for TrackMessage
func NewTrackMessageRequest(server string, params *TrackMessageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trackMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrackReadRequest generates requests for TrackRead
func NewTrackReadRequest(server string, params *TrackReadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trackRead")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTranslationLanguagesRequest generates requests for TranslationLanguages
func NewTranslationLanguagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/translationLanguages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTypingRequest generates requests for Typing
func NewTypingRequest(server string, params *TypingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/typing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recipientId", runtime.ParamLocationQuery, params.RecipientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveDialogRequest generates requests for UnarchiveDialog
func NewUnarchiveDialogRequest(server string, params *UnarchiveDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unarchiveDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveUserId", runtime.ParamLocationQuery, params.ArchiveUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnblockDialogRequest generates requests for UnblockDialog
func NewUnblockDialogRequest(server string, params *UnblockDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unblockDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockUserId", runtime.ParamLocationQuery, params.BlockUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnreadDialogRequest generates requests for UnreadDialog
func NewUnreadDialogRequest(server string, params *UnreadDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unreadDialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAvatarRequestWithBody generates requests for UpdateAvatar with any type of body
func NewUpdateAvatarRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updateAvatar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateChatDraftMessageRequest generates requests for UpdateChatDraftMessage
func NewUpdateChatDraftMessageRequest(server string, params *UpdateChatDraftMessageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updateChatDraftMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files[]", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrderDraftMessageRequest generates requests for UpdateOrderDraftMessage
func NewUpdateOrderDraftMessageRequest(server string, params *UpdateOrderDraftMessageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updateOrderDraftMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderId", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Message != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files[]", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSettingsRequestWithBody generates requests for UpdateSettings with any type of body
func NewUpdateSettingsRequestWithBody(server string, params *UpdateSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updateSettings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fullname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fullname", runtime.ParamLocationQuery, *params.Fullname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneId", runtime.ParamLocationQuery, *params.TimezoneId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Details != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, *params.Details); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvatarPhotoSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "avatarPhotoSize", runtime.ParamLocationQuery, *params.AvatarPhotoSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CountryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryId", runtime.ParamLocationQuery, *params.CountryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cityId", runtime.ParamLocationQuery, *params.CityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profession", runtime.ParamLocationQuery, *params.Profession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkHoursFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workHoursFrom", runtime.ParamLocationQuery, *params.WorkHoursFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkHoursTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workHoursTo", runtime.ParamLocationQuery, *params.WorkHoursTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateStageProgressRequest generates requests for UpdateStageProgress
func NewUpdateStageProgressRequest(server string, params *UpdateStageProgressParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updateStageProgress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stages", runtime.ParamLocationQuery, params.Stages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment", runtime.ParamLocationQuery, params.Comment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics[]", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrackId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trackId", runtime.ParamLocationQuery, *params.TrackId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCoverRequestWithBody generates requests for UploadCover with any type of body
func NewUploadCoverRequestWithBody(server string, params *UploadCoverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploadCover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CoverSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "coverSize", runtime.ParamLocationQuery, *params.CoverSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadLogRequestWithBody generates requests for UploadLog with any type of body
func NewUploadLogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploadLog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPortfolioFileRequestWithBody generates requests for UploadPortfolioFile with any type of body
func NewUploadPortfolioFileRequestWithBody(server string, params *UploadPortfolioFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploadPortfolioFile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Hashes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hashes[]", runtime.ParamLocationQuery, *params.Hashes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadedFileRequest generates requests for UploadedFile
func NewUploadedFileRequest(server string, params *UploadedFileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploadedFile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserRequest generates requests for User
func NewUserRequest(server string, params *UserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WithHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hidden", runtime.ParamLocationQuery, *params.WithHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserByUsernameRequest generates requests for UserByUsername
func NewUserByUsernameRequest(server string, params *UserByUsernameParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userByUsername")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WithHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_hidden", runtime.ParamLocationQuery, *params.WithHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserKworksRequest generates requests for UserKworks
func NewUserKworksRequest(server string, params *UserKworksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userKworks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status_id", runtime.ParamLocationQuery, *params.StatusId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserReviewsRequest generates requests for UserReviews
func NewUserReviewsRequest(server string, params *UserReviewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userReviews")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSearchRequest generates requests for UserSearch
func NewUserSearchRequest(server string, params *UserSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userSearch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyPhoneActivationCodeRequest generates requests for VerifyPhoneActivationCode
func NewVerifyPhoneActivationCodeRequest(server string, params *VerifyPhoneActivationCodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/verifyPhoneActivationCode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifySmsCodeForAccountDeletingRequest generates requests for VerifySmsCodeForAccountDeleting
func NewVerifySmsCodeForAccountDeletingRequest(server string, params *VerifySmsCodeForAccountDeletingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/verifySmsCodeForAccountDeleting")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewViewedCatalogKworksRequest generates requests for ViewedCatalogKworks
func NewViewedCatalogKworksRequest(server string, params *ViewedCatalogKworksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/viewedCatalogKworks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVoiceUploadRequestWithBody generates requests for VoiceUpload with any type of body
func NewVoiceUploadRequestWithBody(server string, params *VoiceUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voiceUpload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.VoicePeaks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voice_peaks", runtime.ParamLocationQuery, *params.VoicePeaks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWantRequest generates requests for Want
func NewWantRequest(server string, params *WantParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/want")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWantsStatusListRequest generates requests for WantsStatusList
func NewWantsStatusListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wantsStatusList")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerConfirmsExtraRemovalRequestRequest generates requests for WorkerConfirmsExtraRemovalRequest
func NewWorkerConfirmsExtraRemovalRequestRequest(server string, params *WorkerConfirmsExtraRemovalRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workerConfirmsExtraRemovalRequest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, params.TrackId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerDeclineExtrasRequest generates requests for WorkerDeclineExtras
func NewWorkerDeclineExtrasRequest(server string, params *WorkerDeclineExtrasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workerDeclineExtras")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, params.TrackId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerDeclinesExtraRemovalRequestRequest generates requests for WorkerDeclinesExtraRemovalRequest
func NewWorkerDeclinesExtraRemovalRequestRequest(server string, params *WorkerDeclinesExtraRemovalRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workerDeclinesExtraRemovalRequest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "track_id", runtime.ParamLocationQuery, params.TrackId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerExtraDeleteRequest generates requests for WorkerExtraDelete
func NewWorkerExtraDeleteRequest(server string, params *WorkerExtraDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workerExtraDelete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extra_id", runtime.ParamLocationQuery, params.ExtraId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerInprogressRequest generates requests for WorkerInprogress
func NewWorkerInprogressRequest(server string, params *WorkerInprogressParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workerInprogress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ContractsAgreement != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contracts_agreement", runtime.ParamLocationQuery, *params.ContractsAgreement); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerOrdersRequest generates requests for WorkerOrders
func NewWorkerOrdersRequest(server string, params *WorkerOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workerOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AcceptExtrasWithResponse request
	AcceptExtrasWithResponse(ctx context.Context, params *AcceptExtrasParams, reqEditors ...RequestEditorFn) (*AcceptExtrasResponse, error)

	// AcceptStageSuggestionWithResponse request
	AcceptStageSuggestionWithResponse(ctx context.Context, params *AcceptStageSuggestionParams, reqEditors ...RequestEditorFn) (*AcceptStageSuggestionResponse, error)

	// ActorWithBodyWithResponse request with any body
	ActorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActorResponse, error)

	ActorWithFormdataBodyWithResponse(ctx context.Context, body ActorFormdataRequestBody, reqEditors ...RequestEditorFn) (*ActorResponse, error)

	// AddFavoriteCategoriesWithResponse request
	AddFavoriteCategoriesWithResponse(ctx context.Context, params *AddFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*AddFavoriteCategoriesResponse, error)

	// AddNewPhoneNumberWithResponse request
	AddNewPhoneNumberWithResponse(ctx context.Context, params *AddNewPhoneNumberParams, reqEditors ...RequestEditorFn) (*AddNewPhoneNumberResponse, error)

	// AddPhoneNumberWithResponse request
	AddPhoneNumberWithResponse(ctx context.Context, params *AddPhoneNumberParams, reqEditors ...RequestEditorFn) (*AddPhoneNumberResponse, error)

	// AddStageWithResponse request
	AddStageWithResponse(ctx context.Context, params *AddStageParams, reqEditors ...RequestEditorFn) (*AddStageResponse, error)

	// AllowInboxRequestWithResponse request
	AllowInboxRequestWithResponse(ctx context.Context, params *AllowInboxRequestParams, reqEditors ...RequestEditorFn) (*AllowInboxRequestResponse, error)

	// AllowMobilePushWithResponse request
	AllowMobilePushWithResponse(ctx context.Context, params *AllowMobilePushParams, reqEditors ...RequestEditorFn) (*AllowMobilePushResponse, error)

	// AllowOrderPortfolioUploadWithResponse request
	AllowOrderPortfolioUploadWithResponse(ctx context.Context, params *AllowOrderPortfolioUploadParams, reqEditors ...RequestEditorFn) (*AllowOrderPortfolioUploadResponse, error)

	// AllowPushNotificationsSoundWithResponse request
	AllowPushNotificationsSoundWithResponse(ctx context.Context, params *AllowPushNotificationsSoundParams, reqEditors ...RequestEditorFn) (*AllowPushNotificationsSoundResponse, error)

	// AppleSignInWithBodyWithResponse request with any body
	AppleSignInWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppleSignInResponse, error)

	AppleSignInWithFormdataBodyWithResponse(ctx context.Context, body AppleSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*AppleSignInResponse, error)

	// ApplyFiltersWithResponse request
	ApplyFiltersWithResponse(ctx context.Context, params *ApplyFiltersParams, reqEditors ...RequestEditorFn) (*ApplyFiltersResponse, error)

	// ApproveOrderWithResponse request
	ApproveOrderWithResponse(ctx context.Context, params *ApproveOrderParams, reqEditors ...RequestEditorFn) (*ApproveOrderResponse, error)

	// ApproveOrderStageWithResponse request
	ApproveOrderStageWithResponse(ctx context.Context, params *ApproveOrderStageParams, reqEditors ...RequestEditorFn) (*ApproveOrderStageResponse, error)

	// ArchiveDialogWithResponse request
	ArchiveDialogWithResponse(ctx context.Context, params *ArchiveDialogParams, reqEditors ...RequestEditorFn) (*ArchiveDialogResponse, error)

	// BlockDialogWithResponse request
	BlockDialogWithResponse(ctx context.Context, params *BlockDialogParams, reqEditors ...RequestEditorFn) (*BlockDialogResponse, error)

	// BlockedDialogListWithResponse request
	BlockedDialogListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedDialogListResponse, error)

	// CancelOrderAwaitingPaymentWithResponse request
	CancelOrderAwaitingPaymentWithResponse(ctx context.Context, params *CancelOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*CancelOrderAwaitingPaymentResponse, error)

	// CancelOrderByPayerWithBodyWithResponse request with any body
	CancelOrderByPayerWithBodyWithResponse(ctx context.Context, params *CancelOrderByPayerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelOrderByPayerResponse, error)

	CancelOrderByPayerWithFormdataBodyWithResponse(ctx context.Context, params *CancelOrderByPayerParams, body CancelOrderByPayerFormdataRequestBody, reqEditors ...RequestEditorFn) (*CancelOrderByPayerResponse, error)

	// CancelOrderByWorkerWithBodyWithResponse request with any body
	CancelOrderByWorkerWithBodyWithResponse(ctx context.Context, params *CancelOrderByWorkerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelOrderByWorkerResponse, error)

	CancelOrderByWorkerWithFormdataBodyWithResponse(ctx context.Context, params *CancelOrderByWorkerParams, body CancelOrderByWorkerFormdataRequestBody, reqEditors ...RequestEditorFn) (*CancelOrderByWorkerResponse, error)

	// CatalogCategoriesWithResponse request
	CatalogCategoriesWithResponse(ctx context.Context, params *CatalogCategoriesParams, reqEditors ...RequestEditorFn) (*CatalogCategoriesResponse, error)

	// CatalogFiltersWithResponse request
	CatalogFiltersWithResponse(ctx context.Context, params *CatalogFiltersParams, reqEditors ...RequestEditorFn) (*CatalogFiltersResponse, error)

	// CatalogMainWithResponse request
	CatalogMainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CatalogMainResponse, error)

	// CatalogMainv2WithResponse request
	CatalogMainv2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CatalogMainv2Response, error)

	// CatalogRubricsWithResponse request
	CatalogRubricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CatalogRubricsResponse, error)

	// CategoriesWithResponse request
	CategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CategoriesResponse, error)

	// CategoryWithResponse request
	CategoryWithResponse(ctx context.Context, params *CategoryParams, reqEditors ...RequestEditorFn) (*CategoryResponse, error)

	// CategoryAttributesWithResponse request
	CategoryAttributesWithResponse(ctx context.Context, params *CategoryAttributesParams, reqEditors ...RequestEditorFn) (*CategoryAttributesResponse, error)

	// ChangePasswordWithBodyWithResponse request with any body
	ChangePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error)

	ChangePasswordWithFormdataBodyWithResponse(ctx context.Context, body ChangePasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error)

	// ChangePayerSubRoleWithResponse request
	ChangePayerSubRoleWithResponse(ctx context.Context, params *ChangePayerSubRoleParams, reqEditors ...RequestEditorFn) (*ChangePayerSubRoleResponse, error)

	// ChangeUsernameWithBodyWithResponse request with any body
	ChangeUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeUsernameResponse, error)

	ChangeUsernameWithFormdataBodyWithResponse(ctx context.Context, body ChangeUsernameFormdataRequestBody, reqEditors ...RequestEditorFn) (*ChangeUsernameResponse, error)

	// CheckLoginWithBodyWithResponse request with any body
	CheckLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckLoginResponse, error)

	CheckLoginWithFormdataBodyWithResponse(ctx context.Context, body CheckLoginFormdataRequestBody, reqEditors ...RequestEditorFn) (*CheckLoginResponse, error)

	// CitiesWithResponse request
	CitiesWithResponse(ctx context.Context, params *CitiesParams, reqEditors ...RequestEditorFn) (*CitiesResponse, error)

	// ClearFiltersWithResponse request
	ClearFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearFiltersResponse, error)

	// ConfirmCancelOrderRequestByPayerWithResponse request
	ConfirmCancelOrderRequestByPayerWithResponse(ctx context.Context, params *ConfirmCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*ConfirmCancelOrderRequestByPayerResponse, error)

	// ConfirmCancelOrderRequestByWorkerWithResponse request
	ConfirmCancelOrderRequestByWorkerWithResponse(ctx context.Context, params *ConfirmCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*ConfirmCancelOrderRequestByWorkerResponse, error)

	// CountriesWithResponse request
	CountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountriesResponse, error)

	// CreateAnswerWithBodyWithResponse request with any body
	CreateAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnswerResponse, error)

	CreateAnswerWithFormdataBodyWithResponse(ctx context.Context, body CreateAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateAnswerResponse, error)

	// CreateKworkComplainWithBodyWithResponse request with any body
	CreateKworkComplainWithBodyWithResponse(ctx context.Context, params *CreateKworkComplainParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKworkComplainResponse, error)

	CreateKworkComplainWithFormdataBodyWithResponse(ctx context.Context, params *CreateKworkComplainParams, body CreateKworkComplainFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateKworkComplainResponse, error)

	// CreatePortfolioWithResponse request
	CreatePortfolioWithResponse(ctx context.Context, params *CreatePortfolioParams, reqEditors ...RequestEditorFn) (*CreatePortfolioResponse, error)

	// CreateReviewWithBodyWithResponse request with any body
	CreateReviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error)

	CreateReviewWithFormdataBodyWithResponse(ctx context.Context, body CreateReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error)

	// CreateStageWithResponse request
	CreateStageWithResponse(ctx context.Context, params *CreateStageParams, reqEditors ...RequestEditorFn) (*CreateStageResponse, error)

	// DelFavoriteCategoriesWithResponse request
	DelFavoriteCategoriesWithResponse(ctx context.Context, params *DelFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*DelFavoriteCategoriesResponse, error)

	// DeleteAccountWithResponse request
	DeleteAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error)

	// DeleteCancelOrderRequestByPayerWithResponse request
	DeleteCancelOrderRequestByPayerWithResponse(ctx context.Context, params *DeleteCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*DeleteCancelOrderRequestByPayerResponse, error)

	// DeleteCancelOrderRequestByWorkerWithResponse request
	DeleteCancelOrderRequestByWorkerWithResponse(ctx context.Context, params *DeleteCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*DeleteCancelOrderRequestByWorkerResponse, error)

	// DeleteCoverWithResponse request
	DeleteCoverWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCoverResponse, error)

	// DeleteKworkWithResponse request
	DeleteKworkWithResponse(ctx context.Context, params *DeleteKworkParams, reqEditors ...RequestEditorFn) (*DeleteKworkResponse, error)

	// DeleteOfferWithResponse request
	DeleteOfferWithResponse(ctx context.Context, params *DeleteOfferParams, reqEditors ...RequestEditorFn) (*DeleteOfferResponse, error)

	// DeleteOrderNoteWithResponse request
	DeleteOrderNoteWithResponse(ctx context.Context, params *DeleteOrderNoteParams, reqEditors ...RequestEditorFn) (*DeleteOrderNoteResponse, error)

	// DeletePortfolioWithResponse request
	DeletePortfolioWithResponse(ctx context.Context, params *DeletePortfolioParams, reqEditors ...RequestEditorFn) (*DeletePortfolioResponse, error)

	// DeleteReviewWithResponse request
	DeleteReviewWithResponse(ctx context.Context, params *DeleteReviewParams, reqEditors ...RequestEditorFn) (*DeleteReviewResponse, error)

	// DeleteStageWithResponse request
	DeleteStageWithResponse(ctx context.Context, params *DeleteStageParams, reqEditors ...RequestEditorFn) (*DeleteStageResponse, error)

	// DeleteUserNoteWithResponse request
	DeleteUserNoteWithResponse(ctx context.Context, params *DeleteUserNoteParams, reqEditors ...RequestEditorFn) (*DeleteUserNoteResponse, error)

	// DeleteWantWithResponse request
	DeleteWantWithResponse(ctx context.Context, params *DeleteWantParams, reqEditors ...RequestEditorFn) (*DeleteWantResponse, error)

	// DialogsWithResponse request
	DialogsWithResponse(ctx context.Context, params *DialogsParams, reqEditors ...RequestEditorFn) (*DialogsResponse, error)

	// EditAnswerWithBodyWithResponse request with any body
	EditAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAnswerResponse, error)

	EditAnswerWithFormdataBodyWithResponse(ctx context.Context, body EditAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*EditAnswerResponse, error)

	// EditPortfolioWithResponse request
	EditPortfolioWithResponse(ctx context.Context, params *EditPortfolioParams, reqEditors ...RequestEditorFn) (*EditPortfolioResponse, error)

	// EditReviewWithBodyWithResponse request with any body
	EditReviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditReviewResponse, error)

	EditReviewWithFormdataBodyWithResponse(ctx context.Context, body EditReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*EditReviewResponse, error)

	// EditStageWithResponse request
	EditStageWithResponse(ctx context.Context, params *EditStageParams, reqEditors ...RequestEditorFn) (*EditStageResponse, error)

	// EmailVerificationLetterWithResponse request
	EmailVerificationLetterWithResponse(ctx context.Context, params *EmailVerificationLetterParams, reqEditors ...RequestEditorFn) (*EmailVerificationLetterResponse, error)

	// ExchangeInfoWithResponse request
	ExchangeInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExchangeInfoResponse, error)

	// FavoriteCategoriesWithResponse request
	FavoriteCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FavoriteCategoriesResponse, error)

	// FavoriteKworksWithResponse request
	FavoriteKworksWithResponse(ctx context.Context, params *FavoriteKworksParams, reqEditors ...RequestEditorFn) (*FavoriteKworksResponse, error)

	// FcmNotificationsReadWithResponse request
	FcmNotificationsReadWithResponse(ctx context.Context, params *FcmNotificationsReadParams, reqEditors ...RequestEditorFn) (*FcmNotificationsReadResponse, error)

	// FcmNotificationsReceivedWithResponse request
	FcmNotificationsReceivedWithResponse(ctx context.Context, params *FcmNotificationsReceivedParams, reqEditors ...RequestEditorFn) (*FcmNotificationsReceivedResponse, error)

	// FcmTokenRequestFailedWithResponse request
	FcmTokenRequestFailedWithResponse(ctx context.Context, params *FcmTokenRequestFailedParams, reqEditors ...RequestEditorFn) (*FcmTokenRequestFailedResponse, error)

	// FileDeleteWithResponse request
	FileDeleteWithResponse(ctx context.Context, params *FileDeleteParams, reqEditors ...RequestEditorFn) (*FileDeleteResponse, error)

	// FileUploadWithBodyWithResponse request with any body
	FileUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResponse, error)

	// GetActorInfoWithBodyWithResponse request with any body
	GetActorInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetActorInfoResponse, error)

	GetActorInfoWithFormdataBodyWithResponse(ctx context.Context, body GetActorInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetActorInfoResponse, error)

	// GetArbitrationReasonsWithResponse request
	GetArbitrationReasonsWithResponse(ctx context.Context, params *GetArbitrationReasonsParams, reqEditors ...RequestEditorFn) (*GetArbitrationReasonsResponse, error)

	// GetAvailableFeaturesWithResponse request
	GetAvailableFeaturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableFeaturesResponse, error)

	// GetBadgesInfoWithBodyWithResponse request with any body
	GetBadgesInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBadgesInfoResponse, error)

	GetBadgesInfoWithFormdataBodyWithResponse(ctx context.Context, body GetBadgesInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetBadgesInfoResponse, error)

	// GetBillRefillUrlWithResponse request
	GetBillRefillUrlWithResponse(ctx context.Context, params *GetBillRefillUrlParams, reqEditors ...RequestEditorFn) (*GetBillRefillUrlResponse, error)

	// GetCaptchaStatusWithResponse request
	GetCaptchaStatusWithResponse(ctx context.Context, params *GetCaptchaStatusParams, reqEditors ...RequestEditorFn) (*GetCaptchaStatusResponse, error)

	// GetChannelWithResponse request
	GetChannelWithResponse(ctx context.Context, params *GetChannelParams, reqEditors ...RequestEditorFn) (*GetChannelResponse, error)

	// GetCompanyDetailsWithResponse request
	GetCompanyDetailsWithResponse(ctx context.Context, params *GetCompanyDetailsParams, reqEditors ...RequestEditorFn) (*GetCompanyDetailsResponse, error)

	// GetComplainCategoriesWithResponse request
	GetComplainCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetComplainCategoriesResponse, error)

	// GetCookieWithResponse request
	GetCookieWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCookieResponse, error)

	// GetCurrentVersionsWithResponse request
	GetCurrentVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentVersionsResponse, error)

	// GetCustomOptionsPresetsWithResponse request
	GetCustomOptionsPresetsWithResponse(ctx context.Context, params *GetCustomOptionsPresetsParams, reqEditors ...RequestEditorFn) (*GetCustomOptionsPresetsResponse, error)

	// GetDialogWithResponse request
	GetDialogWithResponse(ctx context.Context, params *GetDialogParams, reqEditors ...RequestEditorFn) (*GetDialogResponse, error)

	// GetExtrasAvailableForOrderWithResponse request
	GetExtrasAvailableForOrderWithResponse(ctx context.Context, params *GetExtrasAvailableForOrderParams, reqEditors ...RequestEditorFn) (*GetExtrasAvailableForOrderResponse, error)

	// GetFishingTutorialQuestionsWithResponse request
	GetFishingTutorialQuestionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFishingTutorialQuestionsResponse, error)

	// GetHiddenKworksWithResponse request
	GetHiddenKworksWithResponse(ctx context.Context, params *GetHiddenKworksParams, reqEditors ...RequestEditorFn) (*GetHiddenKworksResponse, error)

	// GetInboxTracksWithResponse request
	GetInboxTracksWithResponse(ctx context.Context, params *GetInboxTracksParams, reqEditors ...RequestEditorFn) (*GetInboxTracksResponse, error)

	// GetKworkAnswersWithResponse request
	GetKworkAnswersWithResponse(ctx context.Context, params *GetKworkAnswersParams, reqEditors ...RequestEditorFn) (*GetKworkAnswersResponse, error)

	// GetKworkDetailsWithResponse request
	GetKworkDetailsWithResponse(ctx context.Context, params *GetKworkDetailsParams, reqEditors ...RequestEditorFn) (*GetKworkDetailsResponse, error)

	// GetKworkDetailsExtraWithResponse request
	GetKworkDetailsExtraWithResponse(ctx context.Context, params *GetKworkDetailsExtraParams, reqEditors ...RequestEditorFn) (*GetKworkDetailsExtraResponse, error)

	// GetKworkLinksTableWithResponse request
	GetKworkLinksTableWithResponse(ctx context.Context, params *GetKworkLinksTableParams, reqEditors ...RequestEditorFn) (*GetKworkLinksTableResponse, error)

	// GetKworkLinksTablev2WithResponse request
	GetKworkLinksTablev2WithResponse(ctx context.Context, params *GetKworkLinksTablev2Params, reqEditors ...RequestEditorFn) (*GetKworkLinksTablev2Response, error)

	// GetKworkPortfoliosWithResponse request
	GetKworkPortfoliosWithResponse(ctx context.Context, params *GetKworkPortfoliosParams, reqEditors ...RequestEditorFn) (*GetKworkPortfoliosResponse, error)

	// GetKworkReviewsWithResponse request
	GetKworkReviewsWithResponse(ctx context.Context, params *GetKworkReviewsParams, reqEditors ...RequestEditorFn) (*GetKworkReviewsResponse, error)

	// GetOrderCancellationReasonsWithResponse request
	GetOrderCancellationReasonsWithResponse(ctx context.Context, params *GetOrderCancellationReasonsParams, reqEditors ...RequestEditorFn) (*GetOrderCancellationReasonsResponse, error)

	// GetOrderDetailsWithResponse request
	GetOrderDetailsWithResponse(ctx context.Context, params *GetOrderDetailsParams, reqEditors ...RequestEditorFn) (*GetOrderDetailsResponse, error)

	// GetOrderFilesWithResponse request
	GetOrderFilesWithResponse(ctx context.Context, params *GetOrderFilesParams, reqEditors ...RequestEditorFn) (*GetOrderFilesResponse, error)

	// GetOrderHeaderWithResponse request
	GetOrderHeaderWithResponse(ctx context.Context, params *GetOrderHeaderParams, reqEditors ...RequestEditorFn) (*GetOrderHeaderResponse, error)

	// GetOrderProvidedDataWithResponse request
	GetOrderProvidedDataWithResponse(ctx context.Context, params *GetOrderProvidedDataParams, reqEditors ...RequestEditorFn) (*GetOrderProvidedDataResponse, error)

	// GetOrderedExtrasWithResponse request
	GetOrderedExtrasWithResponse(ctx context.Context, params *GetOrderedExtrasParams, reqEditors ...RequestEditorFn) (*GetOrderedExtrasResponse, error)

	// GetPayerCompanyModalUrlWithResponse request
	GetPayerCompanyModalUrlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPayerCompanyModalUrlResponse, error)

	// GetPaymentMethodsWithResponse request
	GetPaymentMethodsWithResponse(ctx context.Context, params *GetPaymentMethodsParams, reqEditors ...RequestEditorFn) (*GetPaymentMethodsResponse, error)

	// GetSecurityUserDataWithResponse request
	GetSecurityUserDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecurityUserDataResponse, error)

	// GetSubscribersStatisticsWithResponse request
	GetSubscribersStatisticsWithResponse(ctx context.Context, params *GetSubscribersStatisticsParams, reqEditors ...RequestEditorFn) (*GetSubscribersStatisticsResponse, error)

	// GetTracksWithResponse request
	GetTracksWithResponse(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*GetTracksResponse, error)

	// GetUserInfoWithResponse request
	GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error)

	// GetUsersLastOrderInfoWithResponse request
	GetUsersLastOrderInfoWithResponse(ctx context.Context, params *GetUsersLastOrderInfoParams, reqEditors ...RequestEditorFn) (*GetUsersLastOrderInfoResponse, error)

	// GetVoiceMessageConvertStatusWithResponse request
	GetVoiceMessageConvertStatusWithResponse(ctx context.Context, params *GetVoiceMessageConvertStatusParams, reqEditors ...RequestEditorFn) (*GetVoiceMessageConvertStatusResponse, error)

	// GetVoiceMessageTranscriptionWithResponse request
	GetVoiceMessageTranscriptionWithResponse(ctx context.Context, params *GetVoiceMessageTranscriptionParams, reqEditors ...RequestEditorFn) (*GetVoiceMessageTranscriptionResponse, error)

	// GetWantsCountWithResponse request
	GetWantsCountWithResponse(ctx context.Context, params *GetWantsCountParams, reqEditors ...RequestEditorFn) (*GetWantsCountResponse, error)

	// GetWebAuthTokenWithResponse request
	GetWebAuthTokenWithResponse(ctx context.Context, params *GetWebAuthTokenParams, reqEditors ...RequestEditorFn) (*GetWebAuthTokenResponse, error)

	// HideDialogWithResponse request
	HideDialogWithResponse(ctx context.Context, params *HideDialogParams, reqEditors ...RequestEditorFn) (*HideDialogResponse, error)

	// HideSelfEmployedNotificationWithResponse request
	HideSelfEmployedNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HideSelfEmployedNotificationResponse, error)

	// HideVoiceMessageSettingsPopupWithResponse request
	HideVoiceMessageSettingsPopupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HideVoiceMessageSettingsPopupResponse, error)

	// InboxComplainMessageWithBodyWithResponse request with any body
	InboxComplainMessageWithBodyWithResponse(ctx context.Context, params *InboxComplainMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InboxComplainMessageResponse, error)

	InboxComplainMessageWithFormdataBodyWithResponse(ctx context.Context, params *InboxComplainMessageParams, body InboxComplainMessageFormdataRequestBody, reqEditors ...RequestEditorFn) (*InboxComplainMessageResponse, error)

	// InboxCreateWithBodyWithResponse request with any body
	InboxCreateWithBodyWithResponse(ctx context.Context, params *InboxCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InboxCreateResponse, error)

	InboxCreateWithFormdataBodyWithResponse(ctx context.Context, params *InboxCreateParams, body InboxCreateFormdataRequestBody, reqEditors ...RequestEditorFn) (*InboxCreateResponse, error)

	// InboxCustomRequestDeclineWithResponse request
	InboxCustomRequestDeclineWithResponse(ctx context.Context, params *InboxCustomRequestDeclineParams, reqEditors ...RequestEditorFn) (*InboxCustomRequestDeclineResponse, error)

	// InboxDeleteWithResponse request
	InboxDeleteWithResponse(ctx context.Context, params *InboxDeleteParams, reqEditors ...RequestEditorFn) (*InboxDeleteResponse, error)

	// InboxEditWithBodyWithResponse request with any body
	InboxEditWithBodyWithResponse(ctx context.Context, params *InboxEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InboxEditResponse, error)

	InboxEditWithFormdataBodyWithResponse(ctx context.Context, params *InboxEditParams, body InboxEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*InboxEditResponse, error)

	// InboxForwardWithResponse request
	InboxForwardWithResponse(ctx context.Context, params *InboxForwardParams, reqEditors ...RequestEditorFn) (*InboxForwardResponse, error)

	// InboxMessageWithResponse request
	InboxMessageWithResponse(ctx context.Context, params *InboxMessageParams, reqEditors ...RequestEditorFn) (*InboxMessageResponse, error)

	// InboxPayerDeclineWithResponse request
	InboxPayerDeclineWithResponse(ctx context.Context, params *InboxPayerDeclineParams, reqEditors ...RequestEditorFn) (*InboxPayerDeclineResponse, error)

	// InboxReadWithResponse request
	InboxReadWithResponse(ctx context.Context, params *InboxReadParams, reqEditors ...RequestEditorFn) (*InboxReadResponse, error)

	// InboxTrackMessageWithResponse request
	InboxTrackMessageWithResponse(ctx context.Context, params *InboxTrackMessageParams, reqEditors ...RequestEditorFn) (*InboxTrackMessageResponse, error)

	// InboxWorkerDeclineWithResponse request
	InboxWorkerDeclineWithResponse(ctx context.Context, params *InboxWorkerDeclineParams, reqEditors ...RequestEditorFn) (*InboxWorkerDeclineResponse, error)

	// InboxesWithResponse request
	InboxesWithResponse(ctx context.Context, params *InboxesParams, reqEditors ...RequestEditorFn) (*InboxesResponse, error)

	// IsDialogAllowWithResponse request
	IsDialogAllowWithResponse(ctx context.Context, params *IsDialogAllowParams, reqEditors ...RequestEditorFn) (*IsDialogAllowResponse, error)

	// KworksWithResponse request
	KworksWithResponse(ctx context.Context, params *KworksParams, reqEditors ...RequestEditorFn) (*KworksResponse, error)

	// KworksCategoriesListWithResponse request
	KworksCategoriesListWithResponse(ctx context.Context, params *KworksCategoriesListParams, reqEditors ...RequestEditorFn) (*KworksCategoriesListResponse, error)

	// KworksStatusListWithResponse request
	KworksStatusListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*KworksStatusListResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// MarkInboxTracksAsReadWithResponse request
	MarkInboxTracksAsReadWithResponse(ctx context.Context, params *MarkInboxTracksAsReadParams, reqEditors ...RequestEditorFn) (*MarkInboxTracksAsReadResponse, error)

	// MarkKworkAsFavoriteWithResponse request
	MarkKworkAsFavoriteWithResponse(ctx context.Context, params *MarkKworkAsFavoriteParams, reqEditors ...RequestEditorFn) (*MarkKworkAsFavoriteResponse, error)

	// MarkKworkAsHiddenWithResponse request
	MarkKworkAsHiddenWithResponse(ctx context.Context, params *MarkKworkAsHiddenParams, reqEditors ...RequestEditorFn) (*MarkKworkAsHiddenResponse, error)

	// MarkKworksBlackFridayWithResponse request
	MarkKworksBlackFridayWithResponse(ctx context.Context, params *MarkKworksBlackFridayParams, reqEditors ...RequestEditorFn) (*MarkKworksBlackFridayResponse, error)

	// MarkVoiceMessageHeardWithResponse request
	MarkVoiceMessageHeardWithResponse(ctx context.Context, params *MarkVoiceMessageHeardParams, reqEditors ...RequestEditorFn) (*MarkVoiceMessageHeardResponse, error)

	// MiniatureWithResponse request
	MiniatureWithResponse(ctx context.Context, params *MiniatureParams, reqEditors ...RequestEditorFn) (*MiniatureResponse, error)

	// MyWantsWithResponse request
	MyWantsWithResponse(ctx context.Context, params *MyWantsParams, reqEditors ...RequestEditorFn) (*MyWantsResponse, error)

	// NotificationsWithResponse request
	NotificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*NotificationsResponse, error)

	// NotificationsFetchWithResponse request
	NotificationsFetchWithResponse(ctx context.Context, params *NotificationsFetchParams, reqEditors ...RequestEditorFn) (*NotificationsFetchResponse, error)

	// NotificationsReceivedWithResponse request
	NotificationsReceivedWithResponse(ctx context.Context, params *NotificationsReceivedParams, reqEditors ...RequestEditorFn) (*NotificationsReceivedResponse, error)

	// OfferWithResponse request
	OfferWithResponse(ctx context.Context, params *OfferParams, reqEditors ...RequestEditorFn) (*OfferResponse, error)

	// OfferOrderOptionsWithResponse request
	OfferOrderOptionsWithResponse(ctx context.Context, params *OfferOrderOptionsParams, reqEditors ...RequestEditorFn) (*OfferOrderOptionsResponse, error)

	// OffersWithResponse request
	OffersWithResponse(ctx context.Context, params *OffersParams, reqEditors ...RequestEditorFn) (*OffersResponse, error)

	// OfflineWithResponse request
	OfflineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OfflineResponse, error)

	// OrderWithResponse request
	OrderWithResponse(ctx context.Context, params *OrderParams, reqEditors ...RequestEditorFn) (*OrderResponse, error)

	// OrderKworkWithResponse request
	OrderKworkWithResponse(ctx context.Context, params *OrderKworkParams, reqEditors ...RequestEditorFn) (*OrderKworkResponse, error)

	// OrderStageWithResponse request
	OrderStageWithResponse(ctx context.Context, params *OrderStageParams, reqEditors ...RequestEditorFn) (*OrderStageResponse, error)

	// OrdersBetweenWithResponse request
	OrdersBetweenWithResponse(ctx context.Context, params *OrdersBetweenParams, reqEditors ...RequestEditorFn) (*OrdersBetweenResponse, error)

	// PauseKworkWithResponse request
	PauseKworkWithResponse(ctx context.Context, params *PauseKworkParams, reqEditors ...RequestEditorFn) (*PauseKworkResponse, error)

	// PayOrderAwaitingPaymentWithResponse request
	PayOrderAwaitingPaymentWithResponse(ctx context.Context, params *PayOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*PayOrderAwaitingPaymentResponse, error)

	// PayerBuyExtrasWithResponse request
	PayerBuyExtrasWithResponse(ctx context.Context, params *PayerBuyExtrasParams, reqEditors ...RequestEditorFn) (*PayerBuyExtrasResponse, error)

	// PayerDeclineExtrasWithResponse request
	PayerDeclineExtrasWithResponse(ctx context.Context, params *PayerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*PayerDeclineExtrasResponse, error)

	// PayerDeclinesExtraRemovalRequestWithResponse request
	PayerDeclinesExtraRemovalRequestWithResponse(ctx context.Context, params *PayerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*PayerDeclinesExtraRemovalRequestResponse, error)

	// PayerExtraDeleteWithResponse request
	PayerExtraDeleteWithResponse(ctx context.Context, params *PayerExtraDeleteParams, reqEditors ...RequestEditorFn) (*PayerExtraDeleteResponse, error)

	// PayerOrdersWithResponse request
	PayerOrdersWithResponse(ctx context.Context, params *PayerOrdersParams, reqEditors ...RequestEditorFn) (*PayerOrdersResponse, error)

	// PayerUpgradePackageWithResponse request
	PayerUpgradePackageWithResponse(ctx context.Context, params *PayerUpgradePackageParams, reqEditors ...RequestEditorFn) (*PayerUpgradePackageResponse, error)

	// PortfolioCategoriesListWithResponse request
	PortfolioCategoriesListWithResponse(ctx context.Context, params *PortfolioCategoriesListParams, reqEditors ...RequestEditorFn) (*PortfolioCategoriesListResponse, error)

	// PortfolioListWithResponse request
	PortfolioListWithResponse(ctx context.Context, params *PortfolioListParams, reqEditors ...RequestEditorFn) (*PortfolioListResponse, error)

	// PositiveReviewsCountWithResponse request
	PositiveReviewsCountWithResponse(ctx context.Context, params *PositiveReviewsCountParams, reqEditors ...RequestEditorFn) (*PositiveReviewsCountResponse, error)

	// PrivacyWithResponse request
	PrivacyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PrivacyResponse, error)

	// ProjectsWithResponse request
	ProjectsWithResponse(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*ProjectsResponse, error)

	// PushInAppNotificationLogWithResponse request
	PushInAppNotificationLogWithResponse(ctx context.Context, params *PushInAppNotificationLogParams, reqEditors ...RequestEditorFn) (*PushInAppNotificationLogResponse, error)

	// RateArbitrationWithResponse request
	RateArbitrationWithResponse(ctx context.Context, params *RateArbitrationParams, reqEditors ...RequestEditorFn) (*RateArbitrationResponse, error)

	// RechargeBalanceWithResponse request
	RechargeBalanceWithResponse(ctx context.Context, params *RechargeBalanceParams, reqEditors ...RequestEditorFn) (*RechargeBalanceResponse, error)

	// RegisterCloudTokenWithResponse request
	RegisterCloudTokenWithResponse(ctx context.Context, params *RegisterCloudTokenParams, reqEditors ...RequestEditorFn) (*RegisterCloudTokenResponse, error)

	// RejectCancelOrderRequestByPayerWithResponse request
	RejectCancelOrderRequestByPayerWithResponse(ctx context.Context, params *RejectCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*RejectCancelOrderRequestByPayerResponse, error)

	// RejectCancelOrderRequestByWorkerWithResponse request
	RejectCancelOrderRequestByWorkerWithResponse(ctx context.Context, params *RejectCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*RejectCancelOrderRequestByWorkerResponse, error)

	// RejectStageSuggestionWithResponse request
	RejectStageSuggestionWithResponse(ctx context.Context, params *RejectStageSuggestionParams, reqEditors ...RequestEditorFn) (*RejectStageSuggestionResponse, error)

	// RepeatOrderWithResponse request
	RepeatOrderWithResponse(ctx context.Context, params *RepeatOrderParams, reqEditors ...RequestEditorFn) (*RepeatOrderResponse, error)

	// ReportAppVersionWithResponse request
	ReportAppVersionWithResponse(ctx context.Context, params *ReportAppVersionParams, reqEditors ...RequestEditorFn) (*ReportAppVersionResponse, error)

	// RequestPhoneChangingWithResponse request
	RequestPhoneChangingWithResponse(ctx context.Context, params *RequestPhoneChangingParams, reqEditors ...RequestEditorFn) (*RequestPhoneChangingResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithFormdataBodyWithResponse(ctx context.Context, body ResetPasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// ResolutionWithResponse request
	ResolutionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResolutionResponse, error)

	// RestartWantWithResponse request
	RestartWantWithResponse(ctx context.Context, params *RestartWantParams, reqEditors ...RequestEditorFn) (*RestartWantResponse, error)

	// SaveOrderNoteWithBodyWithResponse request with any body
	SaveOrderNoteWithBodyWithResponse(ctx context.Context, params *SaveOrderNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveOrderNoteResponse, error)

	SaveOrderNoteWithFormdataBodyWithResponse(ctx context.Context, params *SaveOrderNoteParams, body SaveOrderNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*SaveOrderNoteResponse, error)

	// SaveUserNoteWithBodyWithResponse request with any body
	SaveUserNoteWithBodyWithResponse(ctx context.Context, params *SaveUserNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserNoteResponse, error)

	SaveUserNoteWithFormdataBodyWithResponse(ctx context.Context, params *SaveUserNoteParams, body SaveUserNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*SaveUserNoteResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// SearchDialogsWithResponse request
	SearchDialogsWithResponse(ctx context.Context, params *SearchDialogsParams, reqEditors ...RequestEditorFn) (*SearchDialogsResponse, error)

	// SearchInboxesWithResponse request
	SearchInboxesWithResponse(ctx context.Context, params *SearchInboxesParams, reqEditors ...RequestEditorFn) (*SearchInboxesResponse, error)

	// SearchKworksCatalogQueryWithResponse request
	SearchKworksCatalogQueryWithResponse(ctx context.Context, params *SearchKworksCatalogQueryParams, reqEditors ...RequestEditorFn) (*SearchKworksCatalogQueryResponse, error)

	// SearchMessagesWithResponse request
	SearchMessagesWithResponse(ctx context.Context, params *SearchMessagesParams, reqEditors ...RequestEditorFn) (*SearchMessagesResponse, error)

	// SearchOrderTracksWithResponse request
	SearchOrderTracksWithResponse(ctx context.Context, params *SearchOrderTracksParams, reqEditors ...RequestEditorFn) (*SearchOrderTracksResponse, error)

	// SearchTracksWithResponse request
	SearchTracksWithResponse(ctx context.Context, params *SearchTracksParams, reqEditors ...RequestEditorFn) (*SearchTracksResponse, error)

	// SendBonusWithResponse request
	SendBonusWithResponse(ctx context.Context, params *SendBonusParams, reqEditors ...RequestEditorFn) (*SendBonusResponse, error)

	// SendCompanyForVerificationWithResponse request
	SendCompanyForVerificationWithResponse(ctx context.Context, params *SendCompanyForVerificationParams, reqEditors ...RequestEditorFn) (*SendCompanyForVerificationResponse, error)

	// SendOrderForApprovalWithResponse request
	SendOrderForApprovalWithResponse(ctx context.Context, params *SendOrderForApprovalParams, reqEditors ...RequestEditorFn) (*SendOrderForApprovalResponse, error)

	// SendOrderForArbitrationWithResponse request
	SendOrderForArbitrationWithResponse(ctx context.Context, params *SendOrderForArbitrationParams, reqEditors ...RequestEditorFn) (*SendOrderForArbitrationResponse, error)

	// SendOrderForRevisionWithResponse request
	SendOrderForRevisionWithResponse(ctx context.Context, params *SendOrderForRevisionParams, reqEditors ...RequestEditorFn) (*SendOrderForRevisionResponse, error)

	// SendOrderReceiptLinkForVerificationWithResponse request
	SendOrderReceiptLinkForVerificationWithResponse(ctx context.Context, params *SendOrderReceiptLinkForVerificationParams, reqEditors ...RequestEditorFn) (*SendOrderReceiptLinkForVerificationResponse, error)

	// SendOrderRequirementsWithResponse request
	SendOrderRequirementsWithResponse(ctx context.Context, params *SendOrderRequirementsParams, reqEditors ...RequestEditorFn) (*SendOrderRequirementsResponse, error)

	// SendReportWithResponse request
	SendReportWithResponse(ctx context.Context, params *SendReportParams, reqEditors ...RequestEditorFn) (*SendReportResponse, error)

	// SendSelfEmployedSurveyResultWithResponse request
	SendSelfEmployedSurveyResultWithResponse(ctx context.Context, params *SendSelfEmployedSurveyResultParams, reqEditors ...RequestEditorFn) (*SendSelfEmployedSurveyResultResponse, error)

	// SendUserStatusWithResponse request
	SendUserStatusWithResponse(ctx context.Context, params *SendUserStatusParams, reqEditors ...RequestEditorFn) (*SendUserStatusResponse, error)

	// SendWhatsAppCodeWithResponse request
	SendWhatsAppCodeWithResponse(ctx context.Context, params *SendWhatsAppCodeParams, reqEditors ...RequestEditorFn) (*SendWhatsAppCodeResponse, error)

	// SetAvailableAtWeekendsWithResponse request
	SetAvailableAtWeekendsWithResponse(ctx context.Context, params *SetAvailableAtWeekendsParams, reqEditors ...RequestEditorFn) (*SetAvailableAtWeekendsResponse, error)

	// SetDialogStarredWithResponse request
	SetDialogStarredWithResponse(ctx context.Context, params *SetDialogStarredParams, reqEditors ...RequestEditorFn) (*SetDialogStarredResponse, error)

	// SetFavoriteWithResponse request
	SetFavoriteWithResponse(ctx context.Context, params *SetFavoriteParams, reqEditors ...RequestEditorFn) (*SetFavoriteResponse, error)

	// SetFishingTutorialStatusWithResponse request
	SetFishingTutorialStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SetFishingTutorialStatusResponse, error)

	// SetOrderRatingWithResponse request
	SetOrderRatingWithResponse(ctx context.Context, params *SetOrderRatingParams, reqEditors ...RequestEditorFn) (*SetOrderRatingResponse, error)

	// SetTakingOrdersWithResponse request
	SetTakingOrdersWithResponse(ctx context.Context, params *SetTakingOrdersParams, reqEditors ...RequestEditorFn) (*SetTakingOrdersResponse, error)

	// SetUserTypeWithResponse request
	SetUserTypeWithResponse(ctx context.Context, params *SetUserTypeParams, reqEditors ...RequestEditorFn) (*SetUserTypeResponse, error)

	// SetVoiceMessageReceivingWithResponse request
	SetVoiceMessageReceivingWithResponse(ctx context.Context, params *SetVoiceMessageReceivingParams, reqEditors ...RequestEditorFn) (*SetVoiceMessageReceivingResponse, error)

	// SetVoiceMessageSpeedWithResponse request
	SetVoiceMessageSpeedWithResponse(ctx context.Context, params *SetVoiceMessageSpeedParams, reqEditors ...RequestEditorFn) (*SetVoiceMessageSpeedResponse, error)

	// SignInWithBodyWithResponse request with any body
	SignInWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignInResponse, error)

	SignInWithFormdataBodyWithResponse(ctx context.Context, body SignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*SignInResponse, error)

	// SignUpWithBodyWithResponse request with any body
	SignUpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignUpResponse, error)

	SignUpWithFormdataBodyWithResponse(ctx context.Context, body SignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*SignUpResponse, error)

	// SocialSignInWithBodyWithResponse request with any body
	SocialSignInWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignInResponse, error)

	SocialSignInWithFormdataBodyWithResponse(ctx context.Context, body SocialSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignInResponse, error)

	// SocialSignInByTokenWithBodyWithResponse request with any body
	SocialSignInByTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignInByTokenResponse, error)

	SocialSignInByTokenWithFormdataBodyWithResponse(ctx context.Context, body SocialSignInByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignInByTokenResponse, error)

	// SocialSignInByTokenv2WithBodyWithResponse request with any body
	SocialSignInByTokenv2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignInByTokenv2Response, error)

	SocialSignInByTokenv2WithFormdataBodyWithResponse(ctx context.Context, body SocialSignInByTokenv2FormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignInByTokenv2Response, error)

	// SocialSignUpWithBodyWithResponse request with any body
	SocialSignUpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignUpResponse, error)

	SocialSignUpWithFormdataBodyWithResponse(ctx context.Context, body SocialSignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignUpResponse, error)

	// SocialSignUpByTokenWithBodyWithResponse request with any body
	SocialSignUpByTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignUpByTokenResponse, error)

	SocialSignUpByTokenWithFormdataBodyWithResponse(ctx context.Context, body SocialSignUpByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignUpByTokenResponse, error)

	// StartKworkWithResponse request
	StartKworkWithResponse(ctx context.Context, params *StartKworkParams, reqEditors ...RequestEditorFn) (*StartKworkResponse, error)

	// StopWantWithResponse request
	StopWantWithResponse(ctx context.Context, params *StopWantParams, reqEditors ...RequestEditorFn) (*StopWantResponse, error)

	// SuggestStagesWithResponse request
	SuggestStagesWithResponse(ctx context.Context, params *SuggestStagesParams, reqEditors ...RequestEditorFn) (*SuggestStagesResponse, error)

	// TermsWithResponse request
	TermsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TermsResponse, error)

	// TermsOfServiceWithResponse request
	TermsOfServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TermsOfServiceResponse, error)

	// TimezonesWithResponse request
	TimezonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TimezonesResponse, error)

	// TrackDeleteWithResponse request
	TrackDeleteWithResponse(ctx context.Context, params *TrackDeleteParams, reqEditors ...RequestEditorFn) (*TrackDeleteResponse, error)

	// TrackEditWithBodyWithResponse request with any body
	TrackEditWithBodyWithResponse(ctx context.Context, params *TrackEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TrackEditResponse, error)

	TrackEditWithFormdataBodyWithResponse(ctx context.Context, params *TrackEditParams, body TrackEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*TrackEditResponse, error)

	// TrackMessageWithResponse request
	TrackMessageWithResponse(ctx context.Context, params *TrackMessageParams, reqEditors ...RequestEditorFn) (*TrackMessageResponse, error)

	// TrackReadWithResponse request
	TrackReadWithResponse(ctx context.Context, params *TrackReadParams, reqEditors ...RequestEditorFn) (*TrackReadResponse, error)

	// TranslationLanguagesWithResponse request
	TranslationLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TranslationLanguagesResponse, error)

	// TypingWithResponse request
	TypingWithResponse(ctx context.Context, params *TypingParams, reqEditors ...RequestEditorFn) (*TypingResponse, error)

	// UnarchiveDialogWithResponse request
	UnarchiveDialogWithResponse(ctx context.Context, params *UnarchiveDialogParams, reqEditors ...RequestEditorFn) (*UnarchiveDialogResponse, error)

	// UnblockDialogWithResponse request
	UnblockDialogWithResponse(ctx context.Context, params *UnblockDialogParams, reqEditors ...RequestEditorFn) (*UnblockDialogResponse, error)

	// UnreadDialogWithResponse request
	UnreadDialogWithResponse(ctx context.Context, params *UnreadDialogParams, reqEditors ...RequestEditorFn) (*UnreadDialogResponse, error)

	// UpdateAvatarWithBodyWithResponse request with any body
	UpdateAvatarWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAvatarResponse, error)

	// UpdateChatDraftMessageWithResponse request
	UpdateChatDraftMessageWithResponse(ctx context.Context, params *UpdateChatDraftMessageParams, reqEditors ...RequestEditorFn) (*UpdateChatDraftMessageResponse, error)

	// UpdateOrderDraftMessageWithResponse request
	UpdateOrderDraftMessageWithResponse(ctx context.Context, params *UpdateOrderDraftMessageParams, reqEditors ...RequestEditorFn) (*UpdateOrderDraftMessageResponse, error)

	// UpdateSettingsWithBodyWithResponse request with any body
	UpdateSettingsWithBodyWithResponse(ctx context.Context, params *UpdateSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error)

	// UpdateStageProgressWithResponse request
	UpdateStageProgressWithResponse(ctx context.Context, params *UpdateStageProgressParams, reqEditors ...RequestEditorFn) (*UpdateStageProgressResponse, error)

	// UploadCoverWithBodyWithResponse request with any body
	UploadCoverWithBodyWithResponse(ctx context.Context, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCoverResponse, error)

	// UploadLogWithBodyWithResponse request with any body
	UploadLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLogResponse, error)

	// UploadPortfolioFileWithBodyWithResponse request with any body
	UploadPortfolioFileWithBodyWithResponse(ctx context.Context, params *UploadPortfolioFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPortfolioFileResponse, error)

	// UploadedFileWithResponse request
	UploadedFileWithResponse(ctx context.Context, params *UploadedFileParams, reqEditors ...RequestEditorFn) (*UploadedFileResponse, error)

	// UserWithResponse request
	UserWithResponse(ctx context.Context, params *UserParams, reqEditors ...RequestEditorFn) (*UserResponse, error)

	// UserByUsernameWithResponse request
	UserByUsernameWithResponse(ctx context.Context, params *UserByUsernameParams, reqEditors ...RequestEditorFn) (*UserByUsernameResponse, error)

	// UserKworksWithResponse request
	UserKworksWithResponse(ctx context.Context, params *UserKworksParams, reqEditors ...RequestEditorFn) (*UserKworksResponse, error)

	// UserReviewsWithResponse request
	UserReviewsWithResponse(ctx context.Context, params *UserReviewsParams, reqEditors ...RequestEditorFn) (*UserReviewsResponse, error)

	// UserSearchWithResponse request
	UserSearchWithResponse(ctx context.Context, params *UserSearchParams, reqEditors ...RequestEditorFn) (*UserSearchResponse, error)

	// VerifyPhoneActivationCodeWithResponse request
	VerifyPhoneActivationCodeWithResponse(ctx context.Context, params *VerifyPhoneActivationCodeParams, reqEditors ...RequestEditorFn) (*VerifyPhoneActivationCodeResponse, error)

	// VerifySmsCodeForAccountDeletingWithResponse request
	VerifySmsCodeForAccountDeletingWithResponse(ctx context.Context, params *VerifySmsCodeForAccountDeletingParams, reqEditors ...RequestEditorFn) (*VerifySmsCodeForAccountDeletingResponse, error)

	// ViewedCatalogKworksWithResponse request
	ViewedCatalogKworksWithResponse(ctx context.Context, params *ViewedCatalogKworksParams, reqEditors ...RequestEditorFn) (*ViewedCatalogKworksResponse, error)

	// VoiceUploadWithBodyWithResponse request with any body
	VoiceUploadWithBodyWithResponse(ctx context.Context, params *VoiceUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VoiceUploadResponse, error)

	// WantWithResponse request
	WantWithResponse(ctx context.Context, params *WantParams, reqEditors ...RequestEditorFn) (*WantResponse, error)

	// WantsStatusListWithResponse request
	WantsStatusListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WantsStatusListResponse, error)

	// WorkerConfirmsExtraRemovalRequestWithResponse request
	WorkerConfirmsExtraRemovalRequestWithResponse(ctx context.Context, params *WorkerConfirmsExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*WorkerConfirmsExtraRemovalRequestResponse, error)

	// WorkerDeclineExtrasWithResponse request
	WorkerDeclineExtrasWithResponse(ctx context.Context, params *WorkerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*WorkerDeclineExtrasResponse, error)

	// WorkerDeclinesExtraRemovalRequestWithResponse request
	WorkerDeclinesExtraRemovalRequestWithResponse(ctx context.Context, params *WorkerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*WorkerDeclinesExtraRemovalRequestResponse, error)

	// WorkerExtraDeleteWithResponse request
	WorkerExtraDeleteWithResponse(ctx context.Context, params *WorkerExtraDeleteParams, reqEditors ...RequestEditorFn) (*WorkerExtraDeleteResponse, error)

	// WorkerInprogressWithResponse request
	WorkerInprogressWithResponse(ctx context.Context, params *WorkerInprogressParams, reqEditors ...RequestEditorFn) (*WorkerInprogressResponse, error)

	// WorkerOrdersWithResponse request
	WorkerOrdersWithResponse(ctx context.Context, params *WorkerOrdersParams, reqEditors ...RequestEditorFn) (*WorkerOrdersResponse, error)
}

type AcceptExtrasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *BalanceDeficit
}

// Status returns HTTPResponse.Status
func (r AcceptExtrasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptExtrasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptStageSuggestionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AcceptStageSuggestionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptStageSuggestionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// AchievmentsList Бейдж пользователя
			AchievmentsList *ProfileBadges `json:"achievments_list,omitempty"`

			// Addtime Дата регистрации
			Addtime *int `json:"addtime,omitempty"`

			// AllowMobilePush Разрешена ли отправка пушей в мобильное приложение через FCM
			AllowMobilePush *bool `json:"allow_mobile_push,omitempty"`

			// AppNotifyCount Количество непрочитанных уведомлений, кроме [want, kworkActive, kworkRejected]
			AppNotifyCount *int `json:"app_notify_count,omitempty"`

			// ArchivedWantsCount Количество архивных запросов пользователя
			ArchivedWantsCount *int `json:"archived_wants_count,omitempty"`

			// BadReviews Количество отрицательныз отзывов
			BadReviews *int `json:"bad_reviews,omitempty"`

			// BlackFridayForSellers Активность акции ЧП для продавцов
			BlackFridayForSellers *bool `json:"black_friday_for_sellers,omitempty"`

			// CityId Идентификатор города
			CityId *int `json:"city_id,omitempty"`

			// CompletedOrdersCount Кол-во выполненных заказов
			CompletedOrdersCount *int `json:"completed_orders_count,omitempty"`

			// CountryId Идентификатор страны
			CountryId *int `json:"country_id,omitempty"`

			// Cover Путь к баннеру пользователя
			Cover *string `json:"cover,omitempty"`

			// Currency Валюта
			Currency *string `json:"currency,omitempty"`

			// Description Текст о себе
			Description *string `json:"description,omitempty"`

			// Email E-mail
			Email *string `json:"email,omitempty"`

			// FavouriteKworksCount Кол-во избранных кворков
			FavouriteKworksCount *int `json:"favourite_kworks_count,omitempty"`

			// FreeAmount Баланс свободный
			FreeAmount *float32 `json:"free_amount,omitempty"`

			// Fullname Настоящее имя
			Fullname *string `json:"fullname,omitempty"`

			// GoodReviews Количество положительных отзывов
			GoodReviews *int `json:"good_reviews,omitempty"`

			// HasOffers Есть ли у пользователя активные предложения
			HasOffers *bool `json:"has_offers,omitempty"`

			// HiddenKworksCount Кол-во скрытых кворков
			HiddenKworksCount *int `json:"hidden_kworks_count,omitempty"`

			// HoldAmount Баланс заблокировано
			HoldAmount *float32 `json:"hold_amount,omitempty"`

			// Id Идентификатор пользователя
			Id *int `json:"id,omitempty"`

			// InboxArchiveCount Количество диалогов в архиве
			InboxArchiveCount *int `json:"inbox_archive_count,omitempty"`

			// IsMorePayer Пользователь больше покупатель, чем продавец
			IsMorePayer *bool `json:"is_more_payer,omitempty"`

			// Kworks Кворки пользователя
			Kworks *ProfileKworks `json:"kworks,omitempty"`

			// KworksAvailableAtWeekends Флаг, показывающий доступны ли кворки на выходных
			KworksAvailableAtWeekends *bool `json:"kworks_available_at_weekends,omitempty"`

			// KworksCount Кол-во кворков актора
			KworksCount *int `json:"kworks_count,omitempty"`

			// LevelDescription Название уровня продавца
			LevelDescription *string `json:"level_description,omitempty"`

			// Location Город или страна
			Location *string `json:"location,omitempty"`

			// NotifyUnreadCount Количество непрочитанных уведомлений
			NotifyUnreadCount *int `json:"notify_unread_count,omitempty"`

			// OffersCount Количество предложений пользователя
			OffersCount *int `json:"offers_count,omitempty"`

			// PortfolioList Портфолио пользователя
			PortfolioList *ProfilePortfolios `json:"portfolio_list,omitempty"`

			// Profession Специальность пользователя
			Profession *string `json:"profession"`

			// Profilepicture Путь к изображению аватара
			Profilepicture *string `json:"profilepicture,omitempty"`

			// PushNotificationsSoundAllowed Включен ли звук в мобильных пуш уведомлениях
			PushNotificationsSoundAllowed *bool `json:"pushNotificationsSoundAllowed,omitempty"`

			// Rating Рейтинг по 5 бальной шкале с 1 десятичным знаком
			Rating *string `json:"rating,omitempty"`

			// RatingCount Количество отзывов
			RatingCount *int `json:"rating_count,omitempty"`

			// RedNotify Есть ли важные непрочитанные уведомления
			RedNotify *bool `json:"red_notify,omitempty"`

			// Reviews Массив отзывов
			Reviews *[]UserReview `json:"reviews,omitempty"`

			// Slogan Слоган - не заполнен
			Slogan *string `json:"slogan,omitempty"`

			// Status Статус
			Status *string `json:"status,omitempty"`

			// TimezoneId Идентификатор часового пояса
			TimezoneId *int `json:"timezone_id,omitempty"`

			// TotalAmount Баланс общий
			TotalAmount *float32 `json:"total_amount,omitempty"`

			// Type Текущая роль пользователя worker|payer
			Type *string `json:"type,omitempty"`

			// UnreadDialogCount Количество непрочитанных диалогов
			UnreadDialogCount *int `json:"unread_dialog_count,omitempty"`

			// UnreadMessagesCount Количество непрочитанных сообщений
			UnreadMessagesCount *int `json:"unread_messages_count,omitempty"`

			// Username Имя пользователя
			Username *string `json:"username,omitempty"`

			// Verified Подтвержден ли email
			Verified *bool `json:"verified,omitempty"`

			// WantsCount Количество запросов пользователя
			WantsCount *int `json:"wants_count,omitempty"`

			// WarningInboxCount Количество важных непрочитанных диалогов
			WarningInboxCount *int `json:"warning_inbox_count,omitempty"`

			// WorkerStatus Статус продавца (null, free, busy)
			WorkerStatus *string `json:"worker_status,omitempty"`

			// YescrowApplicants Дочерние роли
			YescrowApplicants *struct {
				// Payer Дочерняя роль - покупатель
				Payer *struct {
					// Status Статус проверки (0 - На проверке, 1 - Успешно, 2 - Отклонено)
					Status *int `json:"status,omitempty"`

					// Type Тип (2 - Юридическое лицо покупатель, 3 - Самозанятый покупатель, 4 - ИП покупатель)
					Type *int `json:"type,omitempty"`
				} `json:"payer,omitempty"`

				// Worker Дочерняя роль - продавец
				Worker *struct {
					// Status Статус проверки (0 - На проверке, 1 - Успешно, 2 - Отклонено)
					Status *int `json:"status,omitempty"`

					// Type Тип (0 - Самозанятый продавец, 1 - ИП продавец)
					Type *int `json:"type,omitempty"`
				} `json:"worker,omitempty"`
			} `json:"yescrow_applicants,omitempty"`

			// YescrowPayer Дочерние роли покупателя
			YescrowPayer *struct {
				// Company Компания
				Company *struct {
					// Name Название компании
					Name *string `json:"name,omitempty"`

					// Status Статус компании (0 - Проверка инициирована, 1 - Проверка пройдена, 2 - Проверка отклонена)
					Status *int `json:"status,omitempty"`
				} `json:"company,omitempty"`

				// CompanyBalance Баланс компании
				CompanyBalance *float32 `json:"company_balance,omitempty"`

				// Role Дочерняя роль (0 - Частное лицо, 1 - Компания)
				Role *int `json:"role,omitempty"`
			} `json:"yescrow_payer,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFavoriteCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddFavoriteCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFavoriteCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddNewPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ConfirmationType Тип уведомления call/sms/digits
			ConfirmationType *string `json:"confirmation_type,omitempty"`

			// Phone Маска номера телефона
			Phone *string `json:"phone,omitempty"`

			// TelegramBotLink Ссылка для Telegram
			TelegramBotLink *string `json:"telegram_bot_link,omitempty"`

			// Timeout Время через которое можно повторить отправку
			Timeout *int `json:"timeout,omitempty"`

			// WhatsappLink Ссылка для WhatsApp
			WhatsappLink *string `json:"whatsapp_link,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddNewPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddNewPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ConfirmationType Тип уведомления call/sms/digits
			ConfirmationType *string `json:"confirmation_type,omitempty"`

			// Phone Маска номера телефона
			Phone *string `json:"phone,omitempty"`

			// TelegramBotLink Ссылка для Telegram
			TelegramBotLink *string `json:"telegram_bot_link,omitempty"`

			// Timeout Время через которое можно повторить отправку
			Timeout *int `json:"timeout,omitempty"`

			// WhatsappLink Ссылка для WhatsApp
			WhatsappLink *string `json:"whatsapp_link,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllowInboxRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AllowInboxRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllowInboxRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllowMobilePushResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AllowMobilePushResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllowMobilePushResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllowOrderPortfolioUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AllowOrderPortfolioUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllowOrderPortfolioUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllowPushNotificationsSoundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AllowPushNotificationsSoundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllowPushNotificationsSoundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppleSignInResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppleSignInResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppleSignInResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApplyFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ApplyFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplyFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// CurrentStatus Название статуса, который присвоен юзеру
			CurrentStatus *string `json:"current_status,omitempty"`

			// CurrentStatusIcon Абсолютный путь для ссылки на картинку уровня
			CurrentStatusIcon *string `json:"current_status_icon,omitempty"`

			// NextStatus Название следующего уровня
			NextStatus *string `json:"next_status,omitempty"`

			// NextStatusBorder Количество заказов до следующего уровня.
			NextStatusBorder *int `json:"next_status_border,omitempty"`

			// OrderDeliveryTime За какое время был выполнен заказ
			OrderDeliveryTime *int `json:"order_delivery_time,omitempty"`

			// OrdersApproved Сколько заказов завершил покупатель
			OrdersApproved *int `json:"orders_approved,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ApproveOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveOrderStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// CurrentStatus Название статуса, который присвоен юзеру
			CurrentStatus *string `json:"current_status,omitempty"`

			// CurrentStatusIcon Абсолютный путь для ссылки на картинку уровня
			CurrentStatusIcon *string `json:"current_status_icon,omitempty"`

			// NextStatus Название следующего уровня
			NextStatus *string `json:"next_status,omitempty"`

			// NextStatusBorder Количество заказов до следующего уровня.
			NextStatusBorder *int `json:"next_status_border,omitempty"`

			// OrderDeliveryTime За какое время был выполнен заказ
			OrderDeliveryTime *int `json:"order_delivery_time,omitempty"`

			// OrdersApproved Сколько заказов завершил покупатель
			OrdersApproved *int `json:"orders_approved,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ApproveOrderStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveOrderStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ArchiveDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Message Сообщение об успехе
			Message *string `json:"message,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BlockDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedDialogListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// BlockedUserIds Идентификаторы пользователей
			BlockedUserIds *[]int `json:"blockedUserIds,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BlockedDialogListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedDialogListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelOrderAwaitingPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CancelOrderAwaitingPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelOrderAwaitingPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelOrderByPayerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CancelOrderByPayerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelOrderByPayerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelOrderByWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CancelOrderByWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelOrderByWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CatalogCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *[]SecondLevelCategory `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CatalogCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CatalogCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CatalogFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Filters Фильтры
			Filters *[]struct {
				// Filters Список подфильтров (для пакетных фильтров)
				Filters *[]struct {
					// Id Идентификатор
					Id *string `json:"id,omitempty"`

					// MaxValue Максимальное значение (для типа range)
					MaxValue *int `json:"max_value,omitempty"`

					// MinValue Минимальное значение (для типа range)
					MinValue *int `json:"min_value,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`

					// Type Тип numeric - числовой, multiple_choice - множественный выбор, one_of_several - одно из
					Type *string `json:"type,omitempty"`

					// Values Значения, если они есть
					Values *[]struct {
						// Id Идентификатор
						Id *string `json:"id,omitempty"`

						// Name Название
						Name *string `json:"name,omitempty"`
					} `json:"values,omitempty"`
				} `json:"filters,omitempty"`

				// Id Идентификатор
				Id *string `json:"id,omitempty"`

				// IsPackage Если заданно, то фильтр по пакетному параметру
				IsPackage *int `json:"is_package,omitempty"`

				// IsUnembedded Если заданно, то фильтр является отвязанным атрибутом
				IsUnembedded *int `json:"is_unembedded,omitempty"`

				// MaxValue Максимальное значение (для типа range)
				MaxValue *int `json:"max_value,omitempty"`

				// MinValue Минимальное значение (для типа range)
				MinValue *int `json:"min_value,omitempty"`

				// MobileGroupId Id группы
				MobileGroupId *int `json:"mobile_group_id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`

				// Placeholder Плейсхолдер для поля ввода значения (для типа numeric)
				Placeholder *string `json:"placeholder,omitempty"`

				// QueryKey Алиас фильтра
				QueryKey *string `json:"query_key,omitempty"`

				// Type Тип numeric - числовой, multiple_choice - множественный выбор, one_of_several - одно из
				Type *string `json:"type,omitempty"`

				// Values Значения, если они есть
				Values *[]struct {
					// Id Идентификатор
					Id *string `json:"id,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`
				} `json:"values,omitempty"`
			} `json:"filters,omitempty"`

			// Groups Группы фильтров
			Groups *[]struct {
				// Id ID группы
				Id *int `json:"id,omitempty"`

				// Name Название группы
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// KworksCount Кол-во кворков для заданных фильтров
			KworksCount *int `json:"kworks_count,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CatalogFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CatalogFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CatalogMainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *struct {
			// MarketingAction Маркетинговая акция
			MarketingAction *struct {
				// Image Путь к изображению
				Image *string `json:"image,omitempty"`

				// IsActive Признак активности
				IsActive *bool `json:"is_active,omitempty"`

				// Url Ссылка для перехода
				Url *string `json:"url,omitempty"`
			} `json:"marketing_action,omitempty"`

			// PopularCategories Популярные категории
			PopularCategories *[]SecondLevelCategory `json:"popular_categories,omitempty"`

			// PopularKworks Популярные кворки
			PopularKworks *[]ProfileKworks `json:"popular_kworks,omitempty"`

			// Rubrics Рубрики меню
			Rubrics *[]FirstLevelCategory `json:"rubrics,omitempty"`

			// ViewedKworks Просмотренные кворки
			ViewedKworks *[]ProfileKworks `json:"viewed_kworks,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CatalogMainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CatalogMainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CatalogMainv2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *struct {
			// CatalogServiceBlock Блоки каталога услуг
			CatalogServiceBlock *[]CatalogServiceBlock `json:"catalog_service_block,omitempty"`

			// MarketingAction Маркетинговая акция
			MarketingAction *struct {
				// Image Путь к изображению
				Image *string `json:"image,omitempty"`

				// IsActive Признак активности
				IsActive *bool `json:"is_active,omitempty"`

				// Url Ссылка для перехода
				Url *string `json:"url,omitempty"`
			} `json:"marketing_action,omitempty"`

			// OtherServicesBlock Блоки других услуг
			OtherServicesBlock *[]CatalogOtherServiceBlock `json:"other_services_block,omitempty"`

			// PopularCategoriesBlock Блоки популярных рубрик
			PopularCategoriesBlock *[]PopularBlock `json:"popular_categories_block,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CatalogMainv2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CatalogMainv2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CatalogRubricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *[]FirstLevelCategory `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CatalogRubricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CatalogRubricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Категории
		Response *[]CategoryLevel1 `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные категории
		Response *struct {
			// Attributes Классификации/Атрибуты
			Attributes *Attributes `json:"attributes,omitempty"`

			// BaseVolume Базовый числовой объем
			BaseVolume *int `json:"base_volume,omitempty"`

			// Id Идентификатор категории
			Id *int `json:"id,omitempty"`

			// MobileDescription Краткое описание
			MobileDescription *string `json:"mobile_description,omitempty"`

			// Name Название категории
			Name *string `json:"name,omitempty"`

			// PositiveReviewsCount Количество отзывов => Количество кворков с таким количество отзывов
			PositiveReviewsCount *PositiveReviewsCount `json:"positive_reviews_count,omitempty"`

			// VolumeType Тип числового объема
			VolumeType *VolumeType `json:"volume_type,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CategoryAttributesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Классификации/Атрибуты
		Response *Attributes `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CategoryAttributesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CategoryAttributesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ChangePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePayerSubRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ChangePayerSubRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePayerSubRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ChangeUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные о занятости логина
		Response *struct {
			// Login Сгенерированный свободный логин
			Login *string `json:"login,omitempty"`

			// Success Свободен ли логин
			Success *bool `json:"success,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности запроса
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CheckLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Города
		Response *[]struct {
			// Id Идентификатор
			Id *string `json:"id,omitempty"`

			// Name Название
			Name *string `json:"name,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Предустановленные фильтры
		Response *[]WantsFilter `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ClearFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmCancelOrderRequestByPayerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ConfirmCancelOrderRequestByPayerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmCancelOrderRequestByPayerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmCancelOrderRequestByWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ConfirmCancelOrderRequestByWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmCancelOrderRequestByWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Страны
		Response *[]struct {
			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// Name Название
			Name *string `json:"name,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKworkComplainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ComplainAvailable timestamp, когда можно отправить следующую жалобу без капчи.
		ComplainAvailable *int `json:"complainAvailable,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateKworkComplainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKworkComplainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePortfolioResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSON400     *MultiError
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreatePortfolioResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePortfolioResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelFavoriteCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DelFavoriteCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelFavoriteCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ConfirmationType Тип отправления кода подтверждения, sms/email/deleted
			ConfirmationType *string `json:"confirmation_type,omitempty"`

			// Orders Массив заказов если они есть
			Orders *[]struct {
				// Id ID заказа
				Id *int `json:"id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`
			} `json:"orders,omitempty"`

			// PhoneMask Замаскированный телефон, если подтверждение через SMS
			PhoneMask *string `json:"phoneMask,omitempty"`

			// TelegramBotLink Ссылка на Telegram-бот, если доступно подтверждение через Telegram
			TelegramBotLink *string `json:"telegramBotLink,omitempty"`

			// Timeout Время задержки перед следующей попыткой в секундах
			Timeout *int `json:"timeout,omitempty"`

			// TransportType Тип траноспорта при запросе кода через SMS или мессенджеры
			TransportType *string `json:"transportType,omitempty"`

			// WhatsappLink Ссылка для отправки кода в WhatsApp, если доступно подтверждение через WhatsApp
			WhatsappLink *string `json:"whatsappLink,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCancelOrderRequestByPayerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCancelOrderRequestByPayerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCancelOrderRequestByPayerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCancelOrderRequestByWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCancelOrderRequestByWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCancelOrderRequestByWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// Src Ссылка на дефолтную обложку
			Src *string `json:"src,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteKworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOfferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteOfferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOfferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteOrderNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePortfolioResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeletePortfolioResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePortfolioResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteWantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DialogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// FilterCounts Объект данных количеств диалогов по фильтрам
		FilterCounts *struct {
			// Archived Количество диалогов в архиве
			Archived *int `json:"archived,omitempty"`

			// Unread Количество непрочитанных диалогов
			Unread *int `json:"unread,omitempty"`
		} `json:"filter_counts,omitempty"`

		// Paging Данные пагинации
		Paging *Paging `json:"paging,omitempty"`

		// Response Массив объектов сообщений
		Response *[]DialogMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DialogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DialogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EditAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditPortfolioResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSON400     *MultiError
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r EditPortfolioResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditPortfolioResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EditReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EditStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailVerificationLetterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Timeout Время через которое можно повторить отправку
			Timeout *int `json:"timeout,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EmailVerificationLetterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailVerificationLetterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]ExchangeInfo `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FavoriteCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив объектов рубрик
		Response *[]struct {
			// Description Описание
			Description *string `json:"description,omitempty"`

			// Id ID
			Id *int `json:"id,omitempty"`

			// IsAttribute Является ли аттрибутом
			IsAttribute *bool `json:"is_attribute,omitempty"`

			// Name Название
			Name *string `json:"name,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FavoriteCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FavoriteCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FavoriteKworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Избранный кворк
		Response *FavoriteKworks `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FavoriteKworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FavoriteKworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FcmNotificationsReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r FcmNotificationsReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FcmNotificationsReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FcmNotificationsReceivedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r FcmNotificationsReceivedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FcmNotificationsReceivedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FcmTokenRequestFailedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r FcmTokenRequestFailedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FcmTokenRequestFailedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r FileDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Файл
		Response *File `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r FileUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActorInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// AboutMeText Текст о себе
			AboutMeText *string `json:"about_me_text,omitempty"`

			// AllowMobilePush Разрешена ли отправка пушей в мобильное приложение через FCM
			AllowMobilePush *bool `json:"allow_mobile_push,omitempty"`

			// ArchivedWantsCount Количество архивных запросов пользователя
			ArchivedWantsCount *int `json:"archived_wants_count,omitempty"`

			// AvatarPath Путь к изображению аватара
			AvatarPath *string `json:"avatar_path,omitempty"`

			// BlackFridayForSellers Активность акции ЧП для продавцов
			BlackFridayForSellers *bool `json:"black_friday_for_sellers,omitempty"`

			// CityId Идентификатор города
			CityId *int `json:"city_id,omitempty"`

			// CountryId Идентификатор страны
			CountryId *int `json:"country_id,omitempty"`

			// CoverPath Путь к баннеру пользователя
			CoverPath *string `json:"cover_path,omitempty"`

			// Currency Валюта
			Currency *string `json:"currency,omitempty"`

			// FavouriteKworksCount Кол-во избранных кворков
			FavouriteKworksCount *int `json:"favourite_kworks_count,omitempty"`

			// Fullname Настоящее имя
			Fullname *string `json:"fullname,omitempty"`

			// HiddenKworksCount Кол-во скрытых кворков
			HiddenKworksCount *int `json:"hidden_kworks_count,omitempty"`

			// Id Идентификатор пользователя
			Id *int `json:"id,omitempty"`

			// KworksCount Кол-во кворков актора
			KworksCount *int `json:"kworks_count,omitempty"`

			// OffersCount Количество предложений пользователя
			OffersCount *int `json:"offers_count,omitempty"`

			// Profession Специальность пользователя
			Profession *string `json:"profession"`

			// PushNotificationsSoundAllowed Включен ли звук в мобильных пуш уведомлениях
			PushNotificationsSoundAllowed *bool `json:"push_notifications_sound_allowed,omitempty"`

			// TimezoneId Идентификатор часового пояса
			TimezoneId *int `json:"timezone_id,omitempty"`

			// TotalAmount Баланс общий
			TotalAmount *float32 `json:"total_amount,omitempty"`

			// Type Текущая роль пользователя worker|payer
			Type *string `json:"type,omitempty"`

			// Username Имя пользователя
			Username *string `json:"username,omitempty"`

			// Verified Подтвержден ли email
			Verified *bool `json:"verified,omitempty"`

			// WorkerStatus Статус продавца (null, free, busy)
			WorkerStatus *string `json:"worker_status,omitempty"`

			// YescrowPayer Дочерние роли покупателя
			YescrowPayer *struct {
				// Company Компания
				Company *struct {
					// Name Название компании
					Name *string `json:"name,omitempty"`

					// Status Статус компании (0 - Проверка инициирована, 1 - Проверка пройдена, 2 - Проверка отклонена)
					Status *int `json:"status,omitempty"`
				} `json:"company,omitempty"`

				// Role Дочерняя роль (0 - Частное лицо, 1 - Компания)
				Role *int `json:"role,omitempty"`
			} `json:"yescrow_payer,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetActorInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActorInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArbitrationReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]ArbitrationReason `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetArbitrationReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArbitrationReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// IsSupportDialogAvailable Флаг открытого общения со службой поддержки
			IsSupportDialogAvailable *bool `json:"is_support_dialog_available,omitempty"`

			// SelfEmployed Информация СЗ/ИП
			SelfEmployed *struct {
				// ShowRegistrationNotification Флаг для отображения успешной регистрации СЗ/ИП
				ShowRegistrationNotification *bool `json:"show_registration_notification,omitempty"`

				// ShowSurveyPopup Флаг для отображения опроса
				ShowSurveyPopup *bool `json:"show_survey_popup,omitempty"`
			} `json:"self_employed,omitempty"`

			// TestGroups Набор тестовых групп пользователя
			TestGroups *[]map[string]bool `json:"test_groups,omitempty"`

			// VoiceMessages Голосовые сообщения
			VoiceMessages *struct {
				// IsVoiceMessageRecordingAvailable Разрешение записывать ГС
				IsVoiceMessageRecordingAvailable *bool `json:"is_voice_message_recording_available,omitempty"`

				// ReceivingSettings Настройки получения ГС
				ReceivingSettings *struct {
					// IsReceivingAllowed Флаг разрешения приема ГС
					IsReceivingAllowed *bool `json:"is_receiving_allowed,omitempty"`

					// IsReceivingSettingAllowed Флаг доступности настройки ГС
					IsReceivingSettingAllowed *bool `json:"is_receiving_setting_allowed,omitempty"`

					// ShouldShowSettingsPopup Флаг показа попапа
					ShouldShowSettingsPopup *bool `json:"should_show_settings_popup,omitempty"`
				} `json:"receiving_settings,omitempty"`

				// SpeedControl Параметры скорости ГС
				SpeedControl *struct {
					// AvailableSpeeds Список допустимых скоростей
					AvailableSpeeds *[]float32 `json:"available_speeds,omitempty"`

					// IsAvailable Разрешение менять скорость
					IsAvailable *bool `json:"is_available,omitempty"`

					// Speed Скорость воспроизведения
					Speed *float32 `json:"speed,omitempty"`
				} `json:"speed_control,omitempty"`
			} `json:"voice_messages,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAvailableFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBadgesInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// DialogsUnreadCount Количество непрочитанных диалогов
			DialogsUnreadCount *int `json:"dialogs_unread_count,omitempty"`

			// ImportantDialogCount Количество важных диалогов
			ImportantDialogCount *int `json:"important_dialog_count,omitempty"`

			// ImportantNotificationsCount Есть ли важные непрочитанные уведомления
			ImportantNotificationsCount *bool `json:"important_notifications_count,omitempty"`

			// NotificationsNotDelivered Необходимость отображать уведомление о добавлении приложения в белый список
			NotificationsNotDelivered *bool `json:"notifications_not_delivered,omitempty"`

			// NotificationsUnreadCount Количество непрочитанных уведомлений
			NotificationsUnreadCount *int `json:"notifications_unread_count,omitempty"`

			// UnreadMessagesCount Количество непрочитанных сообщений
			UnreadMessagesCount *int `json:"unread_messages_count,omitempty"`

			// WarningDialogsCount Количество важных непрочитанных диалогов
			WarningDialogsCount *int `json:"warning_dialogs_count,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBadgesInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBadgesInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillRefillUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// YescrowPaymentUrl URL для редиректа браузера
			YescrowPaymentUrl *string `json:"yescrowPaymentUrl,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBillRefillUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillRefillUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptchaStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ShowCaptcha Требуется ли показать капчу при запросе сброса пароля
			ShowCaptcha *bool `json:"show_captcha,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCaptchaStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptchaStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Channel Идентификатор канала
			Channel *string `json:"channel,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные о компании
		Response *GetCompanyDetails_200_Response `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}
type GetCompanyDetails_200_Response struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetCompanyDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplainCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Категории жалоб
		Response *[]ComplainCategory `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetComplainCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplainCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCookieResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCookieResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCookieResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *struct {
			// CriticalUpdate Флаг критического обновления
			CriticalUpdate *bool `json:"critical_update,omitempty"`

			// CurrentVersionAndroid Текущая версия Android
			CurrentVersionAndroid *string `json:"current_version_android,omitempty"`

			// CurrentVersionIos Текущая версия iOS
			CurrentVersionIos *string `json:"current_version_ios,omitempty"`

			// Facebook Флаг использования Facebook
			Facebook *bool `json:"facebook,omitempty"`

			// Notification In-app уведомление или null
			Notification *struct {
				Id                  *int    `json:"id,omitempty"`
				Lang                *string `json:"lang,omitempty"`
				Link                *string `json:"link,omitempty"`
				MinSupportedVersion *int    `json:"min_supported_version,omitempty"`
				ShowPeriodDays      *int    `json:"show_period_days,omitempty"`

				// SupportEndDate Unix timestamp окончания поддержки
				SupportEndDate *int    `json:"support_end_date,omitempty"`
				Text           *string `json:"text,omitempty"`
				Title          *string `json:"title,omitempty"`
			} `json:"notification"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *struct {
		// Error Текст ошибки
		Error *string `json:"error,omitempty"`

		// ErrorCode Код ошибки
		ErrorCode *int `json:"error_code,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCurrentVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomOptionsPresetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// ExtraLimitPrice Сумма опций для покупателя, которую ещё можно добавить в заказ
			ExtraLimitPrice *int `json:"extra_limit_price,omitempty"`

			// PriceRange Цены
			PriceRange *[]struct {
				// PayerPrice Цена
				PayerPrice *float32 `json:"payer_price,omitempty"`

				// WorkerPrice Цена с комиссией
				WorkerPrice *float32 `json:"worker_price,omitempty"`
			} `json:"price_range,omitempty"`

			// TimeUpperBoundInDays Максимальное количество дней, доступное для опции
			TimeUpperBoundInDays *int `json:"time_upper_bound_in_days,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomOptionsPresetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomOptionsPresetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *DialogMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtrasAvailableForOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]OrderOption `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetExtrasAvailableForOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtrasAvailableForOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFishingTutorialQuestionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *[]struct {
			Answers *[]struct {
				// Comment Комментарий к ответу
				Comment *string `json:"comment,omitempty"`

				// IsCorrect Верный ли ответ
				IsCorrect *bool `json:"isCorrect,omitempty"`

				// Text Вариант ответа
				Text *string `json:"text,omitempty"`
			} `json:"answers,omitempty"`

			// Text Текст вопроса
			Text *string `json:"text,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности запроса
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetFishingTutorialQuestionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFishingTutorialQuestionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHiddenKworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Кворки пользователя
		Response *ProfileKworks `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetHiddenKworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHiddenKworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInboxTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Orders Данные об активных заказах между пользователями
		Orders *[]TrackOrder `json:"orders,omitempty"`

		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]InboxTrackMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`

		// User Данные о собеседнике
		User *Interlocutor `json:"user,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetInboxTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInboxTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkAnswersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response FAQ
		Response *[]struct {
			// Answer Ответ
			Answer *int `json:"answer,omitempty"`

			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// Position Позиция
			Position *int `json:"position,omitempty"`

			// Question Вопрос
			Question *string `json:"question,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkAnswersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkAnswersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Active Статус кворка
			Active *int `json:"active,omitempty"`

			// AdditionalOptions Дополнительные опции
			AdditionalOptions *[]struct {
				// Id Идентификатор опции
				Id *int `json:"id,omitempty"`

				// Name Наименование опции
				Name *string `json:"name,omitempty"`

				// Price Стоимость опции
				Price *int `json:"price,omitempty"`
			} `json:"additional_options,omitempty"`

			// Badges Бейджи кворка
			Badges *KworkBadges `json:"badges,omitempty"`

			// Category Id категории
			Category *int `json:"category,omitempty"`

			// ChannelLink Данные о канале
			ChannelLink *[]struct {
				// Link Адрес ссылки
				Link *string `json:"link,omitempty"`

				// Type Тип сети
				Type *string `json:"type,omitempty"`
			} `json:"channel_link,omitempty"`

			// ChannelStat Данные о канале
			ChannelStat *[]struct {
				// AvgPostReach Просмотры на пост
				AvgPostReach *int `json:"avg_post_reach,omitempty"`

				// ErrPercent Вовлеченность
				ErrPercent *float32 `json:"err_percent,omitempty"`

				// MentionsCount Кол-во упоминаний
				MentionsCount *int `json:"mentions_count,omitempty"`

				// ParticipantsCount Кол-во подписчиков
				ParticipantsCount *int `json:"participants_count,omitempty"`

				// PostsPerDay Публикаций в день
				PostsPerDay *int `json:"posts_per_day,omitempty"`

				// PricePerThousand Цена за 1000 просмотров
				PricePerThousand *float32 `json:"price_per_thousand,omitempty"`
			} `json:"channel_stat,omitempty"`

			// Classifications Классификации для вывода
			Classifications *[]struct {
				// Attrs Атрибуты через запятую
				Attrs *string `json:"attrs,omitempty"`

				// Title Заголовок
				Title *string `json:"title,omitempty"`
			} `json:"classifications,omitempty"`

			// DefaultKworkPrice Стандартная цена кворка
			DefaultKworkPrice *int `json:"default_kwork_price,omitempty"`

			// Feat Активен кворк или нет
			Feat *int `json:"feat,omitempty"`

			// Files Прикрепленные файлы
			Files *[]struct {
				// EntityType Тип файла
				EntityType *string `json:"entity_type,omitempty"`

				// Fname Имя файла
				Fname *string `json:"fname,omitempty"`

				// Url Ссылка на файл
				Url *string `json:"url,omitempty"`
			} `json:"files,omitempty"`

			// Id Идентификатор кворка
			Id *string `json:"id,omitempty"`

			// ImageUrl Путь к обложке кворка
			ImageUrl *string `json:"image_url,omitempty"`

			// IsFavorite Кворк в избранных у активного юзера
			IsFavorite *bool `json:"is_favorite,omitempty"`

			// IsHidden Кворк скрыт у активного юзера
			IsHidden *bool `json:"is_hidden,omitempty"`

			// IsKworkRejectedWithSpamReason Отклонен ли кворк с причиной Спам
			IsKworkRejectedWithSpamReason *bool `json:"is_kwork_rejected_with_spam_reason,omitempty"`

			// IsSubscription Наличие бейджа “подписка”
			IsSubscription *bool `json:"is_subscription,omitempty"`

			// KworkDescription Описание кворка
			KworkDescription *string `json:"kwork_description,omitempty"`

			// KworkInFavoritesCount Кол-во раз, которое кворк добавили в избранное
			KworkInFavoritesCount *int `json:"kwork_in_favorites_count,omitempty"`

			// KworkInstructions Инструкции для покупателей
			KworkInstructions *string `json:"kwork_instructions,omitempty"`

			// KworkLink Ссылка на кворк
			KworkLink *string `json:"kwork_link,omitempty"`

			// KworkTitle Наименование кворка
			KworkTitle *string `json:"kwork_title,omitempty"`

			// Lang Язык кворка
			Lang *string `json:"lang,omitempty"`

			// LinksSites Ссылки кворка
			LinksSites *[]KworkLinkSiteItem `json:"links_sites,omitempty"`

			// LinksSitesCount Кол-во ссылок кворка
			LinksSitesCount *int `json:"links_sites_count,omitempty"`

			// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
			NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

			// OrdersInQueueCount Заказов в очереди
			OrdersInQueueCount *int `json:"orders_in_queue_count,omitempty"`

			// Packages Пакетные предложения для кворка
			Packages *[]KworkPackage `json:"packages,omitempty"`

			// PortfolioItems Первые 10 работ портфолио кворка
			PortfolioItems *[]ProfilePortfolios `json:"portfolio_items,omitempty"`

			// PortfolioItemsCount Кол-во работ в портфолио кворка
			PortfolioItemsCount *int `json:"portfolio_items_count,omitempty"`

			// RejectFieldsString Список причин отклонения кворка, если он отклонен
			RejectFieldsString *string        `json:"reject_fields_string,omitempty"`
			ShortUserInfo      *ShortUserInfo `json:"short_user_info,omitempty"`

			// ShowSubscribersStatistics Достаточно ли данных для отображения графика о динамике подписчиков на канале
			ShowSubscribersStatistics *bool `json:"show_subscribers_statistics,omitempty"`

			// Term Срок выполнения
			Term *string `json:"term,omitempty"`

			// UnitAndQuantity Единицы измерения и кол-во
			UnitAndQuantity *struct {
				// BaseVolume Базовый объем(в выбранном типе объема)
				BaseVolume *int `json:"base_volume,omitempty"`

				// BaseVolumeName Название базового минимального объема
				BaseVolumeName *string `json:"base_volume_name,omitempty"`

				// BaseVolumePrice Стоимость базового объема
				BaseVolumePrice *int `json:"base_volume_price,omitempty"`

				// MaxVolume Максимальный объем заказа(в выбранном типе объема)
				MaxVolume *int `json:"max_volume,omitempty"`

				// MinDays Количество дней на выполнение минимального объема заказа.
				MinDays *int `json:"min_days,omitempty"`

				// VolumeLabel Текст количество х, где х - объем в нужном склонении
				VolumeLabel *string `json:"volume_label,omitempty"`

				// VolumeTypeId Идентификатор выбранного типа объема
				VolumeTypeId *int `json:"volume_type_id,omitempty"`

				// VolumeTypes Возможные типы объемов для кворка
				VolumeTypes *[]struct {
					// ContainsId Единица объема для contains_value
					ContainsId *int `json:"contains_id,omitempty"`

					// ContainsValue Количество в других единицах (contains_id)
					ContainsValue *int `json:"contains_value,omitempty"`

					// Id Идентификатор типа объема
					Id *int `json:"id,omitempty"`

					// Name Наименование в единственном числе
					Name *string `json:"name,omitempty"`

					// NameAccusative Наименование в винительном падеже
					NameAccusative *string `json:"name_accusative,omitempty"`

					// NamePlural1119 Наименование во множественном числе, от 11 до 19
					NamePlural1119 *string `json:"name_plural_11_19,omitempty"`

					// NamePlural24 Наименование во множественном числе, от 2 до 4
					NamePlural24 *string `json:"name_plural_2_4,omitempty"`

					// NameShort Сокращенное наименование
					NameShort *string `json:"name_short,omitempty"`
				} `json:"volume_types,omitempty"`
			} `json:"unit_and_quantity,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkDetailsExtraResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// KworkRatings Оценки
			KworkRatings *struct {
				// Communication Коммуникация
				Communication *float32 `json:"communication,omitempty"`

				// Quality Качество
				Quality *float32 `json:"quality,omitempty"`

				// Speed Скорость
				Speed *float32 `json:"speed,omitempty"`
			} `json:"kwork_ratings,omitempty"`

			// LastReviews Последние 3 отзыва
			LastReviews *[]struct {
				// Answer Ответ на отзыв
				Answer *struct {
					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// Profilepicture Аватар
					Profilepicture *string `json:"profilepicture,omitempty"`

					// Text Текст
					Text *string `json:"text,omitempty"`

					// TimeAdded Когда был добавлен ответ (timestamp)
					TimeAdded *int `json:"time_added,omitempty"`

					// UserId Идентификатор пользователя
					UserId *int `json:"user_id,omitempty"`

					// Username Имя пользователя
					Username *string `json:"username,omitempty"`
				} `json:"answer,omitempty"`

				// Bad Плохой отзыв
				Bad *bool `json:"bad,omitempty"`

				// Good Хороший отзыв
				Good *bool `json:"good,omitempty"`

				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Text Текст отзыва
				Text *string `json:"text,omitempty"`

				// TimeAdded Когда был добавлен (timestamp)
				TimeAdded *int `json:"time_added,omitempty"`

				// Writer Автор отзыва
				Writer *struct {
					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// Profilepicture Аватар
					Profilepicture *string `json:"profilepicture,omitempty"`

					// Username Имя пользователя
					Username *string `json:"username,omitempty"`
				} `json:"writer,omitempty"`
			} `json:"last_reviews,omitempty"`

			// LinksSites Ссылки кворка
			LinksSites *[]KworkLinkSiteItem `json:"links_sites,omitempty"`

			// LinksSitesCount Кол-во ссылок кворка
			LinksSitesCount *int `json:"links_sites_count,omitempty"`

			// LinksSitesV2 Ссылки кворка (новый формат)
			LinksSitesV2 *struct {
				// LinkHeaders Загаловки для табилцы ссылок
				LinkHeaders *[]string `json:"link_headers,omitempty"`

				// LinksContent Данные для таблицы ссылок
				LinksContent *[]KworkLinkSiteItem `json:"links_content,omitempty"`
			} `json:"links_sites_v2,omitempty"`

			// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
			NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

			// OtherKworks Другие кворки пользователя
			OtherKworks *[]KworkInList `json:"other_kworks,omitempty"`

			// RecommendedKworks Рекомендуемые кворки
			RecommendedKworks *[]KworkInList `json:"recommended_kworks,omitempty"`

			// ReviewsCount Кол-во отзывов кворка
			ReviewsCount *int `json:"reviews_count,omitempty"`

			// SimilarKworks Похожие кворки
			SimilarKworks *[]KworkInList `json:"similar_kworks,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkDetailsExtraResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkDetailsExtraResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkLinksTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Ссылки кворка
		Response *[]KworkLinkSiteItem `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkLinksTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkLinksTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkLinksTablev2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Ссылки кворка
		Response *struct {
			// LinkHeaders Загаловки для табилцы ссылок
			LinkHeaders *[]string `json:"link_headers,omitempty"`

			// LinksContent Данные для таблицы ссылок
			LinksContent *[]KworkLinkSiteItem `json:"links_content,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkLinksTablev2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkLinksTablev2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkPortfoliosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Работы портфолио
		Response *[]ProfilePortfolios `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkPortfoliosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkPortfoliosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKworkReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Отзывы
		Response *[]struct {
			// Answer Ответ продавца на отзыв
			Answer *UserAnswer `json:"answer,omitempty"`

			// Bad Отрицательный ли отзыв
			Bad *string `json:"bad,omitempty"`

			// Good Положительный ли отзыв
			Good *string `json:"good,omitempty"`

			// Id Идентификатор отзыва
			Id *int `json:"id,omitempty"`

			// Text Отзыв
			Text *string `json:"text,omitempty"`

			// TimeAdded Дата создания
			TimeAdded *int `json:"time_added,omitempty"`

			// Writer Краткие данные автора отзыва
			Writer *UserReviewWriter `json:"writer,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKworkReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKworkReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderCancellationReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]CancelReason `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderCancellationReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderCancellationReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]OrderDetails `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *[]struct {
			// CloudUrl Имя в файлохранидище
			CloudUrl *string `json:"cloudUrl,omitempty"`

			// Date Дата создания файла
			Date *int `json:"date,omitempty"`

			// EntityType Тип файла
			EntityType *string `json:"entity_type,omitempty"`

			// Fname Имя файла
			Fname *string `json:"fname,omitempty"`

			// Id Идентификатор файла
			Id *int `json:"id,omitempty"`

			// MiniatureUrl Ссылка на картинку миниатюру
			MiniatureUrl *string `json:"miniature_url,omitempty"`

			// Owner Отправлялся ли файл текущим пользователем
			Owner *bool `json:"owner,omitempty"`

			// Size Размер
			Size *int `json:"size,omitempty"`

			// Url Ссылка на файл
			Url *string `json:"url,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderHeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]OrderHeader `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderHeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderHeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderProvidedDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]OrderProvidedData `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOrderProvidedDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderProvidedDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderedExtrasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Count Количество
			Count *int `json:"count,omitempty"`

			// Duration Продолжительность
			Duration *int `json:"duration,omitempty"`

			// ExtraId ИД опции
			ExtraId *int `json:"extra_id,omitempty"`

			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// IsDeletingRequested Есть ли запрос на удаление (85 трек)
			IsDeletingRequested *bool `json:"is_deleting_requested,omitempty"`

			// Name Название
			Name *string `json:"name,omitempty"`

			// Price Цена заказа
			Price *float32 `json:"price,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrderedExtrasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderedExtrasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayerCompanyModalUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Ссылка
		Response *string `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPayerCompanyModalUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayerCompanyModalUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// Currency Валюта
			Currency *string `json:"currency,omitempty"`

			// PaymentTypeAvailableCollection Доступные типы оплаты для пользователя с вложенной структурой
			PaymentTypeAvailableCollection *[]PaymentType `json:"payment_type_available_collection,omitempty"`

			// ServiceFeeFixed Фиксированная сумма, прибавляемая к комиссии для типа percent_and_fixed
			ServiceFeeFixed *int `json:"service_fee_fixed,omitempty"`

			// ServiceFeeMin Фиксированная минимальная сумма сервисного сбора для типа min_or_percent, которая считается до service_fee_min_percent_sum
			ServiceFeeMin *int `json:"service_fee_min,omitempty"`

			// ServiceFeeMinPercentSum Минимальная сумма, после которой считается процент от суммы для типа min_or_percent
			ServiceFeeMinPercentSum *int `json:"service_fee_min_percent_sum,omitempty"`

			// ServiceFeePercent Процент сервисного сбора, берется всегда для типа percent_and_fixed и если сумма выше service_fee_min_percent_sum для типа min_or_percent
			ServiceFeePercent *float32 `json:"service_fee_percent,omitempty"`

			// ServiceFeePercentLevels Уровни комиссий
			ServiceFeePercentLevels *[]struct {
				// From Сумма от
				From *int `json:"from,omitempty"`

				// Percent Комиссия
				Percent *float32 `json:"percent,omitempty"`
			} `json:"service_fee_percent_levels,omitempty"`

			// ServiceFeeType Тип расчета комиссии. Возможные варианты: min_or_percent, percent_and_fixed
			ServiceFeeType *string `json:"service_fee_type,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityUserDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ConfirmationType Тип уведомления call/sms/digits
			ConfirmationType *string `json:"confirmation_type,omitempty"`

			// Email email пользователя
			Email *string `json:"email,omitempty"`

			// IsAvailableKworkCreation Может ли пользователь создавать кворки
			IsAvailableKworkCreation *bool `json:"is_available_kwork_creation,omitempty"`

			// IsProfileCompleted Данные
			IsProfileCompleted *struct {
				// Details Заполнено ли поле `О себе`
				Details *bool `json:"details,omitempty"`

				// Profession Заполнено ли поле `Профессия`
				Profession *bool `json:"profession,omitempty"`

				// ProfilePic Заполнено ли поле `Аватар`
				ProfilePic *bool `json:"profile_pic,omitempty"`
			} `json:"is_profile_completed,omitempty"`

			// Phone Телефон пользователя
			Phone *string `json:"phone,omitempty"`

			// TelegramBotLink Ссылка для Telegram
			TelegramBotLink *string `json:"telegram_bot_link,omitempty"`

			// Username Имя пользователя
			Username *string `json:"username,omitempty"`

			// UsernameChangeAvailable Дата, с которой можно менять логин
			UsernameChangeAvailable *int `json:"username_change_available,omitempty"`

			// UsernameChanged Был ли изменен логин
			UsernameChanged *bool `json:"username_changed,omitempty"`

			// WhatsappLink Ссылка для WhatsApp
			WhatsappLink *string `json:"whatsapp_link,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSecurityUserDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityUserDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscribersStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Count Количество
			Count *int `json:"count,omitempty"`

			// Date Дата
			Date *string `json:"date,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSubscribersStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscribersStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Messages Массив элементов чата
			Messages *[]Track `json:"messages,omitempty"`

			// Review Блок отзывов и ответов на них
			Review *struct {
				// Answer Ответ на отзыв
				Answer *struct {
					// Actions Доступное действия
					Actions *struct {
						// Id Идентификатор действия
						Id *string `json:"id,omitempty"`
					} `json:"actions,omitempty"`

					// IsUnread Прочитан ли ответ на отзыв
					IsUnread *bool `json:"is_unread,omitempty"`

					// ModerationStatus Статус модерации (new - на модерации, active - видно всем, reject - отклонен)
					ModerationStatus *string `json:"moderation_status,omitempty"`

					// Review Ответ
					Review *string `json:"review,omitempty"`

					// SentTimestamp Время отправки UnixTime
					SentTimestamp *int `json:"sent_timestamp,omitempty"`

					// Title Название
					Title *string `json:"title,omitempty"`
				} `json:"answer,omitempty"`

				// Review Отзыв
				Review *struct {
					// Actions Действия
					Actions *[]string `json:"actions,omitempty"`

					// AutoMode Автоотзыв, если был
					AutoMode *string `json:"auto_mode,omitempty"`

					// IsUnread Прочитан ли отзыв
					IsUnread *bool `json:"is_unread,omitempty"`

					// Review Отзыв
					Review *string `json:"review,omitempty"`

					// SentTimestamp Время отправки UnixTime
					SentTimestamp *int `json:"sent_timestamp,omitempty"`

					// Title Название
					Title *string `json:"title,omitempty"`

					// Type Положительный/отрицательный
					Type *string `json:"type,omitempty"`
				} `json:"review,omitempty"`
			} `json:"review,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// AboutMeText Текст о себе
			AboutMeText *string `json:"about_me_text,omitempty"`

			// AchievmentsList Бейдж пользователя
			AchievmentsList *ProfileBadges `json:"achievments_list,omitempty"`

			// AvatarPath Путь к изображению аватара
			AvatarPath *string `json:"avatar_path,omitempty"`

			// BadReviews Количество отрицательных отзывов
			BadReviews *int `json:"bad_reviews,omitempty"`

			// CompletedOrdersCount Количество выполненных заказов
			CompletedOrdersCount *int `json:"completed_orders_count,omitempty"`

			// CompletedOrdersPercent Процент успешно сданных заказов
			CompletedOrdersPercent *int `json:"completed_orders_percent,omitempty"`

			// CoverPath Путь к баннеру пользователя
			CoverPath *string `json:"cover_path,omitempty"`

			// Fullname Настоящее имя
			Fullname *string `json:"fullname,omitempty"`

			// GoodReviews Количество положительных отзывов
			GoodReviews *int `json:"good_reviews,omitempty"`

			// Id Идентификатор пользователя
			Id *int `json:"id,omitempty"`

			// InTimeCompletedOrdersPercent Процент сданных вовремя заказов
			InTimeCompletedOrdersPercent *int `json:"in_time_completed_orders_percent,omitempty"`

			// IsCashlessPaymentAvailable Может ли работать по эскроу схеме
			IsCashlessPaymentAvailable *bool `json:"is_cashless_payment_available,omitempty"`

			// IsOnline Онлайн ли пользователь
			IsOnline *bool `json:"is_online,omitempty"`

			// IsVerifiedWorker Верифицирован ли по паспорту или по адресу
			IsVerifiedWorker *bool `json:"is_verified_worker,omitempty"`

			// KworksCount Кол-во кворков актора
			KworksCount *int `json:"kworks_count,omitempty"`

			// LastOnlineTimestamp Дата последней активности на сайте
			LastOnlineTimestamp *int `json:"last_online_timestamp,omitempty"`

			// Note Заметка о пользователе
			Note *struct {
				// PostedTimestamp Дата публикации
				PostedTimestamp *int `json:"posted_timestamp,omitempty"`

				// Text Текст заметки
				Text *int `json:"text,omitempty"`
			} `json:"note,omitempty"`

			// Profession Специальность пользователя
			Profession *string `json:"profession"`

			// RepeatedOrdersPercent Процент повторных заказов
			RepeatedOrdersPercent *int `json:"repeated_orders_percent,omitempty"`

			// ReviewsCount Общее количество отзывов
			ReviewsCount *int `json:"reviews_count,omitempty"`

			// Skills Навыки
			Skills *[]struct {
				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`
			} `json:"skills,omitempty"`

			// Username Имя пользователя
			Username *string `json:"username,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersLastOrderInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// EndDay День месяца завершения заказа
			EndDay *string `json:"endDay,omitempty"`

			// EndMonth Месяц завершения заказа
			EndMonth *string `json:"endMonth,omitempty"`

			// EndYear Год завершения заказа
			EndYear *string `json:"endYear,omitempty"`

			// Interlocutor Username собеседника
			Interlocutor *string `json:"interlocutor,omitempty"`

			// OrderId Идентификатор заказа
			OrderId *int `json:"orderId,omitempty"`

			// StartDay День месяца создания заказа
			StartDay *string `json:"startDay,omitempty"`

			// StartMonth Месяц создания заказа
			StartMonth *string `json:"startMonth,omitempty"`

			// StartTime Дата создания заказа (предложения) unixtime
			StartTime *int `json:"startTime,omitempty"`

			// StartYear Год создания заказа
			StartYear *string `json:"startYear,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUsersLastOrderInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersLastOrderInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceMessageConvertStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVoiceMessageConvertStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceMessageConvertStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceMessageTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVoiceMessageTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceMessageTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWantsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Count Количество найденных проектов
			Count   *int `json:"count,omitempty"`
			Filters *struct {
				ByBudget *[]BudgetWithCount `json:"by_budget,omitempty"`
				Offers   *[]KworksWithCount `json:"offers,omitempty"`
			} `json:"filters,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetWantsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWantsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ExpiresAt Срок жизни токена (UNIX timestamp)
			ExpiresAt *int `json:"expires_at,omitempty"`

			// Token Авторизационный токен
			Token *string `json:"token,omitempty"`

			// Url URL для входа в веб версию (с токеном)
			Url *string `json:"url,omitempty"`

			// UrlToRedirect URL, куда будет произведен редирект после входа в веб. Если указан NULL, будет производится редирект на главную.
			UrlToRedirect *int `json:"url_to_redirect,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetWebAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HideDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Сообщение
		Message *string `json:"message,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`

		// UnhideAvailableSecs Количество секунд в течение которых можно востановить диалог
		UnhideAvailableSecs *int `json:"unhide_available_secs,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HideDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HideDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HideSelfEmployedNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HideSelfEmployedNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HideSelfEmployedNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HideVoiceMessageSettingsPopupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HideVoiceMessageSettingsPopupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HideVoiceMessageSettingsPopupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxComplainMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxComplainMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxComplainMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ConversationId Сквозной идентификатор сообщения или трека
			ConversationId *int `json:"conversation_id,omitempty"`

			// Id Идентификатор сообщения или трека
			Id *int `json:"id,omitempty"`

			// MassMailingNotification Необходимо ли вывести предупреждение о приближении к лимитам сообщений
			MassMailingNotification *bool `json:"mass_mailing_notification,omitempty"`

			// Page Номер страницы где находится сообщения
			Page *int `json:"page,omitempty"`

			// Time Дата сообщения UNIXTIME
			Time *int `json:"time,omitempty"`

			// Type Тип созданного сообщения
			Type *InboxCreate200ResponseType `json:"type,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *struct {
		// Error Текст ошибки
		Error *string `json:"error,omitempty"`

		// ErrorCode Код ошибки
		ErrorCode *int `json:"error_code,omitempty"`

		// Response Данные
		Response *struct {
			// ExpireTime Количество секунд до снятия ограничения
			ExpireTime *int `json:"expire_time,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}
type InboxCreate200ResponseType string

// Status returns HTTPResponse.Status
func (r InboxCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxCustomRequestDeclineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxCustomRequestDeclineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxCustomRequestDeclineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Files Массив информации по файлам
			Files *[]struct {
				// NewFileId Идентификатор пересланного файла
				NewFileId *int `json:"new_file_id,omitempty"`

				// OldFileId Идентификатор старого  файла
				OldFileId *int `json:"old_file_id,omitempty"`
			} `json:"files"`

			// NewMessageId Идентификатор пересланного сообщения
			NewMessageId *int `json:"new_message_id,omitempty"`

			// OldMessageId Идентификатор пересылаемого сообщения
			OldMessageId *int `json:"old_message_id,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]GetMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxPayerDeclineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxPayerDeclineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxPayerDeclineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxTrackMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]GetMessageWithTrack `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxTrackMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxTrackMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxWorkerDeclineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxWorkerDeclineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxWorkerDeclineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]InboxMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsDialogAllowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные о разрешение диалога
		Response *struct {
			// CurrentUserTime Текущее время получателя
			CurrentUserTime *int `json:"currentUserTime,omitempty"`

			// HasDialog Наличие диалога с получателем
			HasDialog *bool `json:"hasDialog,omitempty"`

			// IsDaytime День ли сейчас в получателя
			IsDaytime *bool `json:"isDaytime,omitempty"`

			// IsOnline Онлайн ли получатель
			IsOnline *bool `json:"isOnline,omitempty"`

			// IsPageNeedSmsVerification Нужна ли верификация по СМС для отправки сообщения на этой странице
			IsPageNeedSmsVerification *bool `json:"isPageNeedSmsVerification,omitempty"`

			// IsSmsVerified Верифицирован ли по смс текущий пользователь
			IsSmsVerified *bool `json:"isSmsVerified,omitempty"`

			// PrivateMessageStatus Текущий код разрешения диалога
			PrivateMessageStatus *int `json:"privateMessageStatus,omitempty"`

			// PrivateMessageStatuses Возможные коды причин запрета переписки
			PrivateMessageStatuses *map[string]interface{} `json:"privateMessageStatuses,omitempty"`

			// ReceivedLastOnline Метка времени получателя последнего статуса онлайн
			ReceivedLastOnline *int `json:"receivedLastOnline,omitempty"`

			// ResponseTime Показатель отвечает за в строковом представлении
			ResponseTime *string `json:"responseTime,omitempty"`

			// ShowInboxAllowModal Флаг необходимости показа окна разрешения отправки
			ShowInboxAllowModal *bool `json:"showInboxAllowModal,omitempty"`

			// UserUtcOffset Разница во временной зоне между UTC и получателем
			UserUtcOffset *int `json:"userUtcOffset,omitempty"`

			// UtcOffset Разница во временной зоне между отправителем и получателем
			UtcOffset *int `json:"utcOffset,omitempty"`

			// WorkTime Информация по рабочему времени получателя
			WorkTime *string `json:"workTime,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IsDialogAllowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsDialogAllowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Kworks Кворки
		Kworks *[]KworkInListWithWorkerLevel `json:"kworks,omitempty"`

		// Response Данные
		Response *struct {
			// Classifiers Вложенные классификаторы
			Classifiers *[]struct {
				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// IsCatalogItem Это элемент каталога или классификация(аттрибут)?
				IsCatalogItem *bool `json:"isCatalogItem,omitempty"`

				// KworksCount Количество кворков внутри классификатора
				KworksCount *int `json:"kworks_count,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`

				// Visibility Видимость:1-всем, 2-только продавцам, 3-виден всем в в панели поиска, но не на странице кворка
				Visibility *int `json:"visibility,omitempty"`
			} `json:"classifiers,omitempty"`

			// KworksCount Количество кворков
			KworksCount *int `json:"kworks_count,omitempty"`

			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r KworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KworksCategoriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Id Идентификатор категории
			Id *int `json:"id,omitempty"`

			// Kworks Кворки пользователя
			Kworks *ProfileKworksWithWorkerLevel `json:"kworks,omitempty"`

			// KworksCount Количество активных кворков в категории
			KworksCount *int `json:"kworks_count,omitempty"`

			// Name Название категории
			Name *string `json:"name,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r KworksCategoriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KworksCategoriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type KworksStatusListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// Kworks Кворк пользователя
			Kworks *ProfileKwork `json:"kworks,omitempty"`

			// KworksCount Количество кворков в группе
			KworksCount *int `json:"kworks_count,omitempty"`

			// Name Название группы
			Name *string `json:"name,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r KworksStatusListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r KworksStatusListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkInboxTracksAsReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarkInboxTracksAsReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkInboxTracksAsReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkKworkAsFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MarkKworkAsFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkKworkAsFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkKworkAsHiddenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarkKworkAsHiddenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkKworkAsHiddenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkKworksBlackFridayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// BlackFridayPrice цена кворка в период ЧП
			BlackFridayPrice *int `json:"black_friday_price,omitempty"`

			// DiscountPercentage размер скидки для бейджа
			DiscountPercentage *int `json:"discount_percentage,omitempty"`

			// IsBlackFriday участвует ли кворк в ЧП
			IsBlackFriday *bool `json:"is_black_friday,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarkKworksBlackFridayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkKworksBlackFridayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkVoiceMessageHeardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarkVoiceMessageHeardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkVoiceMessageHeardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MiniatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MiniatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MiniatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MyWantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]WantPayer `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MyWantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MyWantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Сгруппированные по типам уведомления
		Response *[]NotificationType `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r NotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsFetchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Push-события
		Response *[]PushEvent `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r NotificationsFetchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsFetchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationsReceivedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r NotificationsReceivedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationsReceivedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Предложение на запрос услуги на бирже
		Response *Offer `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OfferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfferOrderOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Messages Массив элементов чата
			Messages *[]Track `json:"messages,omitempty"`

			// User Данные о собеседнике
			User *Interlocutor `json:"user,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OfferOrderOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfferOrderOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OffersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Connects Объект с коннектами
		Connects *Connects `json:"connects,omitempty"`

		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]Offer `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OffersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OffersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfflineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OfflineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfflineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// Order Данные заказа
			Order *struct {
				// Id Идентификатор заказа
				Id *int `json:"id,omitempty"`

				// KworkTitle Название заказа для пользователя
				KworkTitle *string `json:"kwork_title,omitempty"`
			} `json:"order,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrderKworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// OrderId Идентификатор созданного заказа
			OrderId *int `json:"orderId,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *BalanceDeficit
}

// Status returns HTTPResponse.Status
func (r OrderKworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrderKworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrderStageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OrderStageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrderStageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrdersBetweenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Id Идентификатор заказа
			Id *int `json:"id,omitempty"`

			// KworkTitle Название заказа
			KworkTitle *string `json:"kwork_title,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OrdersBetweenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrdersBetweenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseKworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PauseKworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseKworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayOrderAwaitingPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PayOrderAwaitingPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayOrderAwaitingPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayerBuyExtrasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *BalanceDeficit
}

// Status returns HTTPResponse.Status
func (r PayerBuyExtrasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayerBuyExtrasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayerDeclineExtrasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PayerDeclineExtrasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayerDeclineExtrasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayerDeclinesExtraRemovalRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PayerDeclinesExtraRemovalRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayerDeclinesExtraRemovalRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayerExtraDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PayerExtraDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayerExtraDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayerOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Filter Выбранный фильтр
			Filter *string `json:"filter,omitempty"`

			// FilterCounts Объект количеств по статусам
			FilterCounts *struct {
				// Active Количество заказов по фильтру active
				Active *int `json:"active,omitempty"`

				// All Общее количество заказов
				All *int `json:"all,omitempty"`

				// Cancelled Количество заказов по фильтру cancelled
				Cancelled *int `json:"cancelled,omitempty"`

				// Completed Количество заказов по фильтру completed
				Completed *int `json:"completed,omitempty"`

				// Delivered Количество заказов по фильтру delivered
				Delivered *int `json:"delivered,omitempty"`
			} `json:"filter_counts,omitempty"`

			// Orders Массив объектов - заказов
			Orders *struct {
				// CanAddReview Можно добавить отзыв
				CanAddReview *bool `json:"can_add_review,omitempty"`

				// CanRepeatOrder Можно ли заказать еще
				CanRepeatOrder *bool `json:"can_repeat_order,omitempty"`

				// CanсelReason Причина отмены заказа
				CanсelReason *string `json:"canсel_reason,omitempty"`

				// Deadline Время дедлайна заказа UNIXTIME
				Deadline *int `json:"deadline,omitempty"`

				// DisplayTime Время для показа заказа UNIXTIME, При фильтре Выполненные - дата сдачи заказа на проверку (она же дата выполнения), При фильтре Отмененные - дата отмены заказа, В остальных случаях - дата создания заказа
				DisplayTime *int `json:"display_time,omitempty"`

				// DisplayTitle Пользовательское название заказа
				DisplayTitle *string `json:"display_title,omitempty"`

				// HasCompletedStages Есть ли выполненные этапы
				HasCompletedStages *bool `json:"has_completed_stages,omitempty"`

				// HasStages Содержит ли заказ этапы
				HasStages *bool `json:"has_stages,omitempty"`

				// Id Идентификатор заказа
				Id *int `json:"id,omitempty"`

				// InWork Взят в работу
				InWork *bool `json:"in_work,omitempty"`

				// IsCancelRequest Заказ в состоянии запроса отмены (показывать сколько времени осталось на выполнение не нужно) Только для заказов в статусе 1 - В работе
				IsCancelRequest *bool `json:"is_cancel_request,omitempty"`

				// KworkId Идентификатор кворка
				KworkId *int `json:"kwork_id,omitempty"`

				// KworkTitle Название кворка
				KworkTitle *string `json:"kwork_title,omitempty"`

				// MissingData Данные не предоставлены
				MissingData *bool `json:"missing_data,omitempty"`

				// OrderNote Заметка о заказе
				OrderNote *string `json:"order_note,omitempty"`

				// PaymentType Тип заказа: 0 - физлицо, 1 - подписка, 2 - эскроу
				PaymentType *int `json:"payment_type,omitempty"`

				// Photo Путь к обложке кворка
				Photo *string `json:"photo,omitempty"`

				// Price Цена
				Price *float32 `json:"price,omitempty"`

				// Progress Прогресс выполнения работ по заказу
				Progress *int `json:"progress,omitempty"`

				// Project Запрос
				Project *string `json:"project,omitempty"`

				// StagesPrice Цена за все этапы
				StagesPrice *float32 `json:"stages_price,omitempty"`

				// Status Статус заказа 	1 - В работе, 2 - Арбитраж, 3 - Отменен, 4 - На проверке, 5 - Выполнен, 6 - Требуется оплата
				Status *int `json:"status,omitempty"`

				// StatusVirtual Виртуальный статус заказа
				StatusVirtual *int `json:"statusVirtual,omitempty"`

				// TimeAdded Дата заказа UNIXTIME
				TimeAdded *int `json:"time_added,omitempty"`

				// UnreadTracks Количество непрочитанных сообщений в заказе
				UnreadTracks *int `json:"unread_tracks,omitempty"`

				// Worker Объект данных продавца
				Worker *struct {
					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// IsOnline Онлайн ли пользователь
					IsOnline *bool `json:"is_online,omitempty"`

					// Profilepicture Ссылка на изображение аватара
					Profilepicture *string `json:"profilepicture,omitempty"`

					// Username Имя пользователя
					Username *string `json:"username,omitempty"`
				} `json:"worker,omitempty"`

				// YescrowPaymentNotAvailable Бензнал Эскроу больше не доступен
				YescrowPaymentNotAvailable *bool `json:"yescrowPaymentNotAvailable,omitempty"`
			} `json:"orders,omitempty"`

			// Paging Объект данных пагинации
			Paging *struct {
				// Limit Количество элементов на странице
				Limit *int `json:"limit,omitempty"`

				// Page Текущая страница
				Page *int `json:"page,omitempty"`

				// Total Общее количество заказов по текущему фильтру
				Total *int `json:"total,omitempty"`
			} `json:"paging,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PayerOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayerOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayerUpgradePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *BalanceDeficit
}

// Status returns HTTPResponse.Status
func (r PayerUpgradePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayerUpgradePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PortfolioCategoriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Id Идентификатор категории
			Id *int `json:"id,omitempty"`

			// Name Название категории
			Name *string `json:"name,omitempty"`

			// PortfolioCount Количество работ в категории
			PortfolioCount *int `json:"portfolio_count,omitempty"`

			// PortfolioList Портфолио пользователя
			PortfolioList *ProfilePortfolios `json:"portfolio_list,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PortfolioCategoriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PortfolioCategoriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PortfolioListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Paging Информация о пагинации
			Paging *struct {
				// Limit Количество элементов на странице
				Limit *int `json:"limit,omitempty"`

				// Page Номер страницы
				Page *int `json:"page,omitempty"`

				// Pages Всего страниц
				Pages *int `json:"pages,omitempty"`

				// Total Всего портфолио
				Total *int `json:"total,omitempty"`
			} `json:"paging,omitempty"`

			// Portfolio Портфолио пользователя
			Portfolio *ProfilePortfolios `json:"portfolio,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PortfolioListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PortfolioListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PositiveReviewsCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Количество отзывов => Количество кворков с таким количество отзывов
		Response *PositiveReviewsCount `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PositiveReviewsCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PositiveReviewsCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrivacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimpleHtml
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PrivacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrivacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Connects Объект с коннектами
		Connects *Connects `json:"connects,omitempty"`

		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]WantWorker `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushInAppNotificationLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PushInAppNotificationLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushInAppNotificationLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RateArbitrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RateArbitrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RateArbitrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RechargeBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// PaymentUrlWebView Ссылка оплаты в WebView
			PaymentUrlWebView *string `json:"paymentUrlWebView,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RechargeBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RechargeBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterCloudTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RegisterCloudTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterCloudTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectCancelOrderRequestByPayerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RejectCancelOrderRequestByPayerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectCancelOrderRequestByPayerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectCancelOrderRequestByWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RejectCancelOrderRequestByWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectCancelOrderRequestByWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectStageSuggestionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RejectStageSuggestionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectStageSuggestionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepeatOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// OrderId Идентификатор созданного заказа
			OrderId *int `json:"orderId,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *BalanceDeficit
}

// Status returns HTTPResponse.Status
func (r RepeatOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepeatOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportAppVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ReportAppVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportAppVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestPhoneChangingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Hash Валидационный кеш
			Hash *string `json:"hash,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RequestPhoneChangingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestPhoneChangingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimpleHtml
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ResolutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartWantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RestartWantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartWantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveOrderNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SaveOrderNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveOrderNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SaveUserNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Classifiers Вложенные классификаторы
		Classifiers *[]struct {
			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// IsCatalogItem Это элемент каталога или классификация(аттрибут)?
			IsCatalogItem *bool `json:"isCatalogItem,omitempty"`

			// KworksCount Количество кворков внутри классификатора
			KworksCount *int `json:"kworks_count,omitempty"`

			// Name Название
			Name *string `json:"name,omitempty"`

			// Visibility Видимость:1-всем, 2-только продавцам, 3-виден всем в в панели поиска, но не на странице кворка
			Visibility *int `json:"visibility,omitempty"`
		} `json:"classifiers,omitempty"`

		// Paging Данные пагинации
		Paging *[]struct {
			// Limit Количество кворков на странице
			Limit *int `json:"limit,omitempty"`

			// Page Номер текущей страницы
			Page *int `json:"page,omitempty"`

			// Total Общее количество кворков
			Total *int `json:"total,omitempty"`
		} `json:"paging,omitempty"`

		// Response Найденные кворки
		Response *[]ProfileKworksWithWorkerLevel `json:"response,omitempty"`

		// SearchCategories Категории и количество результатов
		SearchCategories *[]struct {
			// Category ID
			Category *int `json:"category,omitempty"`

			// Count Количество записей
			Count *int `json:"count,omitempty"`

			// Name Название категории
			Name *string `json:"name,omitempty"`
		} `json:"searchCategories,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDialogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации
		Paging *Paging `json:"paging,omitempty"`

		// Response Массив объектов сообщений
		Response *[]DialogMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchDialogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDialogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchInboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]InboxMessage `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchInboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchInboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchKworksCatalogQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Найденные фразы
		Response *[]map[string]interface{} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchKworksCatalogQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchKworksCatalogQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]struct {
			// ConversationId conversation_id
			ConversationId *int `json:"conversation_id,omitempty"`

			// Id id сообщения
			Id *int `json:"id,omitempty"`

			// Phrase Найденное слово
			Phrase *string `json:"phrase,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchOrderTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Данные
		Response *[]struct {
			// ConversationId conversation_id
			ConversationId *int `json:"conversation_id,omitempty"`

			// Id id сообщения
			Id *int `json:"id,omitempty"`

			// Phrase Найденное слово
			Phrase *string `json:"phrase,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchOrderTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchOrderTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Идентификаторы треков
		Response *[]int `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendBonusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *struct {
		// Response Массив с данными
		Response *struct {
			// Amount Сумма пополнения без комиссии, если не хватает средств
			Amount *int `json:"amount,omitempty"`

			// Error Текст ошибки
			Error *string `json:"error,omitempty"`

			// ErrorCode Код ошибки
			ErrorCode *int `json:"error_code,omitempty"`

			// PaymentTypeAvailable Доступные типы оплаты для пользователя
			PaymentTypeAvailable *map[string]interface{} `json:"payment_type_available,omitempty"`

			// PaymentUrl Ссылка на платежную систему для пополнения на необходимую сумму
			PaymentUrl *string `json:"payment_url,omitempty"`

			// ServiceFeeMin Фиксированная минимальная сумма сервисного сбора, которая считается до service_fee_min_percent_sum
			ServiceFeeMin *int `json:"service_fee_min,omitempty"`

			// ServiceFeeMinPercentSum Минимальная сумма, после которой считается процент от суммы
			ServiceFeeMinPercentSum *int `json:"service_fee_min_percent_sum,omitempty"`

			// ServiceFeePercent Процент сервисного сбора, если сумма выше service_fee_min_percent_sum
			ServiceFeePercent *float32 `json:"service_fee_percent,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SendBonusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendBonusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendCompanyForVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Результат
		Response *struct {
			// Status 0 – на проверке, 1 – одобрено, 2 – отказано
			Status *int `json:"status,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendCompanyForVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendCompanyForVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendOrderForApprovalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendOrderForApprovalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendOrderForApprovalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendOrderForArbitrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendOrderForArbitrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendOrderForArbitrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendOrderForRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendOrderForRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendOrderForRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendOrderReceiptLinkForVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendOrderReceiptLinkForVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendOrderReceiptLinkForVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendOrderRequirementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendOrderRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendOrderRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// TrackId Идентификатор созданного трека
			TrackId *int `json:"trackId,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendSelfEmployedSurveyResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SendSelfEmployedSurveyResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendSelfEmployedSurveyResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendUserStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendUserStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendUserStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendWhatsAppCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Phone Маска номера телефона, на который отправили код
			Phone *string `json:"phone,omitempty"`

			// Timeout Время через которое можно повторить отправку
			Timeout *int `json:"timeout,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendWhatsAppCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendWhatsAppCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAvailableAtWeekendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetAvailableAtWeekendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAvailableAtWeekendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDialogStarredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Сообщение
		Message *string `json:"message,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetDialogStarredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDialogStarredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFishingTutorialStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности запроса
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetFishingTutorialStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFishingTutorialStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOrderRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetOrderRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOrderRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetTakingOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetTakingOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetTakingOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetUserTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// IsSupportDialogAvailable Флаг открытого общения со службой поддержки
			IsSupportDialogAvailable *bool `json:"is_support_dialog_available,omitempty"`

			// SelfEmployed Информация СЗ/ИП
			SelfEmployed *struct {
				// ShowRegistrationNotification Флаг для отображения успешной регистрации СЗ/ИП
				ShowRegistrationNotification *bool `json:"show_registration_notification,omitempty"`

				// ShowSurveyPopup Флаг для отображения опроса
				ShowSurveyPopup *bool `json:"show_survey_popup,omitempty"`
			} `json:"self_employed,omitempty"`

			// TestGroups Набор тестовых групп пользователя
			TestGroups *[]map[string]bool `json:"test_groups,omitempty"`

			// VoiceMessages Голосовые сообщения
			VoiceMessages *struct {
				// IsVoiceMessageRecordingAvailable Разрешение записывать ГС
				IsVoiceMessageRecordingAvailable *bool `json:"is_voice_message_recording_available,omitempty"`

				// ReceivingSettings Настройки получения ГС
				ReceivingSettings *struct {
					// IsReceivingAllowed Флаг разрешения приема ГС
					IsReceivingAllowed *bool `json:"is_receiving_allowed,omitempty"`

					// IsReceivingSettingAllowed Флаг доступности настройки ГС
					IsReceivingSettingAllowed *bool `json:"is_receiving_setting_allowed,omitempty"`

					// ShouldShowSettingsPopup Флаг показа попапа
					ShouldShowSettingsPopup *bool `json:"should_show_settings_popup,omitempty"`
				} `json:"receiving_settings,omitempty"`

				// SpeedControl Параметры скорости ГС
				SpeedControl *struct {
					// AvailableSpeeds Список допустимых скоростей
					AvailableSpeeds *[]float32 `json:"available_speeds,omitempty"`

					// IsAvailable Разрешение менять скорость
					IsAvailable *bool `json:"is_available,omitempty"`

					// Speed Скорость воспроизведения
					Speed *float32 `json:"speed,omitempty"`
				} `json:"speed_control,omitempty"`
			} `json:"voice_messages,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetUserTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetUserTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVoiceMessageReceivingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetVoiceMessageReceivingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVoiceMessageReceivingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVoiceMessageSpeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// Speed Скорость воспроизведения
			Speed *float32 `json:"speed,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetVoiceMessageSpeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVoiceMessageSpeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignInResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *struct {
		// Error Текст ошибки
		Error *string `json:"error,omitempty"`

		// ErrorCode Код ошибки
		ErrorCode *int `json:"error_code,omitempty"`

		// RecaptchaPassToken Токен для пропуска капчи
		RecaptchaPassToken *string `json:"recaptcha_pass_token,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SignInResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignInResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignUpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SignUpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignUpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialSignInResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SocialSignInResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialSignInResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialSignInByTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SocialSignInByTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialSignInByTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialSignInByTokenv2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SocialSignInByTokenv2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialSignInByTokenv2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialSignUpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SocialSignUpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialSignUpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialSignUpByTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthSuccess
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SocialSignUpByTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialSignUpByTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartKworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Message Активирован или активирован и станет активным после проверки модератором
			Message *string `json:"message,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartKworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartKworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopWantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r StopWantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopWantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuggestStagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SuggestStagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuggestStagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TermsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimpleHtml
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TermsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TermsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TermsOfServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimpleHtml
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TermsOfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TermsOfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimezonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Временные зоны
		Response *[]struct {
			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// Name Название
			Name *string `json:"name,omitempty"`

			// UtcOffset Сдвиг от UTC
			UtcOffset *string `json:"utc_offset,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TimezonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimezonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TrackDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TrackEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]Track `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TrackMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TrackReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TranslationLanguagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Языки для перевода
		Response *map[string]struct {
			// Genitive Название в родительном падеже
			Genitive *string `json:"genitive,omitempty"`

			// Id Идентификатор
			Id *int `json:"id,omitempty"`

			// Nominative Название в именительном падеже
			Nominative *string `json:"nominative,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TranslationLanguagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TranslationLanguagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TypingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TypingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TypingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnarchiveDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnblockDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Message Сообщение об успехе
			Message *string `json:"message,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnblockDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnblockDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnreadDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnreadDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnreadDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChatDraftMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateChatDraftMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChatDraftMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrderDraftMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateOrderDraftMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrderDraftMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Message Сообщение необходимое для вывода пользователю
			Message *string `json:"message,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStageProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// TrackId Идентификатор созданного трека
			TrackId *int `json:"trackId,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateStageProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStageProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Массив с данными
		Response *struct {
			// Src Ссылка на загруженную обложку
			Src *string `json:"src,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPortfolioFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]struct {
			// Hash ИД хеша
			Hash *int `json:"hash,omitempty"`

			// Id ИД файла
			Id *int `json:"id,omitempty"`

			// Path Путь к файлу
			Path *string `json:"path,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadPortfolioFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPortfolioFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadedFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadedFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadedFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Публичные данные пользователя
		Response *User `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserByUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Публичные данные пользователя
		Response *User `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserByUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserByUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserKworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Кворки пользователя
		Response *ProfileKworksWithWorkerLevel `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserKworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserKworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]UserReview `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Найденные пользователи
		Response *[]UserWorker `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyPhoneActivationCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Phone Телефон под маской *** который был добавлен в аккаунт
			Phone *string `json:"phone,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r VerifyPhoneActivationCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyPhoneActivationCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifySmsCodeForAccountDeletingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// ConfirmationType Тип отправления кода подтверждения, sms/email/deleted
			ConfirmationType *string `json:"confirmation_type,omitempty"`

			// Orders Массив заказов если они есть
			Orders *[]struct {
				// Id ID заказа
				Id *int `json:"id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`
			} `json:"orders,omitempty"`

			// Timeout Время задержки перед следующей попыткой в секундах
			Timeout *int `json:"timeout,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r VerifySmsCodeForAccountDeletingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifySmsCodeForAccountDeletingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ViewedCatalogKworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Paging Данные пагинации с лимитом
		Paging *PagingWithPages `json:"paging,omitempty"`

		// Response Кворки пользователя
		Response *ProfileKworks `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ViewedCatalogKworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ViewedCatalogKworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VoiceUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// FileId ИД файла
			FileId *int `json:"fileId,omitempty"`

			// Path Путь до файла
			Path *string `json:"path,omitempty"`

			// VoiceMessageId ИД голосового сообщения
			VoiceMessageId *string `json:"voiceMessageId,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r VoiceUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VoiceUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]WantPayer `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WantsStatusListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *[]WantsList `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WantsStatusListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WantsStatusListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerConfirmsExtraRemovalRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WorkerConfirmsExtraRemovalRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerConfirmsExtraRemovalRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerDeclineExtrasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WorkerDeclineExtrasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerDeclineExtrasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerDeclinesExtraRemovalRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WorkerDeclinesExtraRemovalRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerDeclinesExtraRemovalRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerExtraDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WorkerExtraDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerExtraDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerInprogressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WorkerInprogressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerInprogressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Данные
		Response *struct {
			// Filter Выбранный фильтр
			Filter *string `json:"filter,omitempty"`

			// FilterCounts Объект количеств по статусам
			FilterCounts *struct {
				// Active Количество заказов по фильтру active
				Active *int `json:"active,omitempty"`

				// All Общее количество заказов
				All *string `json:"all,omitempty"`

				// AwaitingReceipt Количество заказов по фильтру awaiting_receipt
				AwaitingReceipt *int `json:"awaiting_receipt,omitempty"`

				// Cancelled Количество заказов по фильтру cancelled
				Cancelled *int `json:"cancelled,omitempty"`

				// Completed Количество заказов по фильтру completed
				Completed *int `json:"completed,omitempty"`

				// Delivered Количество заказов по фильтру delivered
				Delivered *int `json:"delivered,omitempty"`
			} `json:"filter_counts,omitempty"`

			// Orders Массив объектов - заказов
			Orders *struct {
				// CanAddPortfolio Можно загрузить портфолио к заказу
				CanAddPortfolio *bool `json:"can_add_portfolio,omitempty"`

				// CanсelReason Причина отмены заказа
				CanсelReason *string `json:"canсel_reason,omitempty"`

				// Deadline Дата сдачи заказа в UNIXTIME
				Deadline *int `json:"deadline,omitempty"`

				// DisplayTitle Пользовательское название заказа
				DisplayTitle *string `json:"display_title,omitempty"`

				// Duration Время выполнения заказа в секундах
				Duration *int `json:"duration,omitempty"`

				// HasCompletedStages Есть ли выполненные этапы
				HasCompletedStages *bool `json:"has_completed_stages,omitempty"`

				// HasStages Содержит ли заказ этапы
				HasStages *bool `json:"has_stages,omitempty"`

				// Id Идентификатор заказа
				Id *int `json:"id,omitempty"`

				// InWork Взят в работу
				InWork *bool `json:"in_work,omitempty"`

				// IsCancelRequest Заказ в состоянии запроса отмены (показывать сколько времени осталось на выполнение не нужно) Только для заказов в статусе 1 - В работе
				IsCancelRequest *bool `json:"is_cancel_request,omitempty"`

				// KworkTitle Название кворка
				KworkTitle *string `json:"kwork_title,omitempty"`

				// OrderNote Заметка о заказе
				OrderNote *string `json:"order_note,omitempty"`

				// Payer Объект данных заказчика
				Payer *struct {
					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// IsOnline Онлайн ли пользователь
					IsOnline *bool `json:"is_online,omitempty"`

					// Profilepicture Ссылка на изображение аватара
					Profilepicture *string `json:"profilepicture,omitempty"`

					// Username Имя пользователя
					Username *string `json:"username,omitempty"`
				} `json:"payer,omitempty"`

				// PaymentType Тип заказа: 0 - физлицо, 1 - подписка, 2 - эскроу
				PaymentType *int `json:"payment_type,omitempty"`

				// Photo Путь к обложке кворка
				Photo *string `json:"photo,omitempty"`

				// Price Цена
				Price *float32 `json:"price,omitempty"`

				// Progress Прогресс выполнения работ по заказу
				Progress *int `json:"progress,omitempty"`

				// Project Запрос
				Project *string `json:"project,omitempty"`

				// StagesPrice Цена за все этапы
				StagesPrice *float32 `json:"stages_price,omitempty"`

				// Status Статус заказа 	1 - В работе, 2 - Арбитраж, 3 - Отменен, 4 - На проверке, 5 - Выполнен, 6 - Требуется оплата
				Status *int `json:"status,omitempty"`

				// StatusVirtual Виртуальный статус
				StatusVirtual *int `json:"statusVirtual,omitempty"`

				// TimeAdded Дата заказа UNIXTIME
				TimeAdded *int `json:"time_added,omitempty"`

				// TimeCanсel Дата отмены заказа UNIXTIME
				TimeCanсel *int `json:"time_canсel,omitempty"`

				// TimeIsLost 1 - остался час, чтобы взять заказ в работу, так как прошло 23 часа с момента оплаты, 0 - осталось более часа, чтобы взять заказ, так как прошло менее 23 часа с момента оплаты, 1 - все остальные заказы, которые не требуется брать в работу. -2 - заказ не сдан вовремя
				TimeIsLost *int `json:"time_is_lost,omitempty"`

				// TimeLeft Осталось времени, значимо только для заказов в статусе 1 - В работе (Если пусто - Время вышло, 	Если in_work = 1 - Осталось на выполнение заказа, Если in_work = 0 - Осталось до автоотмены заказа)
				TimeLeft *string `json:"time_left,omitempty"`

				// UnreadTracks Количество непрочитанных сообщений в заказе
				UnreadTracks *int `json:"unread_tracks,omitempty"`
			} `json:"orders,omitempty"`

			// Paging Объект данных пагинации
			Paging *struct {
				// Limit Количество элементов на странице
				Limit *int `json:"limit,omitempty"`

				// Page Текущая страница
				Page *int `json:"page,omitempty"`

				// Total Общее количество заказов по текущему фильтру
				Total *int `json:"total,omitempty"`
			} `json:"paging,omitempty"`
		} `json:"response,omitempty"`

		// Success Флаг успешности
		Success *bool `json:"success,omitempty"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WorkerOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AcceptExtrasWithResponse request returning *AcceptExtrasResponse
func (c *ClientWithResponses) AcceptExtrasWithResponse(ctx context.Context, params *AcceptExtrasParams, reqEditors ...RequestEditorFn) (*AcceptExtrasResponse, error) {
	rsp, err := c.AcceptExtras(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptExtrasResponse(rsp)
}

// AcceptStageSuggestionWithResponse request returning *AcceptStageSuggestionResponse
func (c *ClientWithResponses) AcceptStageSuggestionWithResponse(ctx context.Context, params *AcceptStageSuggestionParams, reqEditors ...RequestEditorFn) (*AcceptStageSuggestionResponse, error) {
	rsp, err := c.AcceptStageSuggestion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptStageSuggestionResponse(rsp)
}

// ActorWithBodyWithResponse request with arbitrary body returning *ActorResponse
func (c *ClientWithResponses) ActorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActorResponse, error) {
	rsp, err := c.ActorWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActorResponse(rsp)
}

func (c *ClientWithResponses) ActorWithFormdataBodyWithResponse(ctx context.Context, body ActorFormdataRequestBody, reqEditors ...RequestEditorFn) (*ActorResponse, error) {
	rsp, err := c.ActorWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActorResponse(rsp)
}

// AddFavoriteCategoriesWithResponse request returning *AddFavoriteCategoriesResponse
func (c *ClientWithResponses) AddFavoriteCategoriesWithResponse(ctx context.Context, params *AddFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*AddFavoriteCategoriesResponse, error) {
	rsp, err := c.AddFavoriteCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFavoriteCategoriesResponse(rsp)
}

// AddNewPhoneNumberWithResponse request returning *AddNewPhoneNumberResponse
func (c *ClientWithResponses) AddNewPhoneNumberWithResponse(ctx context.Context, params *AddNewPhoneNumberParams, reqEditors ...RequestEditorFn) (*AddNewPhoneNumberResponse, error) {
	rsp, err := c.AddNewPhoneNumber(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNewPhoneNumberResponse(rsp)
}

// AddPhoneNumberWithResponse request returning *AddPhoneNumberResponse
func (c *ClientWithResponses) AddPhoneNumberWithResponse(ctx context.Context, params *AddPhoneNumberParams, reqEditors ...RequestEditorFn) (*AddPhoneNumberResponse, error) {
	rsp, err := c.AddPhoneNumber(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPhoneNumberResponse(rsp)
}

// AddStageWithResponse request returning *AddStageResponse
func (c *ClientWithResponses) AddStageWithResponse(ctx context.Context, params *AddStageParams, reqEditors ...RequestEditorFn) (*AddStageResponse, error) {
	rsp, err := c.AddStage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddStageResponse(rsp)
}

// AllowInboxRequestWithResponse request returning *AllowInboxRequestResponse
func (c *ClientWithResponses) AllowInboxRequestWithResponse(ctx context.Context, params *AllowInboxRequestParams, reqEditors ...RequestEditorFn) (*AllowInboxRequestResponse, error) {
	rsp, err := c.AllowInboxRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllowInboxRequestResponse(rsp)
}

// AllowMobilePushWithResponse request returning *AllowMobilePushResponse
func (c *ClientWithResponses) AllowMobilePushWithResponse(ctx context.Context, params *AllowMobilePushParams, reqEditors ...RequestEditorFn) (*AllowMobilePushResponse, error) {
	rsp, err := c.AllowMobilePush(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllowMobilePushResponse(rsp)
}

// AllowOrderPortfolioUploadWithResponse request returning *AllowOrderPortfolioUploadResponse
func (c *ClientWithResponses) AllowOrderPortfolioUploadWithResponse(ctx context.Context, params *AllowOrderPortfolioUploadParams, reqEditors ...RequestEditorFn) (*AllowOrderPortfolioUploadResponse, error) {
	rsp, err := c.AllowOrderPortfolioUpload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllowOrderPortfolioUploadResponse(rsp)
}

// AllowPushNotificationsSoundWithResponse request returning *AllowPushNotificationsSoundResponse
func (c *ClientWithResponses) AllowPushNotificationsSoundWithResponse(ctx context.Context, params *AllowPushNotificationsSoundParams, reqEditors ...RequestEditorFn) (*AllowPushNotificationsSoundResponse, error) {
	rsp, err := c.AllowPushNotificationsSound(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllowPushNotificationsSoundResponse(rsp)
}

// AppleSignInWithBodyWithResponse request with arbitrary body returning *AppleSignInResponse
func (c *ClientWithResponses) AppleSignInWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppleSignInResponse, error) {
	rsp, err := c.AppleSignInWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppleSignInResponse(rsp)
}

func (c *ClientWithResponses) AppleSignInWithFormdataBodyWithResponse(ctx context.Context, body AppleSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*AppleSignInResponse, error) {
	rsp, err := c.AppleSignInWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppleSignInResponse(rsp)
}

// ApplyFiltersWithResponse request returning *ApplyFiltersResponse
func (c *ClientWithResponses) ApplyFiltersWithResponse(ctx context.Context, params *ApplyFiltersParams, reqEditors ...RequestEditorFn) (*ApplyFiltersResponse, error) {
	rsp, err := c.ApplyFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyFiltersResponse(rsp)
}

// ApproveOrderWithResponse request returning *ApproveOrderResponse
func (c *ClientWithResponses) ApproveOrderWithResponse(ctx context.Context, params *ApproveOrderParams, reqEditors ...RequestEditorFn) (*ApproveOrderResponse, error) {
	rsp, err := c.ApproveOrder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveOrderResponse(rsp)
}

// ApproveOrderStageWithResponse request returning *ApproveOrderStageResponse
func (c *ClientWithResponses) ApproveOrderStageWithResponse(ctx context.Context, params *ApproveOrderStageParams, reqEditors ...RequestEditorFn) (*ApproveOrderStageResponse, error) {
	rsp, err := c.ApproveOrderStage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveOrderStageResponse(rsp)
}

// ArchiveDialogWithResponse request returning *ArchiveDialogResponse
func (c *ClientWithResponses) ArchiveDialogWithResponse(ctx context.Context, params *ArchiveDialogParams, reqEditors ...RequestEditorFn) (*ArchiveDialogResponse, error) {
	rsp, err := c.ArchiveDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDialogResponse(rsp)
}

// BlockDialogWithResponse request returning *BlockDialogResponse
func (c *ClientWithResponses) BlockDialogWithResponse(ctx context.Context, params *BlockDialogParams, reqEditors ...RequestEditorFn) (*BlockDialogResponse, error) {
	rsp, err := c.BlockDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockDialogResponse(rsp)
}

// BlockedDialogListWithResponse request returning *BlockedDialogListResponse
func (c *ClientWithResponses) BlockedDialogListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedDialogListResponse, error) {
	rsp, err := c.BlockedDialogList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedDialogListResponse(rsp)
}

// CancelOrderAwaitingPaymentWithResponse request returning *CancelOrderAwaitingPaymentResponse
func (c *ClientWithResponses) CancelOrderAwaitingPaymentWithResponse(ctx context.Context, params *CancelOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*CancelOrderAwaitingPaymentResponse, error) {
	rsp, err := c.CancelOrderAwaitingPayment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelOrderAwaitingPaymentResponse(rsp)
}

// CancelOrderByPayerWithBodyWithResponse request with arbitrary body returning *CancelOrderByPayerResponse
func (c *ClientWithResponses) CancelOrderByPayerWithBodyWithResponse(ctx context.Context, params *CancelOrderByPayerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelOrderByPayerResponse, error) {
	rsp, err := c.CancelOrderByPayerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelOrderByPayerResponse(rsp)
}

func (c *ClientWithResponses) CancelOrderByPayerWithFormdataBodyWithResponse(ctx context.Context, params *CancelOrderByPayerParams, body CancelOrderByPayerFormdataRequestBody, reqEditors ...RequestEditorFn) (*CancelOrderByPayerResponse, error) {
	rsp, err := c.CancelOrderByPayerWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelOrderByPayerResponse(rsp)
}

// CancelOrderByWorkerWithBodyWithResponse request with arbitrary body returning *CancelOrderByWorkerResponse
func (c *ClientWithResponses) CancelOrderByWorkerWithBodyWithResponse(ctx context.Context, params *CancelOrderByWorkerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelOrderByWorkerResponse, error) {
	rsp, err := c.CancelOrderByWorkerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelOrderByWorkerResponse(rsp)
}

func (c *ClientWithResponses) CancelOrderByWorkerWithFormdataBodyWithResponse(ctx context.Context, params *CancelOrderByWorkerParams, body CancelOrderByWorkerFormdataRequestBody, reqEditors ...RequestEditorFn) (*CancelOrderByWorkerResponse, error) {
	rsp, err := c.CancelOrderByWorkerWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelOrderByWorkerResponse(rsp)
}

// CatalogCategoriesWithResponse request returning *CatalogCategoriesResponse
func (c *ClientWithResponses) CatalogCategoriesWithResponse(ctx context.Context, params *CatalogCategoriesParams, reqEditors ...RequestEditorFn) (*CatalogCategoriesResponse, error) {
	rsp, err := c.CatalogCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCatalogCategoriesResponse(rsp)
}

// CatalogFiltersWithResponse request returning *CatalogFiltersResponse
func (c *ClientWithResponses) CatalogFiltersWithResponse(ctx context.Context, params *CatalogFiltersParams, reqEditors ...RequestEditorFn) (*CatalogFiltersResponse, error) {
	rsp, err := c.CatalogFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCatalogFiltersResponse(rsp)
}

// CatalogMainWithResponse request returning *CatalogMainResponse
func (c *ClientWithResponses) CatalogMainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CatalogMainResponse, error) {
	rsp, err := c.CatalogMain(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCatalogMainResponse(rsp)
}

// CatalogMainv2WithResponse request returning *CatalogMainv2Response
func (c *ClientWithResponses) CatalogMainv2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CatalogMainv2Response, error) {
	rsp, err := c.CatalogMainv2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCatalogMainv2Response(rsp)
}

// CatalogRubricsWithResponse request returning *CatalogRubricsResponse
func (c *ClientWithResponses) CatalogRubricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CatalogRubricsResponse, error) {
	rsp, err := c.CatalogRubrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCatalogRubricsResponse(rsp)
}

// CategoriesWithResponse request returning *CategoriesResponse
func (c *ClientWithResponses) CategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CategoriesResponse, error) {
	rsp, err := c.Categories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCategoriesResponse(rsp)
}

// CategoryWithResponse request returning *CategoryResponse
func (c *ClientWithResponses) CategoryWithResponse(ctx context.Context, params *CategoryParams, reqEditors ...RequestEditorFn) (*CategoryResponse, error) {
	rsp, err := c.Category(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCategoryResponse(rsp)
}

// CategoryAttributesWithResponse request returning *CategoryAttributesResponse
func (c *ClientWithResponses) CategoryAttributesWithResponse(ctx context.Context, params *CategoryAttributesParams, reqEditors ...RequestEditorFn) (*CategoryAttributesResponse, error) {
	rsp, err := c.CategoryAttributes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCategoryAttributesResponse(rsp)
}

// ChangePasswordWithBodyWithResponse request with arbitrary body returning *ChangePasswordResponse
func (c *ClientWithResponses) ChangePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error) {
	rsp, err := c.ChangePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResponse(rsp)
}

func (c *ClientWithResponses) ChangePasswordWithFormdataBodyWithResponse(ctx context.Context, body ChangePasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error) {
	rsp, err := c.ChangePasswordWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResponse(rsp)
}

// ChangePayerSubRoleWithResponse request returning *ChangePayerSubRoleResponse
func (c *ClientWithResponses) ChangePayerSubRoleWithResponse(ctx context.Context, params *ChangePayerSubRoleParams, reqEditors ...RequestEditorFn) (*ChangePayerSubRoleResponse, error) {
	rsp, err := c.ChangePayerSubRole(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePayerSubRoleResponse(rsp)
}

// ChangeUsernameWithBodyWithResponse request with arbitrary body returning *ChangeUsernameResponse
func (c *ClientWithResponses) ChangeUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeUsernameResponse, error) {
	rsp, err := c.ChangeUsernameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeUsernameResponse(rsp)
}

func (c *ClientWithResponses) ChangeUsernameWithFormdataBodyWithResponse(ctx context.Context, body ChangeUsernameFormdataRequestBody, reqEditors ...RequestEditorFn) (*ChangeUsernameResponse, error) {
	rsp, err := c.ChangeUsernameWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeUsernameResponse(rsp)
}

// CheckLoginWithBodyWithResponse request with arbitrary body returning *CheckLoginResponse
func (c *ClientWithResponses) CheckLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckLoginResponse, error) {
	rsp, err := c.CheckLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckLoginResponse(rsp)
}

func (c *ClientWithResponses) CheckLoginWithFormdataBodyWithResponse(ctx context.Context, body CheckLoginFormdataRequestBody, reqEditors ...RequestEditorFn) (*CheckLoginResponse, error) {
	rsp, err := c.CheckLoginWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckLoginResponse(rsp)
}

// CitiesWithResponse request returning *CitiesResponse
func (c *ClientWithResponses) CitiesWithResponse(ctx context.Context, params *CitiesParams, reqEditors ...RequestEditorFn) (*CitiesResponse, error) {
	rsp, err := c.Cities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCitiesResponse(rsp)
}

// ClearFiltersWithResponse request returning *ClearFiltersResponse
func (c *ClientWithResponses) ClearFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearFiltersResponse, error) {
	rsp, err := c.ClearFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearFiltersResponse(rsp)
}

// ConfirmCancelOrderRequestByPayerWithResponse request returning *ConfirmCancelOrderRequestByPayerResponse
func (c *ClientWithResponses) ConfirmCancelOrderRequestByPayerWithResponse(ctx context.Context, params *ConfirmCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*ConfirmCancelOrderRequestByPayerResponse, error) {
	rsp, err := c.ConfirmCancelOrderRequestByPayer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmCancelOrderRequestByPayerResponse(rsp)
}

// ConfirmCancelOrderRequestByWorkerWithResponse request returning *ConfirmCancelOrderRequestByWorkerResponse
func (c *ClientWithResponses) ConfirmCancelOrderRequestByWorkerWithResponse(ctx context.Context, params *ConfirmCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*ConfirmCancelOrderRequestByWorkerResponse, error) {
	rsp, err := c.ConfirmCancelOrderRequestByWorker(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmCancelOrderRequestByWorkerResponse(rsp)
}

// CountriesWithResponse request returning *CountriesResponse
func (c *ClientWithResponses) CountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountriesResponse, error) {
	rsp, err := c.Countries(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountriesResponse(rsp)
}

// CreateAnswerWithBodyWithResponse request with arbitrary body returning *CreateAnswerResponse
func (c *ClientWithResponses) CreateAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAnswerResponse, error) {
	rsp, err := c.CreateAnswerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnswerResponse(rsp)
}

func (c *ClientWithResponses) CreateAnswerWithFormdataBodyWithResponse(ctx context.Context, body CreateAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateAnswerResponse, error) {
	rsp, err := c.CreateAnswerWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAnswerResponse(rsp)
}

// CreateKworkComplainWithBodyWithResponse request with arbitrary body returning *CreateKworkComplainResponse
func (c *ClientWithResponses) CreateKworkComplainWithBodyWithResponse(ctx context.Context, params *CreateKworkComplainParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKworkComplainResponse, error) {
	rsp, err := c.CreateKworkComplainWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKworkComplainResponse(rsp)
}

func (c *ClientWithResponses) CreateKworkComplainWithFormdataBodyWithResponse(ctx context.Context, params *CreateKworkComplainParams, body CreateKworkComplainFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateKworkComplainResponse, error) {
	rsp, err := c.CreateKworkComplainWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKworkComplainResponse(rsp)
}

// CreatePortfolioWithResponse request returning *CreatePortfolioResponse
func (c *ClientWithResponses) CreatePortfolioWithResponse(ctx context.Context, params *CreatePortfolioParams, reqEditors ...RequestEditorFn) (*CreatePortfolioResponse, error) {
	rsp, err := c.CreatePortfolio(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortfolioResponse(rsp)
}

// CreateReviewWithBodyWithResponse request with arbitrary body returning *CreateReviewResponse
func (c *ClientWithResponses) CreateReviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error) {
	rsp, err := c.CreateReviewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReviewResponse(rsp)
}

func (c *ClientWithResponses) CreateReviewWithFormdataBodyWithResponse(ctx context.Context, body CreateReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error) {
	rsp, err := c.CreateReviewWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReviewResponse(rsp)
}

// CreateStageWithResponse request returning *CreateStageResponse
func (c *ClientWithResponses) CreateStageWithResponse(ctx context.Context, params *CreateStageParams, reqEditors ...RequestEditorFn) (*CreateStageResponse, error) {
	rsp, err := c.CreateStage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStageResponse(rsp)
}

// DelFavoriteCategoriesWithResponse request returning *DelFavoriteCategoriesResponse
func (c *ClientWithResponses) DelFavoriteCategoriesWithResponse(ctx context.Context, params *DelFavoriteCategoriesParams, reqEditors ...RequestEditorFn) (*DelFavoriteCategoriesResponse, error) {
	rsp, err := c.DelFavoriteCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelFavoriteCategoriesResponse(rsp)
}

// DeleteAccountWithResponse request returning *DeleteAccountResponse
func (c *ClientWithResponses) DeleteAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error) {
	rsp, err := c.DeleteAccount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResponse(rsp)
}

// DeleteCancelOrderRequestByPayerWithResponse request returning *DeleteCancelOrderRequestByPayerResponse
func (c *ClientWithResponses) DeleteCancelOrderRequestByPayerWithResponse(ctx context.Context, params *DeleteCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*DeleteCancelOrderRequestByPayerResponse, error) {
	rsp, err := c.DeleteCancelOrderRequestByPayer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCancelOrderRequestByPayerResponse(rsp)
}

// DeleteCancelOrderRequestByWorkerWithResponse request returning *DeleteCancelOrderRequestByWorkerResponse
func (c *ClientWithResponses) DeleteCancelOrderRequestByWorkerWithResponse(ctx context.Context, params *DeleteCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*DeleteCancelOrderRequestByWorkerResponse, error) {
	rsp, err := c.DeleteCancelOrderRequestByWorker(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCancelOrderRequestByWorkerResponse(rsp)
}

// DeleteCoverWithResponse request returning *DeleteCoverResponse
func (c *ClientWithResponses) DeleteCoverWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCoverResponse, error) {
	rsp, err := c.DeleteCover(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCoverResponse(rsp)
}

// DeleteKworkWithResponse request returning *DeleteKworkResponse
func (c *ClientWithResponses) DeleteKworkWithResponse(ctx context.Context, params *DeleteKworkParams, reqEditors ...RequestEditorFn) (*DeleteKworkResponse, error) {
	rsp, err := c.DeleteKwork(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKworkResponse(rsp)
}

// DeleteOfferWithResponse request returning *DeleteOfferResponse
func (c *ClientWithResponses) DeleteOfferWithResponse(ctx context.Context, params *DeleteOfferParams, reqEditors ...RequestEditorFn) (*DeleteOfferResponse, error) {
	rsp, err := c.DeleteOffer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOfferResponse(rsp)
}

// DeleteOrderNoteWithResponse request returning *DeleteOrderNoteResponse
func (c *ClientWithResponses) DeleteOrderNoteWithResponse(ctx context.Context, params *DeleteOrderNoteParams, reqEditors ...RequestEditorFn) (*DeleteOrderNoteResponse, error) {
	rsp, err := c.DeleteOrderNote(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderNoteResponse(rsp)
}

// DeletePortfolioWithResponse request returning *DeletePortfolioResponse
func (c *ClientWithResponses) DeletePortfolioWithResponse(ctx context.Context, params *DeletePortfolioParams, reqEditors ...RequestEditorFn) (*DeletePortfolioResponse, error) {
	rsp, err := c.DeletePortfolio(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePortfolioResponse(rsp)
}

// DeleteReviewWithResponse request returning *DeleteReviewResponse
func (c *ClientWithResponses) DeleteReviewWithResponse(ctx context.Context, params *DeleteReviewParams, reqEditors ...RequestEditorFn) (*DeleteReviewResponse, error) {
	rsp, err := c.DeleteReview(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReviewResponse(rsp)
}

// DeleteStageWithResponse request returning *DeleteStageResponse
func (c *ClientWithResponses) DeleteStageWithResponse(ctx context.Context, params *DeleteStageParams, reqEditors ...RequestEditorFn) (*DeleteStageResponse, error) {
	rsp, err := c.DeleteStage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStageResponse(rsp)
}

// DeleteUserNoteWithResponse request returning *DeleteUserNoteResponse
func (c *ClientWithResponses) DeleteUserNoteWithResponse(ctx context.Context, params *DeleteUserNoteParams, reqEditors ...RequestEditorFn) (*DeleteUserNoteResponse, error) {
	rsp, err := c.DeleteUserNote(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserNoteResponse(rsp)
}

// DeleteWantWithResponse request returning *DeleteWantResponse
func (c *ClientWithResponses) DeleteWantWithResponse(ctx context.Context, params *DeleteWantParams, reqEditors ...RequestEditorFn) (*DeleteWantResponse, error) {
	rsp, err := c.DeleteWant(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWantResponse(rsp)
}

// DialogsWithResponse request returning *DialogsResponse
func (c *ClientWithResponses) DialogsWithResponse(ctx context.Context, params *DialogsParams, reqEditors ...RequestEditorFn) (*DialogsResponse, error) {
	rsp, err := c.Dialogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDialogsResponse(rsp)
}

// EditAnswerWithBodyWithResponse request with arbitrary body returning *EditAnswerResponse
func (c *ClientWithResponses) EditAnswerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAnswerResponse, error) {
	rsp, err := c.EditAnswerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAnswerResponse(rsp)
}

func (c *ClientWithResponses) EditAnswerWithFormdataBodyWithResponse(ctx context.Context, body EditAnswerFormdataRequestBody, reqEditors ...RequestEditorFn) (*EditAnswerResponse, error) {
	rsp, err := c.EditAnswerWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAnswerResponse(rsp)
}

// EditPortfolioWithResponse request returning *EditPortfolioResponse
func (c *ClientWithResponses) EditPortfolioWithResponse(ctx context.Context, params *EditPortfolioParams, reqEditors ...RequestEditorFn) (*EditPortfolioResponse, error) {
	rsp, err := c.EditPortfolio(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPortfolioResponse(rsp)
}

// EditReviewWithBodyWithResponse request with arbitrary body returning *EditReviewResponse
func (c *ClientWithResponses) EditReviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditReviewResponse, error) {
	rsp, err := c.EditReviewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditReviewResponse(rsp)
}

func (c *ClientWithResponses) EditReviewWithFormdataBodyWithResponse(ctx context.Context, body EditReviewFormdataRequestBody, reqEditors ...RequestEditorFn) (*EditReviewResponse, error) {
	rsp, err := c.EditReviewWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditReviewResponse(rsp)
}

// EditStageWithResponse request returning *EditStageResponse
func (c *ClientWithResponses) EditStageWithResponse(ctx context.Context, params *EditStageParams, reqEditors ...RequestEditorFn) (*EditStageResponse, error) {
	rsp, err := c.EditStage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditStageResponse(rsp)
}

// EmailVerificationLetterWithResponse request returning *EmailVerificationLetterResponse
func (c *ClientWithResponses) EmailVerificationLetterWithResponse(ctx context.Context, params *EmailVerificationLetterParams, reqEditors ...RequestEditorFn) (*EmailVerificationLetterResponse, error) {
	rsp, err := c.EmailVerificationLetter(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailVerificationLetterResponse(rsp)
}

// ExchangeInfoWithResponse request returning *ExchangeInfoResponse
func (c *ClientWithResponses) ExchangeInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExchangeInfoResponse, error) {
	rsp, err := c.ExchangeInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeInfoResponse(rsp)
}

// FavoriteCategoriesWithResponse request returning *FavoriteCategoriesResponse
func (c *ClientWithResponses) FavoriteCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FavoriteCategoriesResponse, error) {
	rsp, err := c.FavoriteCategories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFavoriteCategoriesResponse(rsp)
}

// FavoriteKworksWithResponse request returning *FavoriteKworksResponse
func (c *ClientWithResponses) FavoriteKworksWithResponse(ctx context.Context, params *FavoriteKworksParams, reqEditors ...RequestEditorFn) (*FavoriteKworksResponse, error) {
	rsp, err := c.FavoriteKworks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFavoriteKworksResponse(rsp)
}

// FcmNotificationsReadWithResponse request returning *FcmNotificationsReadResponse
func (c *ClientWithResponses) FcmNotificationsReadWithResponse(ctx context.Context, params *FcmNotificationsReadParams, reqEditors ...RequestEditorFn) (*FcmNotificationsReadResponse, error) {
	rsp, err := c.FcmNotificationsRead(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFcmNotificationsReadResponse(rsp)
}

// FcmNotificationsReceivedWithResponse request returning *FcmNotificationsReceivedResponse
func (c *ClientWithResponses) FcmNotificationsReceivedWithResponse(ctx context.Context, params *FcmNotificationsReceivedParams, reqEditors ...RequestEditorFn) (*FcmNotificationsReceivedResponse, error) {
	rsp, err := c.FcmNotificationsReceived(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFcmNotificationsReceivedResponse(rsp)
}

// FcmTokenRequestFailedWithResponse request returning *FcmTokenRequestFailedResponse
func (c *ClientWithResponses) FcmTokenRequestFailedWithResponse(ctx context.Context, params *FcmTokenRequestFailedParams, reqEditors ...RequestEditorFn) (*FcmTokenRequestFailedResponse, error) {
	rsp, err := c.FcmTokenRequestFailed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFcmTokenRequestFailedResponse(rsp)
}

// FileDeleteWithResponse request returning *FileDeleteResponse
func (c *ClientWithResponses) FileDeleteWithResponse(ctx context.Context, params *FileDeleteParams, reqEditors ...RequestEditorFn) (*FileDeleteResponse, error) {
	rsp, err := c.FileDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileDeleteResponse(rsp)
}

// FileUploadWithBodyWithResponse request with arbitrary body returning *FileUploadResponse
func (c *ClientWithResponses) FileUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResponse, error) {
	rsp, err := c.FileUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileUploadResponse(rsp)
}

// GetActorInfoWithBodyWithResponse request with arbitrary body returning *GetActorInfoResponse
func (c *ClientWithResponses) GetActorInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetActorInfoResponse, error) {
	rsp, err := c.GetActorInfoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActorInfoResponse(rsp)
}

func (c *ClientWithResponses) GetActorInfoWithFormdataBodyWithResponse(ctx context.Context, body GetActorInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetActorInfoResponse, error) {
	rsp, err := c.GetActorInfoWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActorInfoResponse(rsp)
}

// GetArbitrationReasonsWithResponse request returning *GetArbitrationReasonsResponse
func (c *ClientWithResponses) GetArbitrationReasonsWithResponse(ctx context.Context, params *GetArbitrationReasonsParams, reqEditors ...RequestEditorFn) (*GetArbitrationReasonsResponse, error) {
	rsp, err := c.GetArbitrationReasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArbitrationReasonsResponse(rsp)
}

// GetAvailableFeaturesWithResponse request returning *GetAvailableFeaturesResponse
func (c *ClientWithResponses) GetAvailableFeaturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableFeaturesResponse, error) {
	rsp, err := c.GetAvailableFeatures(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableFeaturesResponse(rsp)
}

// GetBadgesInfoWithBodyWithResponse request with arbitrary body returning *GetBadgesInfoResponse
func (c *ClientWithResponses) GetBadgesInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBadgesInfoResponse, error) {
	rsp, err := c.GetBadgesInfoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBadgesInfoResponse(rsp)
}

func (c *ClientWithResponses) GetBadgesInfoWithFormdataBodyWithResponse(ctx context.Context, body GetBadgesInfoFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetBadgesInfoResponse, error) {
	rsp, err := c.GetBadgesInfoWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBadgesInfoResponse(rsp)
}

// GetBillRefillUrlWithResponse request returning *GetBillRefillUrlResponse
func (c *ClientWithResponses) GetBillRefillUrlWithResponse(ctx context.Context, params *GetBillRefillUrlParams, reqEditors ...RequestEditorFn) (*GetBillRefillUrlResponse, error) {
	rsp, err := c.GetBillRefillUrl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillRefillUrlResponse(rsp)
}

// GetCaptchaStatusWithResponse request returning *GetCaptchaStatusResponse
func (c *ClientWithResponses) GetCaptchaStatusWithResponse(ctx context.Context, params *GetCaptchaStatusParams, reqEditors ...RequestEditorFn) (*GetCaptchaStatusResponse, error) {
	rsp, err := c.GetCaptchaStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptchaStatusResponse(rsp)
}

// GetChannelWithResponse request returning *GetChannelResponse
func (c *ClientWithResponses) GetChannelWithResponse(ctx context.Context, params *GetChannelParams, reqEditors ...RequestEditorFn) (*GetChannelResponse, error) {
	rsp, err := c.GetChannel(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelResponse(rsp)
}

// GetCompanyDetailsWithResponse request returning *GetCompanyDetailsResponse
func (c *ClientWithResponses) GetCompanyDetailsWithResponse(ctx context.Context, params *GetCompanyDetailsParams, reqEditors ...RequestEditorFn) (*GetCompanyDetailsResponse, error) {
	rsp, err := c.GetCompanyDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyDetailsResponse(rsp)
}

// GetComplainCategoriesWithResponse request returning *GetComplainCategoriesResponse
func (c *ClientWithResponses) GetComplainCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetComplainCategoriesResponse, error) {
	rsp, err := c.GetComplainCategories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplainCategoriesResponse(rsp)
}

// GetCookieWithResponse request returning *GetCookieResponse
func (c *ClientWithResponses) GetCookieWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCookieResponse, error) {
	rsp, err := c.GetCookie(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCookieResponse(rsp)
}

// GetCurrentVersionsWithResponse request returning *GetCurrentVersionsResponse
func (c *ClientWithResponses) GetCurrentVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentVersionsResponse, error) {
	rsp, err := c.GetCurrentVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentVersionsResponse(rsp)
}

// GetCustomOptionsPresetsWithResponse request returning *GetCustomOptionsPresetsResponse
func (c *ClientWithResponses) GetCustomOptionsPresetsWithResponse(ctx context.Context, params *GetCustomOptionsPresetsParams, reqEditors ...RequestEditorFn) (*GetCustomOptionsPresetsResponse, error) {
	rsp, err := c.GetCustomOptionsPresets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomOptionsPresetsResponse(rsp)
}

// GetDialogWithResponse request returning *GetDialogResponse
func (c *ClientWithResponses) GetDialogWithResponse(ctx context.Context, params *GetDialogParams, reqEditors ...RequestEditorFn) (*GetDialogResponse, error) {
	rsp, err := c.GetDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDialogResponse(rsp)
}

// GetExtrasAvailableForOrderWithResponse request returning *GetExtrasAvailableForOrderResponse
func (c *ClientWithResponses) GetExtrasAvailableForOrderWithResponse(ctx context.Context, params *GetExtrasAvailableForOrderParams, reqEditors ...RequestEditorFn) (*GetExtrasAvailableForOrderResponse, error) {
	rsp, err := c.GetExtrasAvailableForOrder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExtrasAvailableForOrderResponse(rsp)
}

// GetFishingTutorialQuestionsWithResponse request returning *GetFishingTutorialQuestionsResponse
func (c *ClientWithResponses) GetFishingTutorialQuestionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFishingTutorialQuestionsResponse, error) {
	rsp, err := c.GetFishingTutorialQuestions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFishingTutorialQuestionsResponse(rsp)
}

// GetHiddenKworksWithResponse request returning *GetHiddenKworksResponse
func (c *ClientWithResponses) GetHiddenKworksWithResponse(ctx context.Context, params *GetHiddenKworksParams, reqEditors ...RequestEditorFn) (*GetHiddenKworksResponse, error) {
	rsp, err := c.GetHiddenKworks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHiddenKworksResponse(rsp)
}

// GetInboxTracksWithResponse request returning *GetInboxTracksResponse
func (c *ClientWithResponses) GetInboxTracksWithResponse(ctx context.Context, params *GetInboxTracksParams, reqEditors ...RequestEditorFn) (*GetInboxTracksResponse, error) {
	rsp, err := c.GetInboxTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInboxTracksResponse(rsp)
}

// GetKworkAnswersWithResponse request returning *GetKworkAnswersResponse
func (c *ClientWithResponses) GetKworkAnswersWithResponse(ctx context.Context, params *GetKworkAnswersParams, reqEditors ...RequestEditorFn) (*GetKworkAnswersResponse, error) {
	rsp, err := c.GetKworkAnswers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkAnswersResponse(rsp)
}

// GetKworkDetailsWithResponse request returning *GetKworkDetailsResponse
func (c *ClientWithResponses) GetKworkDetailsWithResponse(ctx context.Context, params *GetKworkDetailsParams, reqEditors ...RequestEditorFn) (*GetKworkDetailsResponse, error) {
	rsp, err := c.GetKworkDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkDetailsResponse(rsp)
}

// GetKworkDetailsExtraWithResponse request returning *GetKworkDetailsExtraResponse
func (c *ClientWithResponses) GetKworkDetailsExtraWithResponse(ctx context.Context, params *GetKworkDetailsExtraParams, reqEditors ...RequestEditorFn) (*GetKworkDetailsExtraResponse, error) {
	rsp, err := c.GetKworkDetailsExtra(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkDetailsExtraResponse(rsp)
}

// GetKworkLinksTableWithResponse request returning *GetKworkLinksTableResponse
func (c *ClientWithResponses) GetKworkLinksTableWithResponse(ctx context.Context, params *GetKworkLinksTableParams, reqEditors ...RequestEditorFn) (*GetKworkLinksTableResponse, error) {
	rsp, err := c.GetKworkLinksTable(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkLinksTableResponse(rsp)
}

// GetKworkLinksTablev2WithResponse request returning *GetKworkLinksTablev2Response
func (c *ClientWithResponses) GetKworkLinksTablev2WithResponse(ctx context.Context, params *GetKworkLinksTablev2Params, reqEditors ...RequestEditorFn) (*GetKworkLinksTablev2Response, error) {
	rsp, err := c.GetKworkLinksTablev2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkLinksTablev2Response(rsp)
}

// GetKworkPortfoliosWithResponse request returning *GetKworkPortfoliosResponse
func (c *ClientWithResponses) GetKworkPortfoliosWithResponse(ctx context.Context, params *GetKworkPortfoliosParams, reqEditors ...RequestEditorFn) (*GetKworkPortfoliosResponse, error) {
	rsp, err := c.GetKworkPortfolios(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkPortfoliosResponse(rsp)
}

// GetKworkReviewsWithResponse request returning *GetKworkReviewsResponse
func (c *ClientWithResponses) GetKworkReviewsWithResponse(ctx context.Context, params *GetKworkReviewsParams, reqEditors ...RequestEditorFn) (*GetKworkReviewsResponse, error) {
	rsp, err := c.GetKworkReviews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKworkReviewsResponse(rsp)
}

// GetOrderCancellationReasonsWithResponse request returning *GetOrderCancellationReasonsResponse
func (c *ClientWithResponses) GetOrderCancellationReasonsWithResponse(ctx context.Context, params *GetOrderCancellationReasonsParams, reqEditors ...RequestEditorFn) (*GetOrderCancellationReasonsResponse, error) {
	rsp, err := c.GetOrderCancellationReasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderCancellationReasonsResponse(rsp)
}

// GetOrderDetailsWithResponse request returning *GetOrderDetailsResponse
func (c *ClientWithResponses) GetOrderDetailsWithResponse(ctx context.Context, params *GetOrderDetailsParams, reqEditors ...RequestEditorFn) (*GetOrderDetailsResponse, error) {
	rsp, err := c.GetOrderDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderDetailsResponse(rsp)
}

// GetOrderFilesWithResponse request returning *GetOrderFilesResponse
func (c *ClientWithResponses) GetOrderFilesWithResponse(ctx context.Context, params *GetOrderFilesParams, reqEditors ...RequestEditorFn) (*GetOrderFilesResponse, error) {
	rsp, err := c.GetOrderFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderFilesResponse(rsp)
}

// GetOrderHeaderWithResponse request returning *GetOrderHeaderResponse
func (c *ClientWithResponses) GetOrderHeaderWithResponse(ctx context.Context, params *GetOrderHeaderParams, reqEditors ...RequestEditorFn) (*GetOrderHeaderResponse, error) {
	rsp, err := c.GetOrderHeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderHeaderResponse(rsp)
}

// GetOrderProvidedDataWithResponse request returning *GetOrderProvidedDataResponse
func (c *ClientWithResponses) GetOrderProvidedDataWithResponse(ctx context.Context, params *GetOrderProvidedDataParams, reqEditors ...RequestEditorFn) (*GetOrderProvidedDataResponse, error) {
	rsp, err := c.GetOrderProvidedData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderProvidedDataResponse(rsp)
}

// GetOrderedExtrasWithResponse request returning *GetOrderedExtrasResponse
func (c *ClientWithResponses) GetOrderedExtrasWithResponse(ctx context.Context, params *GetOrderedExtrasParams, reqEditors ...RequestEditorFn) (*GetOrderedExtrasResponse, error) {
	rsp, err := c.GetOrderedExtras(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderedExtrasResponse(rsp)
}

// GetPayerCompanyModalUrlWithResponse request returning *GetPayerCompanyModalUrlResponse
func (c *ClientWithResponses) GetPayerCompanyModalUrlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPayerCompanyModalUrlResponse, error) {
	rsp, err := c.GetPayerCompanyModalUrl(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayerCompanyModalUrlResponse(rsp)
}

// GetPaymentMethodsWithResponse request returning *GetPaymentMethodsResponse
func (c *ClientWithResponses) GetPaymentMethodsWithResponse(ctx context.Context, params *GetPaymentMethodsParams, reqEditors ...RequestEditorFn) (*GetPaymentMethodsResponse, error) {
	rsp, err := c.GetPaymentMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentMethodsResponse(rsp)
}

// GetSecurityUserDataWithResponse request returning *GetSecurityUserDataResponse
func (c *ClientWithResponses) GetSecurityUserDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecurityUserDataResponse, error) {
	rsp, err := c.GetSecurityUserData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityUserDataResponse(rsp)
}

// GetSubscribersStatisticsWithResponse request returning *GetSubscribersStatisticsResponse
func (c *ClientWithResponses) GetSubscribersStatisticsWithResponse(ctx context.Context, params *GetSubscribersStatisticsParams, reqEditors ...RequestEditorFn) (*GetSubscribersStatisticsResponse, error) {
	rsp, err := c.GetSubscribersStatistics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscribersStatisticsResponse(rsp)
}

// GetTracksWithResponse request returning *GetTracksResponse
func (c *ClientWithResponses) GetTracksWithResponse(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*GetTracksResponse, error) {
	rsp, err := c.GetTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// GetUsersLastOrderInfoWithResponse request returning *GetUsersLastOrderInfoResponse
func (c *ClientWithResponses) GetUsersLastOrderInfoWithResponse(ctx context.Context, params *GetUsersLastOrderInfoParams, reqEditors ...RequestEditorFn) (*GetUsersLastOrderInfoResponse, error) {
	rsp, err := c.GetUsersLastOrderInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersLastOrderInfoResponse(rsp)
}

// GetVoiceMessageConvertStatusWithResponse request returning *GetVoiceMessageConvertStatusResponse
func (c *ClientWithResponses) GetVoiceMessageConvertStatusWithResponse(ctx context.Context, params *GetVoiceMessageConvertStatusParams, reqEditors ...RequestEditorFn) (*GetVoiceMessageConvertStatusResponse, error) {
	rsp, err := c.GetVoiceMessageConvertStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceMessageConvertStatusResponse(rsp)
}

// GetVoiceMessageTranscriptionWithResponse request returning *GetVoiceMessageTranscriptionResponse
func (c *ClientWithResponses) GetVoiceMessageTranscriptionWithResponse(ctx context.Context, params *GetVoiceMessageTranscriptionParams, reqEditors ...RequestEditorFn) (*GetVoiceMessageTranscriptionResponse, error) {
	rsp, err := c.GetVoiceMessageTranscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceMessageTranscriptionResponse(rsp)
}

// GetWantsCountWithResponse request returning *GetWantsCountResponse
func (c *ClientWithResponses) GetWantsCountWithResponse(ctx context.Context, params *GetWantsCountParams, reqEditors ...RequestEditorFn) (*GetWantsCountResponse, error) {
	rsp, err := c.GetWantsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWantsCountResponse(rsp)
}

// GetWebAuthTokenWithResponse request returning *GetWebAuthTokenResponse
func (c *ClientWithResponses) GetWebAuthTokenWithResponse(ctx context.Context, params *GetWebAuthTokenParams, reqEditors ...RequestEditorFn) (*GetWebAuthTokenResponse, error) {
	rsp, err := c.GetWebAuthToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebAuthTokenResponse(rsp)
}

// HideDialogWithResponse request returning *HideDialogResponse
func (c *ClientWithResponses) HideDialogWithResponse(ctx context.Context, params *HideDialogParams, reqEditors ...RequestEditorFn) (*HideDialogResponse, error) {
	rsp, err := c.HideDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideDialogResponse(rsp)
}

// HideSelfEmployedNotificationWithResponse request returning *HideSelfEmployedNotificationResponse
func (c *ClientWithResponses) HideSelfEmployedNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HideSelfEmployedNotificationResponse, error) {
	rsp, err := c.HideSelfEmployedNotification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideSelfEmployedNotificationResponse(rsp)
}

// HideVoiceMessageSettingsPopupWithResponse request returning *HideVoiceMessageSettingsPopupResponse
func (c *ClientWithResponses) HideVoiceMessageSettingsPopupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HideVoiceMessageSettingsPopupResponse, error) {
	rsp, err := c.HideVoiceMessageSettingsPopup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideVoiceMessageSettingsPopupResponse(rsp)
}

// InboxComplainMessageWithBodyWithResponse request with arbitrary body returning *InboxComplainMessageResponse
func (c *ClientWithResponses) InboxComplainMessageWithBodyWithResponse(ctx context.Context, params *InboxComplainMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InboxComplainMessageResponse, error) {
	rsp, err := c.InboxComplainMessageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxComplainMessageResponse(rsp)
}

func (c *ClientWithResponses) InboxComplainMessageWithFormdataBodyWithResponse(ctx context.Context, params *InboxComplainMessageParams, body InboxComplainMessageFormdataRequestBody, reqEditors ...RequestEditorFn) (*InboxComplainMessageResponse, error) {
	rsp, err := c.InboxComplainMessageWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxComplainMessageResponse(rsp)
}

// InboxCreateWithBodyWithResponse request with arbitrary body returning *InboxCreateResponse
func (c *ClientWithResponses) InboxCreateWithBodyWithResponse(ctx context.Context, params *InboxCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InboxCreateResponse, error) {
	rsp, err := c.InboxCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxCreateResponse(rsp)
}

func (c *ClientWithResponses) InboxCreateWithFormdataBodyWithResponse(ctx context.Context, params *InboxCreateParams, body InboxCreateFormdataRequestBody, reqEditors ...RequestEditorFn) (*InboxCreateResponse, error) {
	rsp, err := c.InboxCreateWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxCreateResponse(rsp)
}

// InboxCustomRequestDeclineWithResponse request returning *InboxCustomRequestDeclineResponse
func (c *ClientWithResponses) InboxCustomRequestDeclineWithResponse(ctx context.Context, params *InboxCustomRequestDeclineParams, reqEditors ...RequestEditorFn) (*InboxCustomRequestDeclineResponse, error) {
	rsp, err := c.InboxCustomRequestDecline(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxCustomRequestDeclineResponse(rsp)
}

// InboxDeleteWithResponse request returning *InboxDeleteResponse
func (c *ClientWithResponses) InboxDeleteWithResponse(ctx context.Context, params *InboxDeleteParams, reqEditors ...RequestEditorFn) (*InboxDeleteResponse, error) {
	rsp, err := c.InboxDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxDeleteResponse(rsp)
}

// InboxEditWithBodyWithResponse request with arbitrary body returning *InboxEditResponse
func (c *ClientWithResponses) InboxEditWithBodyWithResponse(ctx context.Context, params *InboxEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InboxEditResponse, error) {
	rsp, err := c.InboxEditWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxEditResponse(rsp)
}

func (c *ClientWithResponses) InboxEditWithFormdataBodyWithResponse(ctx context.Context, params *InboxEditParams, body InboxEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*InboxEditResponse, error) {
	rsp, err := c.InboxEditWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxEditResponse(rsp)
}

// InboxForwardWithResponse request returning *InboxForwardResponse
func (c *ClientWithResponses) InboxForwardWithResponse(ctx context.Context, params *InboxForwardParams, reqEditors ...RequestEditorFn) (*InboxForwardResponse, error) {
	rsp, err := c.InboxForward(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxForwardResponse(rsp)
}

// InboxMessageWithResponse request returning *InboxMessageResponse
func (c *ClientWithResponses) InboxMessageWithResponse(ctx context.Context, params *InboxMessageParams, reqEditors ...RequestEditorFn) (*InboxMessageResponse, error) {
	rsp, err := c.InboxMessage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxMessageResponse(rsp)
}

// InboxPayerDeclineWithResponse request returning *InboxPayerDeclineResponse
func (c *ClientWithResponses) InboxPayerDeclineWithResponse(ctx context.Context, params *InboxPayerDeclineParams, reqEditors ...RequestEditorFn) (*InboxPayerDeclineResponse, error) {
	rsp, err := c.InboxPayerDecline(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxPayerDeclineResponse(rsp)
}

// InboxReadWithResponse request returning *InboxReadResponse
func (c *ClientWithResponses) InboxReadWithResponse(ctx context.Context, params *InboxReadParams, reqEditors ...RequestEditorFn) (*InboxReadResponse, error) {
	rsp, err := c.InboxRead(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxReadResponse(rsp)
}

// InboxTrackMessageWithResponse request returning *InboxTrackMessageResponse
func (c *ClientWithResponses) InboxTrackMessageWithResponse(ctx context.Context, params *InboxTrackMessageParams, reqEditors ...RequestEditorFn) (*InboxTrackMessageResponse, error) {
	rsp, err := c.InboxTrackMessage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxTrackMessageResponse(rsp)
}

// InboxWorkerDeclineWithResponse request returning *InboxWorkerDeclineResponse
func (c *ClientWithResponses) InboxWorkerDeclineWithResponse(ctx context.Context, params *InboxWorkerDeclineParams, reqEditors ...RequestEditorFn) (*InboxWorkerDeclineResponse, error) {
	rsp, err := c.InboxWorkerDecline(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxWorkerDeclineResponse(rsp)
}

// InboxesWithResponse request returning *InboxesResponse
func (c *ClientWithResponses) InboxesWithResponse(ctx context.Context, params *InboxesParams, reqEditors ...RequestEditorFn) (*InboxesResponse, error) {
	rsp, err := c.Inboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInboxesResponse(rsp)
}

// IsDialogAllowWithResponse request returning *IsDialogAllowResponse
func (c *ClientWithResponses) IsDialogAllowWithResponse(ctx context.Context, params *IsDialogAllowParams, reqEditors ...RequestEditorFn) (*IsDialogAllowResponse, error) {
	rsp, err := c.IsDialogAllow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsDialogAllowResponse(rsp)
}

// KworksWithResponse request returning *KworksResponse
func (c *ClientWithResponses) KworksWithResponse(ctx context.Context, params *KworksParams, reqEditors ...RequestEditorFn) (*KworksResponse, error) {
	rsp, err := c.Kworks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKworksResponse(rsp)
}

// KworksCategoriesListWithResponse request returning *KworksCategoriesListResponse
func (c *ClientWithResponses) KworksCategoriesListWithResponse(ctx context.Context, params *KworksCategoriesListParams, reqEditors ...RequestEditorFn) (*KworksCategoriesListResponse, error) {
	rsp, err := c.KworksCategoriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKworksCategoriesListResponse(rsp)
}

// KworksStatusListWithResponse request returning *KworksStatusListResponse
func (c *ClientWithResponses) KworksStatusListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*KworksStatusListResponse, error) {
	rsp, err := c.KworksStatusList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseKworksStatusListResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// MarkInboxTracksAsReadWithResponse request returning *MarkInboxTracksAsReadResponse
func (c *ClientWithResponses) MarkInboxTracksAsReadWithResponse(ctx context.Context, params *MarkInboxTracksAsReadParams, reqEditors ...RequestEditorFn) (*MarkInboxTracksAsReadResponse, error) {
	rsp, err := c.MarkInboxTracksAsRead(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkInboxTracksAsReadResponse(rsp)
}

// MarkKworkAsFavoriteWithResponse request returning *MarkKworkAsFavoriteResponse
func (c *ClientWithResponses) MarkKworkAsFavoriteWithResponse(ctx context.Context, params *MarkKworkAsFavoriteParams, reqEditors ...RequestEditorFn) (*MarkKworkAsFavoriteResponse, error) {
	rsp, err := c.MarkKworkAsFavorite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkKworkAsFavoriteResponse(rsp)
}

// MarkKworkAsHiddenWithResponse request returning *MarkKworkAsHiddenResponse
func (c *ClientWithResponses) MarkKworkAsHiddenWithResponse(ctx context.Context, params *MarkKworkAsHiddenParams, reqEditors ...RequestEditorFn) (*MarkKworkAsHiddenResponse, error) {
	rsp, err := c.MarkKworkAsHidden(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkKworkAsHiddenResponse(rsp)
}

// MarkKworksBlackFridayWithResponse request returning *MarkKworksBlackFridayResponse
func (c *ClientWithResponses) MarkKworksBlackFridayWithResponse(ctx context.Context, params *MarkKworksBlackFridayParams, reqEditors ...RequestEditorFn) (*MarkKworksBlackFridayResponse, error) {
	rsp, err := c.MarkKworksBlackFriday(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkKworksBlackFridayResponse(rsp)
}

// MarkVoiceMessageHeardWithResponse request returning *MarkVoiceMessageHeardResponse
func (c *ClientWithResponses) MarkVoiceMessageHeardWithResponse(ctx context.Context, params *MarkVoiceMessageHeardParams, reqEditors ...RequestEditorFn) (*MarkVoiceMessageHeardResponse, error) {
	rsp, err := c.MarkVoiceMessageHeard(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkVoiceMessageHeardResponse(rsp)
}

// MiniatureWithResponse request returning *MiniatureResponse
func (c *ClientWithResponses) MiniatureWithResponse(ctx context.Context, params *MiniatureParams, reqEditors ...RequestEditorFn) (*MiniatureResponse, error) {
	rsp, err := c.Miniature(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMiniatureResponse(rsp)
}

// MyWantsWithResponse request returning *MyWantsResponse
func (c *ClientWithResponses) MyWantsWithResponse(ctx context.Context, params *MyWantsParams, reqEditors ...RequestEditorFn) (*MyWantsResponse, error) {
	rsp, err := c.MyWants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMyWantsResponse(rsp)
}

// NotificationsWithResponse request returning *NotificationsResponse
func (c *ClientWithResponses) NotificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*NotificationsResponse, error) {
	rsp, err := c.Notifications(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsResponse(rsp)
}

// NotificationsFetchWithResponse request returning *NotificationsFetchResponse
func (c *ClientWithResponses) NotificationsFetchWithResponse(ctx context.Context, params *NotificationsFetchParams, reqEditors ...RequestEditorFn) (*NotificationsFetchResponse, error) {
	rsp, err := c.NotificationsFetch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsFetchResponse(rsp)
}

// NotificationsReceivedWithResponse request returning *NotificationsReceivedResponse
func (c *ClientWithResponses) NotificationsReceivedWithResponse(ctx context.Context, params *NotificationsReceivedParams, reqEditors ...RequestEditorFn) (*NotificationsReceivedResponse, error) {
	rsp, err := c.NotificationsReceived(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationsReceivedResponse(rsp)
}

// OfferWithResponse request returning *OfferResponse
func (c *ClientWithResponses) OfferWithResponse(ctx context.Context, params *OfferParams, reqEditors ...RequestEditorFn) (*OfferResponse, error) {
	rsp, err := c.Offer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfferResponse(rsp)
}

// OfferOrderOptionsWithResponse request returning *OfferOrderOptionsResponse
func (c *ClientWithResponses) OfferOrderOptionsWithResponse(ctx context.Context, params *OfferOrderOptionsParams, reqEditors ...RequestEditorFn) (*OfferOrderOptionsResponse, error) {
	rsp, err := c.OfferOrderOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfferOrderOptionsResponse(rsp)
}

// OffersWithResponse request returning *OffersResponse
func (c *ClientWithResponses) OffersWithResponse(ctx context.Context, params *OffersParams, reqEditors ...RequestEditorFn) (*OffersResponse, error) {
	rsp, err := c.Offers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOffersResponse(rsp)
}

// OfflineWithResponse request returning *OfflineResponse
func (c *ClientWithResponses) OfflineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OfflineResponse, error) {
	rsp, err := c.Offline(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfflineResponse(rsp)
}

// OrderWithResponse request returning *OrderResponse
func (c *ClientWithResponses) OrderWithResponse(ctx context.Context, params *OrderParams, reqEditors ...RequestEditorFn) (*OrderResponse, error) {
	rsp, err := c.Order(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderResponse(rsp)
}

// OrderKworkWithResponse request returning *OrderKworkResponse
func (c *ClientWithResponses) OrderKworkWithResponse(ctx context.Context, params *OrderKworkParams, reqEditors ...RequestEditorFn) (*OrderKworkResponse, error) {
	rsp, err := c.OrderKwork(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderKworkResponse(rsp)
}

// OrderStageWithResponse request returning *OrderStageResponse
func (c *ClientWithResponses) OrderStageWithResponse(ctx context.Context, params *OrderStageParams, reqEditors ...RequestEditorFn) (*OrderStageResponse, error) {
	rsp, err := c.OrderStage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderStageResponse(rsp)
}

// OrdersBetweenWithResponse request returning *OrdersBetweenResponse
func (c *ClientWithResponses) OrdersBetweenWithResponse(ctx context.Context, params *OrdersBetweenParams, reqEditors ...RequestEditorFn) (*OrdersBetweenResponse, error) {
	rsp, err := c.OrdersBetween(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrdersBetweenResponse(rsp)
}

// PauseKworkWithResponse request returning *PauseKworkResponse
func (c *ClientWithResponses) PauseKworkWithResponse(ctx context.Context, params *PauseKworkParams, reqEditors ...RequestEditorFn) (*PauseKworkResponse, error) {
	rsp, err := c.PauseKwork(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseKworkResponse(rsp)
}

// PayOrderAwaitingPaymentWithResponse request returning *PayOrderAwaitingPaymentResponse
func (c *ClientWithResponses) PayOrderAwaitingPaymentWithResponse(ctx context.Context, params *PayOrderAwaitingPaymentParams, reqEditors ...RequestEditorFn) (*PayOrderAwaitingPaymentResponse, error) {
	rsp, err := c.PayOrderAwaitingPayment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayOrderAwaitingPaymentResponse(rsp)
}

// PayerBuyExtrasWithResponse request returning *PayerBuyExtrasResponse
func (c *ClientWithResponses) PayerBuyExtrasWithResponse(ctx context.Context, params *PayerBuyExtrasParams, reqEditors ...RequestEditorFn) (*PayerBuyExtrasResponse, error) {
	rsp, err := c.PayerBuyExtras(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayerBuyExtrasResponse(rsp)
}

// PayerDeclineExtrasWithResponse request returning *PayerDeclineExtrasResponse
func (c *ClientWithResponses) PayerDeclineExtrasWithResponse(ctx context.Context, params *PayerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*PayerDeclineExtrasResponse, error) {
	rsp, err := c.PayerDeclineExtras(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayerDeclineExtrasResponse(rsp)
}

// PayerDeclinesExtraRemovalRequestWithResponse request returning *PayerDeclinesExtraRemovalRequestResponse
func (c *ClientWithResponses) PayerDeclinesExtraRemovalRequestWithResponse(ctx context.Context, params *PayerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*PayerDeclinesExtraRemovalRequestResponse, error) {
	rsp, err := c.PayerDeclinesExtraRemovalRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayerDeclinesExtraRemovalRequestResponse(rsp)
}

// PayerExtraDeleteWithResponse request returning *PayerExtraDeleteResponse
func (c *ClientWithResponses) PayerExtraDeleteWithResponse(ctx context.Context, params *PayerExtraDeleteParams, reqEditors ...RequestEditorFn) (*PayerExtraDeleteResponse, error) {
	rsp, err := c.PayerExtraDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayerExtraDeleteResponse(rsp)
}

// PayerOrdersWithResponse request returning *PayerOrdersResponse
func (c *ClientWithResponses) PayerOrdersWithResponse(ctx context.Context, params *PayerOrdersParams, reqEditors ...RequestEditorFn) (*PayerOrdersResponse, error) {
	rsp, err := c.PayerOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayerOrdersResponse(rsp)
}

// PayerUpgradePackageWithResponse request returning *PayerUpgradePackageResponse
func (c *ClientWithResponses) PayerUpgradePackageWithResponse(ctx context.Context, params *PayerUpgradePackageParams, reqEditors ...RequestEditorFn) (*PayerUpgradePackageResponse, error) {
	rsp, err := c.PayerUpgradePackage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayerUpgradePackageResponse(rsp)
}

// PortfolioCategoriesListWithResponse request returning *PortfolioCategoriesListResponse
func (c *ClientWithResponses) PortfolioCategoriesListWithResponse(ctx context.Context, params *PortfolioCategoriesListParams, reqEditors ...RequestEditorFn) (*PortfolioCategoriesListResponse, error) {
	rsp, err := c.PortfolioCategoriesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePortfolioCategoriesListResponse(rsp)
}

// PortfolioListWithResponse request returning *PortfolioListResponse
func (c *ClientWithResponses) PortfolioListWithResponse(ctx context.Context, params *PortfolioListParams, reqEditors ...RequestEditorFn) (*PortfolioListResponse, error) {
	rsp, err := c.PortfolioList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePortfolioListResponse(rsp)
}

// PositiveReviewsCountWithResponse request returning *PositiveReviewsCountResponse
func (c *ClientWithResponses) PositiveReviewsCountWithResponse(ctx context.Context, params *PositiveReviewsCountParams, reqEditors ...RequestEditorFn) (*PositiveReviewsCountResponse, error) {
	rsp, err := c.PositiveReviewsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePositiveReviewsCountResponse(rsp)
}

// PrivacyWithResponse request returning *PrivacyResponse
func (c *ClientWithResponses) PrivacyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PrivacyResponse, error) {
	rsp, err := c.Privacy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrivacyResponse(rsp)
}

// ProjectsWithResponse request returning *ProjectsResponse
func (c *ClientWithResponses) ProjectsWithResponse(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*ProjectsResponse, error) {
	rsp, err := c.Projects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsResponse(rsp)
}

// PushInAppNotificationLogWithResponse request returning *PushInAppNotificationLogResponse
func (c *ClientWithResponses) PushInAppNotificationLogWithResponse(ctx context.Context, params *PushInAppNotificationLogParams, reqEditors ...RequestEditorFn) (*PushInAppNotificationLogResponse, error) {
	rsp, err := c.PushInAppNotificationLog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushInAppNotificationLogResponse(rsp)
}

// RateArbitrationWithResponse request returning *RateArbitrationResponse
func (c *ClientWithResponses) RateArbitrationWithResponse(ctx context.Context, params *RateArbitrationParams, reqEditors ...RequestEditorFn) (*RateArbitrationResponse, error) {
	rsp, err := c.RateArbitration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRateArbitrationResponse(rsp)
}

// RechargeBalanceWithResponse request returning *RechargeBalanceResponse
func (c *ClientWithResponses) RechargeBalanceWithResponse(ctx context.Context, params *RechargeBalanceParams, reqEditors ...RequestEditorFn) (*RechargeBalanceResponse, error) {
	rsp, err := c.RechargeBalance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRechargeBalanceResponse(rsp)
}

// RegisterCloudTokenWithResponse request returning *RegisterCloudTokenResponse
func (c *ClientWithResponses) RegisterCloudTokenWithResponse(ctx context.Context, params *RegisterCloudTokenParams, reqEditors ...RequestEditorFn) (*RegisterCloudTokenResponse, error) {
	rsp, err := c.RegisterCloudToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterCloudTokenResponse(rsp)
}

// RejectCancelOrderRequestByPayerWithResponse request returning *RejectCancelOrderRequestByPayerResponse
func (c *ClientWithResponses) RejectCancelOrderRequestByPayerWithResponse(ctx context.Context, params *RejectCancelOrderRequestByPayerParams, reqEditors ...RequestEditorFn) (*RejectCancelOrderRequestByPayerResponse, error) {
	rsp, err := c.RejectCancelOrderRequestByPayer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectCancelOrderRequestByPayerResponse(rsp)
}

// RejectCancelOrderRequestByWorkerWithResponse request returning *RejectCancelOrderRequestByWorkerResponse
func (c *ClientWithResponses) RejectCancelOrderRequestByWorkerWithResponse(ctx context.Context, params *RejectCancelOrderRequestByWorkerParams, reqEditors ...RequestEditorFn) (*RejectCancelOrderRequestByWorkerResponse, error) {
	rsp, err := c.RejectCancelOrderRequestByWorker(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectCancelOrderRequestByWorkerResponse(rsp)
}

// RejectStageSuggestionWithResponse request returning *RejectStageSuggestionResponse
func (c *ClientWithResponses) RejectStageSuggestionWithResponse(ctx context.Context, params *RejectStageSuggestionParams, reqEditors ...RequestEditorFn) (*RejectStageSuggestionResponse, error) {
	rsp, err := c.RejectStageSuggestion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectStageSuggestionResponse(rsp)
}

// RepeatOrderWithResponse request returning *RepeatOrderResponse
func (c *ClientWithResponses) RepeatOrderWithResponse(ctx context.Context, params *RepeatOrderParams, reqEditors ...RequestEditorFn) (*RepeatOrderResponse, error) {
	rsp, err := c.RepeatOrder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepeatOrderResponse(rsp)
}

// ReportAppVersionWithResponse request returning *ReportAppVersionResponse
func (c *ClientWithResponses) ReportAppVersionWithResponse(ctx context.Context, params *ReportAppVersionParams, reqEditors ...RequestEditorFn) (*ReportAppVersionResponse, error) {
	rsp, err := c.ReportAppVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportAppVersionResponse(rsp)
}

// RequestPhoneChangingWithResponse request returning *RequestPhoneChangingResponse
func (c *ClientWithResponses) RequestPhoneChangingWithResponse(ctx context.Context, params *RequestPhoneChangingParams, reqEditors ...RequestEditorFn) (*RequestPhoneChangingResponse, error) {
	rsp, err := c.RequestPhoneChanging(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestPhoneChangingResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithFormdataBodyWithResponse(ctx context.Context, body ResetPasswordFormdataRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// ResolutionWithResponse request returning *ResolutionResponse
func (c *ClientWithResponses) ResolutionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResolutionResponse, error) {
	rsp, err := c.Resolution(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolutionResponse(rsp)
}

// RestartWantWithResponse request returning *RestartWantResponse
func (c *ClientWithResponses) RestartWantWithResponse(ctx context.Context, params *RestartWantParams, reqEditors ...RequestEditorFn) (*RestartWantResponse, error) {
	rsp, err := c.RestartWant(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartWantResponse(rsp)
}

// SaveOrderNoteWithBodyWithResponse request with arbitrary body returning *SaveOrderNoteResponse
func (c *ClientWithResponses) SaveOrderNoteWithBodyWithResponse(ctx context.Context, params *SaveOrderNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveOrderNoteResponse, error) {
	rsp, err := c.SaveOrderNoteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveOrderNoteResponse(rsp)
}

func (c *ClientWithResponses) SaveOrderNoteWithFormdataBodyWithResponse(ctx context.Context, params *SaveOrderNoteParams, body SaveOrderNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*SaveOrderNoteResponse, error) {
	rsp, err := c.SaveOrderNoteWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveOrderNoteResponse(rsp)
}

// SaveUserNoteWithBodyWithResponse request with arbitrary body returning *SaveUserNoteResponse
func (c *ClientWithResponses) SaveUserNoteWithBodyWithResponse(ctx context.Context, params *SaveUserNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserNoteResponse, error) {
	rsp, err := c.SaveUserNoteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserNoteResponse(rsp)
}

func (c *ClientWithResponses) SaveUserNoteWithFormdataBodyWithResponse(ctx context.Context, params *SaveUserNoteParams, body SaveUserNoteFormdataRequestBody, reqEditors ...RequestEditorFn) (*SaveUserNoteResponse, error) {
	rsp, err := c.SaveUserNoteWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserNoteResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// SearchDialogsWithResponse request returning *SearchDialogsResponse
func (c *ClientWithResponses) SearchDialogsWithResponse(ctx context.Context, params *SearchDialogsParams, reqEditors ...RequestEditorFn) (*SearchDialogsResponse, error) {
	rsp, err := c.SearchDialogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDialogsResponse(rsp)
}

// SearchInboxesWithResponse request returning *SearchInboxesResponse
func (c *ClientWithResponses) SearchInboxesWithResponse(ctx context.Context, params *SearchInboxesParams, reqEditors ...RequestEditorFn) (*SearchInboxesResponse, error) {
	rsp, err := c.SearchInboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchInboxesResponse(rsp)
}

// SearchKworksCatalogQueryWithResponse request returning *SearchKworksCatalogQueryResponse
func (c *ClientWithResponses) SearchKworksCatalogQueryWithResponse(ctx context.Context, params *SearchKworksCatalogQueryParams, reqEditors ...RequestEditorFn) (*SearchKworksCatalogQueryResponse, error) {
	rsp, err := c.SearchKworksCatalogQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchKworksCatalogQueryResponse(rsp)
}

// SearchMessagesWithResponse request returning *SearchMessagesResponse
func (c *ClientWithResponses) SearchMessagesWithResponse(ctx context.Context, params *SearchMessagesParams, reqEditors ...RequestEditorFn) (*SearchMessagesResponse, error) {
	rsp, err := c.SearchMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMessagesResponse(rsp)
}

// SearchOrderTracksWithResponse request returning *SearchOrderTracksResponse
func (c *ClientWithResponses) SearchOrderTracksWithResponse(ctx context.Context, params *SearchOrderTracksParams, reqEditors ...RequestEditorFn) (*SearchOrderTracksResponse, error) {
	rsp, err := c.SearchOrderTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchOrderTracksResponse(rsp)
}

// SearchTracksWithResponse request returning *SearchTracksResponse
func (c *ClientWithResponses) SearchTracksWithResponse(ctx context.Context, params *SearchTracksParams, reqEditors ...RequestEditorFn) (*SearchTracksResponse, error) {
	rsp, err := c.SearchTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTracksResponse(rsp)
}

// SendBonusWithResponse request returning *SendBonusResponse
func (c *ClientWithResponses) SendBonusWithResponse(ctx context.Context, params *SendBonusParams, reqEditors ...RequestEditorFn) (*SendBonusResponse, error) {
	rsp, err := c.SendBonus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendBonusResponse(rsp)
}

// SendCompanyForVerificationWithResponse request returning *SendCompanyForVerificationResponse
func (c *ClientWithResponses) SendCompanyForVerificationWithResponse(ctx context.Context, params *SendCompanyForVerificationParams, reqEditors ...RequestEditorFn) (*SendCompanyForVerificationResponse, error) {
	rsp, err := c.SendCompanyForVerification(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendCompanyForVerificationResponse(rsp)
}

// SendOrderForApprovalWithResponse request returning *SendOrderForApprovalResponse
func (c *ClientWithResponses) SendOrderForApprovalWithResponse(ctx context.Context, params *SendOrderForApprovalParams, reqEditors ...RequestEditorFn) (*SendOrderForApprovalResponse, error) {
	rsp, err := c.SendOrderForApproval(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOrderForApprovalResponse(rsp)
}

// SendOrderForArbitrationWithResponse request returning *SendOrderForArbitrationResponse
func (c *ClientWithResponses) SendOrderForArbitrationWithResponse(ctx context.Context, params *SendOrderForArbitrationParams, reqEditors ...RequestEditorFn) (*SendOrderForArbitrationResponse, error) {
	rsp, err := c.SendOrderForArbitration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOrderForArbitrationResponse(rsp)
}

// SendOrderForRevisionWithResponse request returning *SendOrderForRevisionResponse
func (c *ClientWithResponses) SendOrderForRevisionWithResponse(ctx context.Context, params *SendOrderForRevisionParams, reqEditors ...RequestEditorFn) (*SendOrderForRevisionResponse, error) {
	rsp, err := c.SendOrderForRevision(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOrderForRevisionResponse(rsp)
}

// SendOrderReceiptLinkForVerificationWithResponse request returning *SendOrderReceiptLinkForVerificationResponse
func (c *ClientWithResponses) SendOrderReceiptLinkForVerificationWithResponse(ctx context.Context, params *SendOrderReceiptLinkForVerificationParams, reqEditors ...RequestEditorFn) (*SendOrderReceiptLinkForVerificationResponse, error) {
	rsp, err := c.SendOrderReceiptLinkForVerification(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOrderReceiptLinkForVerificationResponse(rsp)
}

// SendOrderRequirementsWithResponse request returning *SendOrderRequirementsResponse
func (c *ClientWithResponses) SendOrderRequirementsWithResponse(ctx context.Context, params *SendOrderRequirementsParams, reqEditors ...RequestEditorFn) (*SendOrderRequirementsResponse, error) {
	rsp, err := c.SendOrderRequirements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendOrderRequirementsResponse(rsp)
}

// SendReportWithResponse request returning *SendReportResponse
func (c *ClientWithResponses) SendReportWithResponse(ctx context.Context, params *SendReportParams, reqEditors ...RequestEditorFn) (*SendReportResponse, error) {
	rsp, err := c.SendReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReportResponse(rsp)
}

// SendSelfEmployedSurveyResultWithResponse request returning *SendSelfEmployedSurveyResultResponse
func (c *ClientWithResponses) SendSelfEmployedSurveyResultWithResponse(ctx context.Context, params *SendSelfEmployedSurveyResultParams, reqEditors ...RequestEditorFn) (*SendSelfEmployedSurveyResultResponse, error) {
	rsp, err := c.SendSelfEmployedSurveyResult(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendSelfEmployedSurveyResultResponse(rsp)
}

// SendUserStatusWithResponse request returning *SendUserStatusResponse
func (c *ClientWithResponses) SendUserStatusWithResponse(ctx context.Context, params *SendUserStatusParams, reqEditors ...RequestEditorFn) (*SendUserStatusResponse, error) {
	rsp, err := c.SendUserStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserStatusResponse(rsp)
}

// SendWhatsAppCodeWithResponse request returning *SendWhatsAppCodeResponse
func (c *ClientWithResponses) SendWhatsAppCodeWithResponse(ctx context.Context, params *SendWhatsAppCodeParams, reqEditors ...RequestEditorFn) (*SendWhatsAppCodeResponse, error) {
	rsp, err := c.SendWhatsAppCode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendWhatsAppCodeResponse(rsp)
}

// SetAvailableAtWeekendsWithResponse request returning *SetAvailableAtWeekendsResponse
func (c *ClientWithResponses) SetAvailableAtWeekendsWithResponse(ctx context.Context, params *SetAvailableAtWeekendsParams, reqEditors ...RequestEditorFn) (*SetAvailableAtWeekendsResponse, error) {
	rsp, err := c.SetAvailableAtWeekends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAvailableAtWeekendsResponse(rsp)
}

// SetDialogStarredWithResponse request returning *SetDialogStarredResponse
func (c *ClientWithResponses) SetDialogStarredWithResponse(ctx context.Context, params *SetDialogStarredParams, reqEditors ...RequestEditorFn) (*SetDialogStarredResponse, error) {
	rsp, err := c.SetDialogStarred(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDialogStarredResponse(rsp)
}

// SetFavoriteWithResponse request returning *SetFavoriteResponse
func (c *ClientWithResponses) SetFavoriteWithResponse(ctx context.Context, params *SetFavoriteParams, reqEditors ...RequestEditorFn) (*SetFavoriteResponse, error) {
	rsp, err := c.SetFavorite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFavoriteResponse(rsp)
}

// SetFishingTutorialStatusWithResponse request returning *SetFishingTutorialStatusResponse
func (c *ClientWithResponses) SetFishingTutorialStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SetFishingTutorialStatusResponse, error) {
	rsp, err := c.SetFishingTutorialStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFishingTutorialStatusResponse(rsp)
}

// SetOrderRatingWithResponse request returning *SetOrderRatingResponse
func (c *ClientWithResponses) SetOrderRatingWithResponse(ctx context.Context, params *SetOrderRatingParams, reqEditors ...RequestEditorFn) (*SetOrderRatingResponse, error) {
	rsp, err := c.SetOrderRating(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOrderRatingResponse(rsp)
}

// SetTakingOrdersWithResponse request returning *SetTakingOrdersResponse
func (c *ClientWithResponses) SetTakingOrdersWithResponse(ctx context.Context, params *SetTakingOrdersParams, reqEditors ...RequestEditorFn) (*SetTakingOrdersResponse, error) {
	rsp, err := c.SetTakingOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetTakingOrdersResponse(rsp)
}

// SetUserTypeWithResponse request returning *SetUserTypeResponse
func (c *ClientWithResponses) SetUserTypeWithResponse(ctx context.Context, params *SetUserTypeParams, reqEditors ...RequestEditorFn) (*SetUserTypeResponse, error) {
	rsp, err := c.SetUserType(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUserTypeResponse(rsp)
}

// SetVoiceMessageReceivingWithResponse request returning *SetVoiceMessageReceivingResponse
func (c *ClientWithResponses) SetVoiceMessageReceivingWithResponse(ctx context.Context, params *SetVoiceMessageReceivingParams, reqEditors ...RequestEditorFn) (*SetVoiceMessageReceivingResponse, error) {
	rsp, err := c.SetVoiceMessageReceiving(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVoiceMessageReceivingResponse(rsp)
}

// SetVoiceMessageSpeedWithResponse request returning *SetVoiceMessageSpeedResponse
func (c *ClientWithResponses) SetVoiceMessageSpeedWithResponse(ctx context.Context, params *SetVoiceMessageSpeedParams, reqEditors ...RequestEditorFn) (*SetVoiceMessageSpeedResponse, error) {
	rsp, err := c.SetVoiceMessageSpeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVoiceMessageSpeedResponse(rsp)
}

// SignInWithBodyWithResponse request with arbitrary body returning *SignInResponse
func (c *ClientWithResponses) SignInWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignInResponse, error) {
	rsp, err := c.SignInWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignInResponse(rsp)
}

func (c *ClientWithResponses) SignInWithFormdataBodyWithResponse(ctx context.Context, body SignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*SignInResponse, error) {
	rsp, err := c.SignInWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignInResponse(rsp)
}

// SignUpWithBodyWithResponse request with arbitrary body returning *SignUpResponse
func (c *ClientWithResponses) SignUpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignUpResponse, error) {
	rsp, err := c.SignUpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignUpResponse(rsp)
}

func (c *ClientWithResponses) SignUpWithFormdataBodyWithResponse(ctx context.Context, body SignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*SignUpResponse, error) {
	rsp, err := c.SignUpWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignUpResponse(rsp)
}

// SocialSignInWithBodyWithResponse request with arbitrary body returning *SocialSignInResponse
func (c *ClientWithResponses) SocialSignInWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignInResponse, error) {
	rsp, err := c.SocialSignInWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignInResponse(rsp)
}

func (c *ClientWithResponses) SocialSignInWithFormdataBodyWithResponse(ctx context.Context, body SocialSignInFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignInResponse, error) {
	rsp, err := c.SocialSignInWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignInResponse(rsp)
}

// SocialSignInByTokenWithBodyWithResponse request with arbitrary body returning *SocialSignInByTokenResponse
func (c *ClientWithResponses) SocialSignInByTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignInByTokenResponse, error) {
	rsp, err := c.SocialSignInByTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignInByTokenResponse(rsp)
}

func (c *ClientWithResponses) SocialSignInByTokenWithFormdataBodyWithResponse(ctx context.Context, body SocialSignInByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignInByTokenResponse, error) {
	rsp, err := c.SocialSignInByTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignInByTokenResponse(rsp)
}

// SocialSignInByTokenv2WithBodyWithResponse request with arbitrary body returning *SocialSignInByTokenv2Response
func (c *ClientWithResponses) SocialSignInByTokenv2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignInByTokenv2Response, error) {
	rsp, err := c.SocialSignInByTokenv2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignInByTokenv2Response(rsp)
}

func (c *ClientWithResponses) SocialSignInByTokenv2WithFormdataBodyWithResponse(ctx context.Context, body SocialSignInByTokenv2FormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignInByTokenv2Response, error) {
	rsp, err := c.SocialSignInByTokenv2WithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignInByTokenv2Response(rsp)
}

// SocialSignUpWithBodyWithResponse request with arbitrary body returning *SocialSignUpResponse
func (c *ClientWithResponses) SocialSignUpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignUpResponse, error) {
	rsp, err := c.SocialSignUpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignUpResponse(rsp)
}

func (c *ClientWithResponses) SocialSignUpWithFormdataBodyWithResponse(ctx context.Context, body SocialSignUpFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignUpResponse, error) {
	rsp, err := c.SocialSignUpWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignUpResponse(rsp)
}

// SocialSignUpByTokenWithBodyWithResponse request with arbitrary body returning *SocialSignUpByTokenResponse
func (c *ClientWithResponses) SocialSignUpByTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialSignUpByTokenResponse, error) {
	rsp, err := c.SocialSignUpByTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignUpByTokenResponse(rsp)
}

func (c *ClientWithResponses) SocialSignUpByTokenWithFormdataBodyWithResponse(ctx context.Context, body SocialSignUpByTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*SocialSignUpByTokenResponse, error) {
	rsp, err := c.SocialSignUpByTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialSignUpByTokenResponse(rsp)
}

// StartKworkWithResponse request returning *StartKworkResponse
func (c *ClientWithResponses) StartKworkWithResponse(ctx context.Context, params *StartKworkParams, reqEditors ...RequestEditorFn) (*StartKworkResponse, error) {
	rsp, err := c.StartKwork(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartKworkResponse(rsp)
}

// StopWantWithResponse request returning *StopWantResponse
func (c *ClientWithResponses) StopWantWithResponse(ctx context.Context, params *StopWantParams, reqEditors ...RequestEditorFn) (*StopWantResponse, error) {
	rsp, err := c.StopWant(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopWantResponse(rsp)
}

// SuggestStagesWithResponse request returning *SuggestStagesResponse
func (c *ClientWithResponses) SuggestStagesWithResponse(ctx context.Context, params *SuggestStagesParams, reqEditors ...RequestEditorFn) (*SuggestStagesResponse, error) {
	rsp, err := c.SuggestStages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuggestStagesResponse(rsp)
}

// TermsWithResponse request returning *TermsResponse
func (c *ClientWithResponses) TermsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TermsResponse, error) {
	rsp, err := c.Terms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTermsResponse(rsp)
}

// TermsOfServiceWithResponse request returning *TermsOfServiceResponse
func (c *ClientWithResponses) TermsOfServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TermsOfServiceResponse, error) {
	rsp, err := c.TermsOfService(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTermsOfServiceResponse(rsp)
}

// TimezonesWithResponse request returning *TimezonesResponse
func (c *ClientWithResponses) TimezonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TimezonesResponse, error) {
	rsp, err := c.Timezones(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimezonesResponse(rsp)
}

// TrackDeleteWithResponse request returning *TrackDeleteResponse
func (c *ClientWithResponses) TrackDeleteWithResponse(ctx context.Context, params *TrackDeleteParams, reqEditors ...RequestEditorFn) (*TrackDeleteResponse, error) {
	rsp, err := c.TrackDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackDeleteResponse(rsp)
}

// TrackEditWithBodyWithResponse request with arbitrary body returning *TrackEditResponse
func (c *ClientWithResponses) TrackEditWithBodyWithResponse(ctx context.Context, params *TrackEditParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TrackEditResponse, error) {
	rsp, err := c.TrackEditWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackEditResponse(rsp)
}

func (c *ClientWithResponses) TrackEditWithFormdataBodyWithResponse(ctx context.Context, params *TrackEditParams, body TrackEditFormdataRequestBody, reqEditors ...RequestEditorFn) (*TrackEditResponse, error) {
	rsp, err := c.TrackEditWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackEditResponse(rsp)
}

// TrackMessageWithResponse request returning *TrackMessageResponse
func (c *ClientWithResponses) TrackMessageWithResponse(ctx context.Context, params *TrackMessageParams, reqEditors ...RequestEditorFn) (*TrackMessageResponse, error) {
	rsp, err := c.TrackMessage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackMessageResponse(rsp)
}

// TrackReadWithResponse request returning *TrackReadResponse
func (c *ClientWithResponses) TrackReadWithResponse(ctx context.Context, params *TrackReadParams, reqEditors ...RequestEditorFn) (*TrackReadResponse, error) {
	rsp, err := c.TrackRead(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackReadResponse(rsp)
}

// TranslationLanguagesWithResponse request returning *TranslationLanguagesResponse
func (c *ClientWithResponses) TranslationLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TranslationLanguagesResponse, error) {
	rsp, err := c.TranslationLanguages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTranslationLanguagesResponse(rsp)
}

// TypingWithResponse request returning *TypingResponse
func (c *ClientWithResponses) TypingWithResponse(ctx context.Context, params *TypingParams, reqEditors ...RequestEditorFn) (*TypingResponse, error) {
	rsp, err := c.Typing(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTypingResponse(rsp)
}

// UnarchiveDialogWithResponse request returning *UnarchiveDialogResponse
func (c *ClientWithResponses) UnarchiveDialogWithResponse(ctx context.Context, params *UnarchiveDialogParams, reqEditors ...RequestEditorFn) (*UnarchiveDialogResponse, error) {
	rsp, err := c.UnarchiveDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDialogResponse(rsp)
}

// UnblockDialogWithResponse request returning *UnblockDialogResponse
func (c *ClientWithResponses) UnblockDialogWithResponse(ctx context.Context, params *UnblockDialogParams, reqEditors ...RequestEditorFn) (*UnblockDialogResponse, error) {
	rsp, err := c.UnblockDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnblockDialogResponse(rsp)
}

// UnreadDialogWithResponse request returning *UnreadDialogResponse
func (c *ClientWithResponses) UnreadDialogWithResponse(ctx context.Context, params *UnreadDialogParams, reqEditors ...RequestEditorFn) (*UnreadDialogResponse, error) {
	rsp, err := c.UnreadDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnreadDialogResponse(rsp)
}

// UpdateAvatarWithBodyWithResponse request with arbitrary body returning *UpdateAvatarResponse
func (c *ClientWithResponses) UpdateAvatarWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAvatarResponse, error) {
	rsp, err := c.UpdateAvatarWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAvatarResponse(rsp)
}

// UpdateChatDraftMessageWithResponse request returning *UpdateChatDraftMessageResponse
func (c *ClientWithResponses) UpdateChatDraftMessageWithResponse(ctx context.Context, params *UpdateChatDraftMessageParams, reqEditors ...RequestEditorFn) (*UpdateChatDraftMessageResponse, error) {
	rsp, err := c.UpdateChatDraftMessage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChatDraftMessageResponse(rsp)
}

// UpdateOrderDraftMessageWithResponse request returning *UpdateOrderDraftMessageResponse
func (c *ClientWithResponses) UpdateOrderDraftMessageWithResponse(ctx context.Context, params *UpdateOrderDraftMessageParams, reqEditors ...RequestEditorFn) (*UpdateOrderDraftMessageResponse, error) {
	rsp, err := c.UpdateOrderDraftMessage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrderDraftMessageResponse(rsp)
}

// UpdateSettingsWithBodyWithResponse request with arbitrary body returning *UpdateSettingsResponse
func (c *ClientWithResponses) UpdateSettingsWithBodyWithResponse(ctx context.Context, params *UpdateSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error) {
	rsp, err := c.UpdateSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsResponse(rsp)
}

// UpdateStageProgressWithResponse request returning *UpdateStageProgressResponse
func (c *ClientWithResponses) UpdateStageProgressWithResponse(ctx context.Context, params *UpdateStageProgressParams, reqEditors ...RequestEditorFn) (*UpdateStageProgressResponse, error) {
	rsp, err := c.UpdateStageProgress(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStageProgressResponse(rsp)
}

// UploadCoverWithBodyWithResponse request with arbitrary body returning *UploadCoverResponse
func (c *ClientWithResponses) UploadCoverWithBodyWithResponse(ctx context.Context, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCoverResponse, error) {
	rsp, err := c.UploadCoverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCoverResponse(rsp)
}

// UploadLogWithBodyWithResponse request with arbitrary body returning *UploadLogResponse
func (c *ClientWithResponses) UploadLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLogResponse, error) {
	rsp, err := c.UploadLogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLogResponse(rsp)
}

// UploadPortfolioFileWithBodyWithResponse request with arbitrary body returning *UploadPortfolioFileResponse
func (c *ClientWithResponses) UploadPortfolioFileWithBodyWithResponse(ctx context.Context, params *UploadPortfolioFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPortfolioFileResponse, error) {
	rsp, err := c.UploadPortfolioFileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPortfolioFileResponse(rsp)
}

// UploadedFileWithResponse request returning *UploadedFileResponse
func (c *ClientWithResponses) UploadedFileWithResponse(ctx context.Context, params *UploadedFileParams, reqEditors ...RequestEditorFn) (*UploadedFileResponse, error) {
	rsp, err := c.UploadedFile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadedFileResponse(rsp)
}

// UserWithResponse request returning *UserResponse
func (c *ClientWithResponses) UserWithResponse(ctx context.Context, params *UserParams, reqEditors ...RequestEditorFn) (*UserResponse, error) {
	rsp, err := c.User(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserResponse(rsp)
}

// UserByUsernameWithResponse request returning *UserByUsernameResponse
func (c *ClientWithResponses) UserByUsernameWithResponse(ctx context.Context, params *UserByUsernameParams, reqEditors ...RequestEditorFn) (*UserByUsernameResponse, error) {
	rsp, err := c.UserByUsername(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserByUsernameResponse(rsp)
}

// UserKworksWithResponse request returning *UserKworksResponse
func (c *ClientWithResponses) UserKworksWithResponse(ctx context.Context, params *UserKworksParams, reqEditors ...RequestEditorFn) (*UserKworksResponse, error) {
	rsp, err := c.UserKworks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserKworksResponse(rsp)
}

// UserReviewsWithResponse request returning *UserReviewsResponse
func (c *ClientWithResponses) UserReviewsWithResponse(ctx context.Context, params *UserReviewsParams, reqEditors ...RequestEditorFn) (*UserReviewsResponse, error) {
	rsp, err := c.UserReviews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserReviewsResponse(rsp)
}

// UserSearchWithResponse request returning *UserSearchResponse
func (c *ClientWithResponses) UserSearchWithResponse(ctx context.Context, params *UserSearchParams, reqEditors ...RequestEditorFn) (*UserSearchResponse, error) {
	rsp, err := c.UserSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSearchResponse(rsp)
}

// VerifyPhoneActivationCodeWithResponse request returning *VerifyPhoneActivationCodeResponse
func (c *ClientWithResponses) VerifyPhoneActivationCodeWithResponse(ctx context.Context, params *VerifyPhoneActivationCodeParams, reqEditors ...RequestEditorFn) (*VerifyPhoneActivationCodeResponse, error) {
	rsp, err := c.VerifyPhoneActivationCode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyPhoneActivationCodeResponse(rsp)
}

// VerifySmsCodeForAccountDeletingWithResponse request returning *VerifySmsCodeForAccountDeletingResponse
func (c *ClientWithResponses) VerifySmsCodeForAccountDeletingWithResponse(ctx context.Context, params *VerifySmsCodeForAccountDeletingParams, reqEditors ...RequestEditorFn) (*VerifySmsCodeForAccountDeletingResponse, error) {
	rsp, err := c.VerifySmsCodeForAccountDeleting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifySmsCodeForAccountDeletingResponse(rsp)
}

// ViewedCatalogKworksWithResponse request returning *ViewedCatalogKworksResponse
func (c *ClientWithResponses) ViewedCatalogKworksWithResponse(ctx context.Context, params *ViewedCatalogKworksParams, reqEditors ...RequestEditorFn) (*ViewedCatalogKworksResponse, error) {
	rsp, err := c.ViewedCatalogKworks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViewedCatalogKworksResponse(rsp)
}

// VoiceUploadWithBodyWithResponse request with arbitrary body returning *VoiceUploadResponse
func (c *ClientWithResponses) VoiceUploadWithBodyWithResponse(ctx context.Context, params *VoiceUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VoiceUploadResponse, error) {
	rsp, err := c.VoiceUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoiceUploadResponse(rsp)
}

// WantWithResponse request returning *WantResponse
func (c *ClientWithResponses) WantWithResponse(ctx context.Context, params *WantParams, reqEditors ...RequestEditorFn) (*WantResponse, error) {
	rsp, err := c.Want(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWantResponse(rsp)
}

// WantsStatusListWithResponse request returning *WantsStatusListResponse
func (c *ClientWithResponses) WantsStatusListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WantsStatusListResponse, error) {
	rsp, err := c.WantsStatusList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWantsStatusListResponse(rsp)
}

// WorkerConfirmsExtraRemovalRequestWithResponse request returning *WorkerConfirmsExtraRemovalRequestResponse
func (c *ClientWithResponses) WorkerConfirmsExtraRemovalRequestWithResponse(ctx context.Context, params *WorkerConfirmsExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*WorkerConfirmsExtraRemovalRequestResponse, error) {
	rsp, err := c.WorkerConfirmsExtraRemovalRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerConfirmsExtraRemovalRequestResponse(rsp)
}

// WorkerDeclineExtrasWithResponse request returning *WorkerDeclineExtrasResponse
func (c *ClientWithResponses) WorkerDeclineExtrasWithResponse(ctx context.Context, params *WorkerDeclineExtrasParams, reqEditors ...RequestEditorFn) (*WorkerDeclineExtrasResponse, error) {
	rsp, err := c.WorkerDeclineExtras(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerDeclineExtrasResponse(rsp)
}

// WorkerDeclinesExtraRemovalRequestWithResponse request returning *WorkerDeclinesExtraRemovalRequestResponse
func (c *ClientWithResponses) WorkerDeclinesExtraRemovalRequestWithResponse(ctx context.Context, params *WorkerDeclinesExtraRemovalRequestParams, reqEditors ...RequestEditorFn) (*WorkerDeclinesExtraRemovalRequestResponse, error) {
	rsp, err := c.WorkerDeclinesExtraRemovalRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerDeclinesExtraRemovalRequestResponse(rsp)
}

// WorkerExtraDeleteWithResponse request returning *WorkerExtraDeleteResponse
func (c *ClientWithResponses) WorkerExtraDeleteWithResponse(ctx context.Context, params *WorkerExtraDeleteParams, reqEditors ...RequestEditorFn) (*WorkerExtraDeleteResponse, error) {
	rsp, err := c.WorkerExtraDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerExtraDeleteResponse(rsp)
}

// WorkerInprogressWithResponse request returning *WorkerInprogressResponse
func (c *ClientWithResponses) WorkerInprogressWithResponse(ctx context.Context, params *WorkerInprogressParams, reqEditors ...RequestEditorFn) (*WorkerInprogressResponse, error) {
	rsp, err := c.WorkerInprogress(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerInprogressResponse(rsp)
}

// WorkerOrdersWithResponse request returning *WorkerOrdersResponse
func (c *ClientWithResponses) WorkerOrdersWithResponse(ctx context.Context, params *WorkerOrdersParams, reqEditors ...RequestEditorFn) (*WorkerOrdersResponse, error) {
	rsp, err := c.WorkerOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerOrdersResponse(rsp)
}

// ParseAcceptExtrasResponse parses an HTTP response from a AcceptExtrasWithResponse call
func ParseAcceptExtrasResponse(rsp *http.Response) (*AcceptExtrasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptExtrasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest BalanceDeficit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAcceptStageSuggestionResponse parses an HTTP response from a AcceptStageSuggestionWithResponse call
func ParseAcceptStageSuggestionResponse(rsp *http.Response) (*AcceptStageSuggestionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptStageSuggestionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActorResponse parses an HTTP response from a ActorWithResponse call
func ParseActorResponse(rsp *http.Response) (*ActorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// AchievmentsList Бейдж пользователя
				AchievmentsList *ProfileBadges `json:"achievments_list,omitempty"`

				// Addtime Дата регистрации
				Addtime *int `json:"addtime,omitempty"`

				// AllowMobilePush Разрешена ли отправка пушей в мобильное приложение через FCM
				AllowMobilePush *bool `json:"allow_mobile_push,omitempty"`

				// AppNotifyCount Количество непрочитанных уведомлений, кроме [want, kworkActive, kworkRejected]
				AppNotifyCount *int `json:"app_notify_count,omitempty"`

				// ArchivedWantsCount Количество архивных запросов пользователя
				ArchivedWantsCount *int `json:"archived_wants_count,omitempty"`

				// BadReviews Количество отрицательныз отзывов
				BadReviews *int `json:"bad_reviews,omitempty"`

				// BlackFridayForSellers Активность акции ЧП для продавцов
				BlackFridayForSellers *bool `json:"black_friday_for_sellers,omitempty"`

				// CityId Идентификатор города
				CityId *int `json:"city_id,omitempty"`

				// CompletedOrdersCount Кол-во выполненных заказов
				CompletedOrdersCount *int `json:"completed_orders_count,omitempty"`

				// CountryId Идентификатор страны
				CountryId *int `json:"country_id,omitempty"`

				// Cover Путь к баннеру пользователя
				Cover *string `json:"cover,omitempty"`

				// Currency Валюта
				Currency *string `json:"currency,omitempty"`

				// Description Текст о себе
				Description *string `json:"description,omitempty"`

				// Email E-mail
				Email *string `json:"email,omitempty"`

				// FavouriteKworksCount Кол-во избранных кворков
				FavouriteKworksCount *int `json:"favourite_kworks_count,omitempty"`

				// FreeAmount Баланс свободный
				FreeAmount *float32 `json:"free_amount,omitempty"`

				// Fullname Настоящее имя
				Fullname *string `json:"fullname,omitempty"`

				// GoodReviews Количество положительных отзывов
				GoodReviews *int `json:"good_reviews,omitempty"`

				// HasOffers Есть ли у пользователя активные предложения
				HasOffers *bool `json:"has_offers,omitempty"`

				// HiddenKworksCount Кол-во скрытых кворков
				HiddenKworksCount *int `json:"hidden_kworks_count,omitempty"`

				// HoldAmount Баланс заблокировано
				HoldAmount *float32 `json:"hold_amount,omitempty"`

				// Id Идентификатор пользователя
				Id *int `json:"id,omitempty"`

				// InboxArchiveCount Количество диалогов в архиве
				InboxArchiveCount *int `json:"inbox_archive_count,omitempty"`

				// IsMorePayer Пользователь больше покупатель, чем продавец
				IsMorePayer *bool `json:"is_more_payer,omitempty"`

				// Kworks Кворки пользователя
				Kworks *ProfileKworks `json:"kworks,omitempty"`

				// KworksAvailableAtWeekends Флаг, показывающий доступны ли кворки на выходных
				KworksAvailableAtWeekends *bool `json:"kworks_available_at_weekends,omitempty"`

				// KworksCount Кол-во кворков актора
				KworksCount *int `json:"kworks_count,omitempty"`

				// LevelDescription Название уровня продавца
				LevelDescription *string `json:"level_description,omitempty"`

				// Location Город или страна
				Location *string `json:"location,omitempty"`

				// NotifyUnreadCount Количество непрочитанных уведомлений
				NotifyUnreadCount *int `json:"notify_unread_count,omitempty"`

				// OffersCount Количество предложений пользователя
				OffersCount *int `json:"offers_count,omitempty"`

				// PortfolioList Портфолио пользователя
				PortfolioList *ProfilePortfolios `json:"portfolio_list,omitempty"`

				// Profession Специальность пользователя
				Profession *string `json:"profession"`

				// Profilepicture Путь к изображению аватара
				Profilepicture *string `json:"profilepicture,omitempty"`

				// PushNotificationsSoundAllowed Включен ли звук в мобильных пуш уведомлениях
				PushNotificationsSoundAllowed *bool `json:"pushNotificationsSoundAllowed,omitempty"`

				// Rating Рейтинг по 5 бальной шкале с 1 десятичным знаком
				Rating *string `json:"rating,omitempty"`

				// RatingCount Количество отзывов
				RatingCount *int `json:"rating_count,omitempty"`

				// RedNotify Есть ли важные непрочитанные уведомления
				RedNotify *bool `json:"red_notify,omitempty"`

				// Reviews Массив отзывов
				Reviews *[]UserReview `json:"reviews,omitempty"`

				// Slogan Слоган - не заполнен
				Slogan *string `json:"slogan,omitempty"`

				// Status Статус
				Status *string `json:"status,omitempty"`

				// TimezoneId Идентификатор часового пояса
				TimezoneId *int `json:"timezone_id,omitempty"`

				// TotalAmount Баланс общий
				TotalAmount *float32 `json:"total_amount,omitempty"`

				// Type Текущая роль пользователя worker|payer
				Type *string `json:"type,omitempty"`

				// UnreadDialogCount Количество непрочитанных диалогов
				UnreadDialogCount *int `json:"unread_dialog_count,omitempty"`

				// UnreadMessagesCount Количество непрочитанных сообщений
				UnreadMessagesCount *int `json:"unread_messages_count,omitempty"`

				// Username Имя пользователя
				Username *string `json:"username,omitempty"`

				// Verified Подтвержден ли email
				Verified *bool `json:"verified,omitempty"`

				// WantsCount Количество запросов пользователя
				WantsCount *int `json:"wants_count,omitempty"`

				// WarningInboxCount Количество важных непрочитанных диалогов
				WarningInboxCount *int `json:"warning_inbox_count,omitempty"`

				// WorkerStatus Статус продавца (null, free, busy)
				WorkerStatus *string `json:"worker_status,omitempty"`

				// YescrowApplicants Дочерние роли
				YescrowApplicants *struct {
					// Payer Дочерняя роль - покупатель
					Payer *struct {
						// Status Статус проверки (0 - На проверке, 1 - Успешно, 2 - Отклонено)
						Status *int `json:"status,omitempty"`

						// Type Тип (2 - Юридическое лицо покупатель, 3 - Самозанятый покупатель, 4 - ИП покупатель)
						Type *int `json:"type,omitempty"`
					} `json:"payer,omitempty"`

					// Worker Дочерняя роль - продавец
					Worker *struct {
						// Status Статус проверки (0 - На проверке, 1 - Успешно, 2 - Отклонено)
						Status *int `json:"status,omitempty"`

						// Type Тип (0 - Самозанятый продавец, 1 - ИП продавец)
						Type *int `json:"type,omitempty"`
					} `json:"worker,omitempty"`
				} `json:"yescrow_applicants,omitempty"`

				// YescrowPayer Дочерние роли покупателя
				YescrowPayer *struct {
					// Company Компания
					Company *struct {
						// Name Название компании
						Name *string `json:"name,omitempty"`

						// Status Статус компании (0 - Проверка инициирована, 1 - Проверка пройдена, 2 - Проверка отклонена)
						Status *int `json:"status,omitempty"`
					} `json:"company,omitempty"`

					// CompanyBalance Баланс компании
					CompanyBalance *float32 `json:"company_balance,omitempty"`

					// Role Дочерняя роль (0 - Частное лицо, 1 - Компания)
					Role *int `json:"role,omitempty"`
				} `json:"yescrow_payer,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddFavoriteCategoriesResponse parses an HTTP response from a AddFavoriteCategoriesWithResponse call
func ParseAddFavoriteCategoriesResponse(rsp *http.Response) (*AddFavoriteCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFavoriteCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddNewPhoneNumberResponse parses an HTTP response from a AddNewPhoneNumberWithResponse call
func ParseAddNewPhoneNumberResponse(rsp *http.Response) (*AddNewPhoneNumberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddNewPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ConfirmationType Тип уведомления call/sms/digits
				ConfirmationType *string `json:"confirmation_type,omitempty"`

				// Phone Маска номера телефона
				Phone *string `json:"phone,omitempty"`

				// TelegramBotLink Ссылка для Telegram
				TelegramBotLink *string `json:"telegram_bot_link,omitempty"`

				// Timeout Время через которое можно повторить отправку
				Timeout *int `json:"timeout,omitempty"`

				// WhatsappLink Ссылка для WhatsApp
				WhatsappLink *string `json:"whatsapp_link,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPhoneNumberResponse parses an HTTP response from a AddPhoneNumberWithResponse call
func ParseAddPhoneNumberResponse(rsp *http.Response) (*AddPhoneNumberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ConfirmationType Тип уведомления call/sms/digits
				ConfirmationType *string `json:"confirmation_type,omitempty"`

				// Phone Маска номера телефона
				Phone *string `json:"phone,omitempty"`

				// TelegramBotLink Ссылка для Telegram
				TelegramBotLink *string `json:"telegram_bot_link,omitempty"`

				// Timeout Время через которое можно повторить отправку
				Timeout *int `json:"timeout,omitempty"`

				// WhatsappLink Ссылка для WhatsApp
				WhatsappLink *string `json:"whatsapp_link,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddStageResponse parses an HTTP response from a AddStageWithResponse call
func ParseAddStageResponse(rsp *http.Response) (*AddStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAllowInboxRequestResponse parses an HTTP response from a AllowInboxRequestWithResponse call
func ParseAllowInboxRequestResponse(rsp *http.Response) (*AllowInboxRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllowInboxRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAllowMobilePushResponse parses an HTTP response from a AllowMobilePushWithResponse call
func ParseAllowMobilePushResponse(rsp *http.Response) (*AllowMobilePushResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllowMobilePushResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAllowOrderPortfolioUploadResponse parses an HTTP response from a AllowOrderPortfolioUploadWithResponse call
func ParseAllowOrderPortfolioUploadResponse(rsp *http.Response) (*AllowOrderPortfolioUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllowOrderPortfolioUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAllowPushNotificationsSoundResponse parses an HTTP response from a AllowPushNotificationsSoundWithResponse call
func ParseAllowPushNotificationsSoundResponse(rsp *http.Response) (*AllowPushNotificationsSoundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllowPushNotificationsSoundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAppleSignInResponse parses an HTTP response from a AppleSignInWithResponse call
func ParseAppleSignInResponse(rsp *http.Response) (*AppleSignInResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppleSignInResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseApplyFiltersResponse parses an HTTP response from a ApplyFiltersWithResponse call
func ParseApplyFiltersResponse(rsp *http.Response) (*ApplyFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplyFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseApproveOrderResponse parses an HTTP response from a ApproveOrderWithResponse call
func ParseApproveOrderResponse(rsp *http.Response) (*ApproveOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// CurrentStatus Название статуса, который присвоен юзеру
				CurrentStatus *string `json:"current_status,omitempty"`

				// CurrentStatusIcon Абсолютный путь для ссылки на картинку уровня
				CurrentStatusIcon *string `json:"current_status_icon,omitempty"`

				// NextStatus Название следующего уровня
				NextStatus *string `json:"next_status,omitempty"`

				// NextStatusBorder Количество заказов до следующего уровня.
				NextStatusBorder *int `json:"next_status_border,omitempty"`

				// OrderDeliveryTime За какое время был выполнен заказ
				OrderDeliveryTime *int `json:"order_delivery_time,omitempty"`

				// OrdersApproved Сколько заказов завершил покупатель
				OrdersApproved *int `json:"orders_approved,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseApproveOrderStageResponse parses an HTTP response from a ApproveOrderStageWithResponse call
func ParseApproveOrderStageResponse(rsp *http.Response) (*ApproveOrderStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveOrderStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// CurrentStatus Название статуса, который присвоен юзеру
				CurrentStatus *string `json:"current_status,omitempty"`

				// CurrentStatusIcon Абсолютный путь для ссылки на картинку уровня
				CurrentStatusIcon *string `json:"current_status_icon,omitempty"`

				// NextStatus Название следующего уровня
				NextStatus *string `json:"next_status,omitempty"`

				// NextStatusBorder Количество заказов до следующего уровня.
				NextStatusBorder *int `json:"next_status_border,omitempty"`

				// OrderDeliveryTime За какое время был выполнен заказ
				OrderDeliveryTime *int `json:"order_delivery_time,omitempty"`

				// OrdersApproved Сколько заказов завершил покупатель
				OrdersApproved *int `json:"orders_approved,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseArchiveDialogResponse parses an HTTP response from a ArchiveDialogWithResponse call
func ParseArchiveDialogResponse(rsp *http.Response) (*ArchiveDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBlockDialogResponse parses an HTTP response from a BlockDialogWithResponse call
func ParseBlockDialogResponse(rsp *http.Response) (*BlockDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Message Сообщение об успехе
				Message *string `json:"message,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBlockedDialogListResponse parses an HTTP response from a BlockedDialogListWithResponse call
func ParseBlockedDialogListResponse(rsp *http.Response) (*BlockedDialogListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedDialogListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// BlockedUserIds Идентификаторы пользователей
				BlockedUserIds *[]int `json:"blockedUserIds,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCancelOrderAwaitingPaymentResponse parses an HTTP response from a CancelOrderAwaitingPaymentWithResponse call
func ParseCancelOrderAwaitingPaymentResponse(rsp *http.Response) (*CancelOrderAwaitingPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelOrderAwaitingPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCancelOrderByPayerResponse parses an HTTP response from a CancelOrderByPayerWithResponse call
func ParseCancelOrderByPayerResponse(rsp *http.Response) (*CancelOrderByPayerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelOrderByPayerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCancelOrderByWorkerResponse parses an HTTP response from a CancelOrderByWorkerWithResponse call
func ParseCancelOrderByWorkerResponse(rsp *http.Response) (*CancelOrderByWorkerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelOrderByWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCatalogCategoriesResponse parses an HTTP response from a CatalogCategoriesWithResponse call
func ParseCatalogCategoriesResponse(rsp *http.Response) (*CatalogCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CatalogCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *[]SecondLevelCategory `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCatalogFiltersResponse parses an HTTP response from a CatalogFiltersWithResponse call
func ParseCatalogFiltersResponse(rsp *http.Response) (*CatalogFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CatalogFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Filters Фильтры
				Filters *[]struct {
					// Filters Список подфильтров (для пакетных фильтров)
					Filters *[]struct {
						// Id Идентификатор
						Id *string `json:"id,omitempty"`

						// MaxValue Максимальное значение (для типа range)
						MaxValue *int `json:"max_value,omitempty"`

						// MinValue Минимальное значение (для типа range)
						MinValue *int `json:"min_value,omitempty"`

						// Name Название
						Name *string `json:"name,omitempty"`

						// Type Тип numeric - числовой, multiple_choice - множественный выбор, one_of_several - одно из
						Type *string `json:"type,omitempty"`

						// Values Значения, если они есть
						Values *[]struct {
							// Id Идентификатор
							Id *string `json:"id,omitempty"`

							// Name Название
							Name *string `json:"name,omitempty"`
						} `json:"values,omitempty"`
					} `json:"filters,omitempty"`

					// Id Идентификатор
					Id *string `json:"id,omitempty"`

					// IsPackage Если заданно, то фильтр по пакетному параметру
					IsPackage *int `json:"is_package,omitempty"`

					// IsUnembedded Если заданно, то фильтр является отвязанным атрибутом
					IsUnembedded *int `json:"is_unembedded,omitempty"`

					// MaxValue Максимальное значение (для типа range)
					MaxValue *int `json:"max_value,omitempty"`

					// MinValue Минимальное значение (для типа range)
					MinValue *int `json:"min_value,omitempty"`

					// MobileGroupId Id группы
					MobileGroupId *int `json:"mobile_group_id,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`

					// Placeholder Плейсхолдер для поля ввода значения (для типа numeric)
					Placeholder *string `json:"placeholder,omitempty"`

					// QueryKey Алиас фильтра
					QueryKey *string `json:"query_key,omitempty"`

					// Type Тип numeric - числовой, multiple_choice - множественный выбор, one_of_several - одно из
					Type *string `json:"type,omitempty"`

					// Values Значения, если они есть
					Values *[]struct {
						// Id Идентификатор
						Id *string `json:"id,omitempty"`

						// Name Название
						Name *string `json:"name,omitempty"`
					} `json:"values,omitempty"`
				} `json:"filters,omitempty"`

				// Groups Группы фильтров
				Groups *[]struct {
					// Id ID группы
					Id *int `json:"id,omitempty"`

					// Name Название группы
					Name *string `json:"name,omitempty"`
				} `json:"groups,omitempty"`

				// KworksCount Кол-во кворков для заданных фильтров
				KworksCount *int `json:"kworks_count,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCatalogMainResponse parses an HTTP response from a CatalogMainWithResponse call
func ParseCatalogMainResponse(rsp *http.Response) (*CatalogMainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CatalogMainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *struct {
				// MarketingAction Маркетинговая акция
				MarketingAction *struct {
					// Image Путь к изображению
					Image *string `json:"image,omitempty"`

					// IsActive Признак активности
					IsActive *bool `json:"is_active,omitempty"`

					// Url Ссылка для перехода
					Url *string `json:"url,omitempty"`
				} `json:"marketing_action,omitempty"`

				// PopularCategories Популярные категории
				PopularCategories *[]SecondLevelCategory `json:"popular_categories,omitempty"`

				// PopularKworks Популярные кворки
				PopularKworks *[]ProfileKworks `json:"popular_kworks,omitempty"`

				// Rubrics Рубрики меню
				Rubrics *[]FirstLevelCategory `json:"rubrics,omitempty"`

				// ViewedKworks Просмотренные кворки
				ViewedKworks *[]ProfileKworks `json:"viewed_kworks,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCatalogMainv2Response parses an HTTP response from a CatalogMainv2WithResponse call
func ParseCatalogMainv2Response(rsp *http.Response) (*CatalogMainv2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CatalogMainv2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *struct {
				// CatalogServiceBlock Блоки каталога услуг
				CatalogServiceBlock *[]CatalogServiceBlock `json:"catalog_service_block,omitempty"`

				// MarketingAction Маркетинговая акция
				MarketingAction *struct {
					// Image Путь к изображению
					Image *string `json:"image,omitempty"`

					// IsActive Признак активности
					IsActive *bool `json:"is_active,omitempty"`

					// Url Ссылка для перехода
					Url *string `json:"url,omitempty"`
				} `json:"marketing_action,omitempty"`

				// OtherServicesBlock Блоки других услуг
				OtherServicesBlock *[]CatalogOtherServiceBlock `json:"other_services_block,omitempty"`

				// PopularCategoriesBlock Блоки популярных рубрик
				PopularCategoriesBlock *[]PopularBlock `json:"popular_categories_block,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCatalogRubricsResponse parses an HTTP response from a CatalogRubricsWithResponse call
func ParseCatalogRubricsResponse(rsp *http.Response) (*CatalogRubricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CatalogRubricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *[]FirstLevelCategory `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCategoriesResponse parses an HTTP response from a CategoriesWithResponse call
func ParseCategoriesResponse(rsp *http.Response) (*CategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Категории
			Response *[]CategoryLevel1 `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCategoryResponse parses an HTTP response from a CategoryWithResponse call
func ParseCategoryResponse(rsp *http.Response) (*CategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные категории
			Response *struct {
				// Attributes Классификации/Атрибуты
				Attributes *Attributes `json:"attributes,omitempty"`

				// BaseVolume Базовый числовой объем
				BaseVolume *int `json:"base_volume,omitempty"`

				// Id Идентификатор категории
				Id *int `json:"id,omitempty"`

				// MobileDescription Краткое описание
				MobileDescription *string `json:"mobile_description,omitempty"`

				// Name Название категории
				Name *string `json:"name,omitempty"`

				// PositiveReviewsCount Количество отзывов => Количество кворков с таким количество отзывов
				PositiveReviewsCount *PositiveReviewsCount `json:"positive_reviews_count,omitempty"`

				// VolumeType Тип числового объема
				VolumeType *VolumeType `json:"volume_type,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCategoryAttributesResponse parses an HTTP response from a CategoryAttributesWithResponse call
func ParseCategoryAttributesResponse(rsp *http.Response) (*CategoryAttributesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CategoryAttributesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Классификации/Атрибуты
			Response *Attributes `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangePasswordResponse parses an HTTP response from a ChangePasswordWithResponse call
func ParseChangePasswordResponse(rsp *http.Response) (*ChangePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangePayerSubRoleResponse parses an HTTP response from a ChangePayerSubRoleWithResponse call
func ParseChangePayerSubRoleResponse(rsp *http.Response) (*ChangePayerSubRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePayerSubRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangeUsernameResponse parses an HTTP response from a ChangeUsernameWithResponse call
func ParseChangeUsernameResponse(rsp *http.Response) (*ChangeUsernameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCheckLoginResponse parses an HTTP response from a CheckLoginWithResponse call
func ParseCheckLoginResponse(rsp *http.Response) (*CheckLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные о занятости логина
			Response *struct {
				// Login Сгенерированный свободный логин
				Login *string `json:"login,omitempty"`

				// Success Свободен ли логин
				Success *bool `json:"success,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности запроса
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCitiesResponse parses an HTTP response from a CitiesWithResponse call
func ParseCitiesResponse(rsp *http.Response) (*CitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Города
			Response *[]struct {
				// Id Идентификатор
				Id *string `json:"id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearFiltersResponse parses an HTTP response from a ClearFiltersWithResponse call
func ParseClearFiltersResponse(rsp *http.Response) (*ClearFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Предустановленные фильтры
			Response *[]WantsFilter `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfirmCancelOrderRequestByPayerResponse parses an HTTP response from a ConfirmCancelOrderRequestByPayerWithResponse call
func ParseConfirmCancelOrderRequestByPayerResponse(rsp *http.Response) (*ConfirmCancelOrderRequestByPayerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmCancelOrderRequestByPayerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConfirmCancelOrderRequestByWorkerResponse parses an HTTP response from a ConfirmCancelOrderRequestByWorkerWithResponse call
func ParseConfirmCancelOrderRequestByWorkerResponse(rsp *http.Response) (*ConfirmCancelOrderRequestByWorkerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmCancelOrderRequestByWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCountriesResponse parses an HTTP response from a CountriesWithResponse call
func ParseCountriesResponse(rsp *http.Response) (*CountriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Страны
			Response *[]struct {
				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAnswerResponse parses an HTTP response from a CreateAnswerWithResponse call
func ParseCreateAnswerResponse(rsp *http.Response) (*CreateAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateKworkComplainResponse parses an HTTP response from a CreateKworkComplainWithResponse call
func ParseCreateKworkComplainResponse(rsp *http.Response) (*CreateKworkComplainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKworkComplainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ComplainAvailable timestamp, когда можно отправить следующую жалобу без капчи.
			ComplainAvailable *int `json:"complainAvailable,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePortfolioResponse parses an HTTP response from a CreatePortfolioWithResponse call
func ParseCreatePortfolioResponse(rsp *http.Response) (*CreatePortfolioResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePortfolioResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MultiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateReviewResponse parses an HTTP response from a CreateReviewWithResponse call
func ParseCreateReviewResponse(rsp *http.Response) (*CreateReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStageResponse parses an HTTP response from a CreateStageWithResponse call
func ParseCreateStageResponse(rsp *http.Response) (*CreateStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDelFavoriteCategoriesResponse parses an HTTP response from a DelFavoriteCategoriesWithResponse call
func ParseDelFavoriteCategoriesResponse(rsp *http.Response) (*DelFavoriteCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelFavoriteCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAccountResponse parses an HTTP response from a DeleteAccountWithResponse call
func ParseDeleteAccountResponse(rsp *http.Response) (*DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ConfirmationType Тип отправления кода подтверждения, sms/email/deleted
				ConfirmationType *string `json:"confirmation_type,omitempty"`

				// Orders Массив заказов если они есть
				Orders *[]struct {
					// Id ID заказа
					Id *int `json:"id,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`
				} `json:"orders,omitempty"`

				// PhoneMask Замаскированный телефон, если подтверждение через SMS
				PhoneMask *string `json:"phoneMask,omitempty"`

				// TelegramBotLink Ссылка на Telegram-бот, если доступно подтверждение через Telegram
				TelegramBotLink *string `json:"telegramBotLink,omitempty"`

				// Timeout Время задержки перед следующей попыткой в секундах
				Timeout *int `json:"timeout,omitempty"`

				// TransportType Тип траноспорта при запросе кода через SMS или мессенджеры
				TransportType *string `json:"transportType,omitempty"`

				// WhatsappLink Ссылка для отправки кода в WhatsApp, если доступно подтверждение через WhatsApp
				WhatsappLink *string `json:"whatsappLink,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCancelOrderRequestByPayerResponse parses an HTTP response from a DeleteCancelOrderRequestByPayerWithResponse call
func ParseDeleteCancelOrderRequestByPayerResponse(rsp *http.Response) (*DeleteCancelOrderRequestByPayerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCancelOrderRequestByPayerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCancelOrderRequestByWorkerResponse parses an HTTP response from a DeleteCancelOrderRequestByWorkerWithResponse call
func ParseDeleteCancelOrderRequestByWorkerResponse(rsp *http.Response) (*DeleteCancelOrderRequestByWorkerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCancelOrderRequestByWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCoverResponse parses an HTTP response from a DeleteCoverWithResponse call
func ParseDeleteCoverResponse(rsp *http.Response) (*DeleteCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// Src Ссылка на дефолтную обложку
				Src *string `json:"src,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKworkResponse parses an HTTP response from a DeleteKworkWithResponse call
func ParseDeleteKworkResponse(rsp *http.Response) (*DeleteKworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOfferResponse parses an HTTP response from a DeleteOfferWithResponse call
func ParseDeleteOfferResponse(rsp *http.Response) (*DeleteOfferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOfferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteOrderNoteResponse parses an HTTP response from a DeleteOrderNoteWithResponse call
func ParseDeleteOrderNoteResponse(rsp *http.Response) (*DeleteOrderNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePortfolioResponse parses an HTTP response from a DeletePortfolioWithResponse call
func ParseDeletePortfolioResponse(rsp *http.Response) (*DeletePortfolioResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePortfolioResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReviewResponse parses an HTTP response from a DeleteReviewWithResponse call
func ParseDeleteReviewResponse(rsp *http.Response) (*DeleteReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStageResponse parses an HTTP response from a DeleteStageWithResponse call
func ParseDeleteStageResponse(rsp *http.Response) (*DeleteStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserNoteResponse parses an HTTP response from a DeleteUserNoteWithResponse call
func ParseDeleteUserNoteResponse(rsp *http.Response) (*DeleteUserNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteWantResponse parses an HTTP response from a DeleteWantWithResponse call
func ParseDeleteWantResponse(rsp *http.Response) (*DeleteWantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDialogsResponse parses an HTTP response from a DialogsWithResponse call
func ParseDialogsResponse(rsp *http.Response) (*DialogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DialogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// FilterCounts Объект данных количеств диалогов по фильтрам
			FilterCounts *struct {
				// Archived Количество диалогов в архиве
				Archived *int `json:"archived,omitempty"`

				// Unread Количество непрочитанных диалогов
				Unread *int `json:"unread,omitempty"`
			} `json:"filter_counts,omitempty"`

			// Paging Данные пагинации
			Paging *Paging `json:"paging,omitempty"`

			// Response Массив объектов сообщений
			Response *[]DialogMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditAnswerResponse parses an HTTP response from a EditAnswerWithResponse call
func ParseEditAnswerResponse(rsp *http.Response) (*EditAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditPortfolioResponse parses an HTTP response from a EditPortfolioWithResponse call
func ParseEditPortfolioResponse(rsp *http.Response) (*EditPortfolioResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditPortfolioResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MultiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditReviewResponse parses an HTTP response from a EditReviewWithResponse call
func ParseEditReviewResponse(rsp *http.Response) (*EditReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditStageResponse parses an HTTP response from a EditStageWithResponse call
func ParseEditStageResponse(rsp *http.Response) (*EditStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEmailVerificationLetterResponse parses an HTTP response from a EmailVerificationLetterWithResponse call
func ParseEmailVerificationLetterResponse(rsp *http.Response) (*EmailVerificationLetterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailVerificationLetterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Timeout Время через которое можно повторить отправку
				Timeout *int `json:"timeout,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExchangeInfoResponse parses an HTTP response from a ExchangeInfoWithResponse call
func ParseExchangeInfoResponse(rsp *http.Response) (*ExchangeInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]ExchangeInfo `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFavoriteCategoriesResponse parses an HTTP response from a FavoriteCategoriesWithResponse call
func ParseFavoriteCategoriesResponse(rsp *http.Response) (*FavoriteCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FavoriteCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив объектов рубрик
			Response *[]struct {
				// Description Описание
				Description *string `json:"description,omitempty"`

				// Id ID
				Id *int `json:"id,omitempty"`

				// IsAttribute Является ли аттрибутом
				IsAttribute *bool `json:"is_attribute,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFavoriteKworksResponse parses an HTTP response from a FavoriteKworksWithResponse call
func ParseFavoriteKworksResponse(rsp *http.Response) (*FavoriteKworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FavoriteKworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Избранный кворк
			Response *FavoriteKworks `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFcmNotificationsReadResponse parses an HTTP response from a FcmNotificationsReadWithResponse call
func ParseFcmNotificationsReadResponse(rsp *http.Response) (*FcmNotificationsReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FcmNotificationsReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFcmNotificationsReceivedResponse parses an HTTP response from a FcmNotificationsReceivedWithResponse call
func ParseFcmNotificationsReceivedResponse(rsp *http.Response) (*FcmNotificationsReceivedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FcmNotificationsReceivedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFcmTokenRequestFailedResponse parses an HTTP response from a FcmTokenRequestFailedWithResponse call
func ParseFcmTokenRequestFailedResponse(rsp *http.Response) (*FcmTokenRequestFailedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FcmTokenRequestFailedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFileDeleteResponse parses an HTTP response from a FileDeleteWithResponse call
func ParseFileDeleteResponse(rsp *http.Response) (*FileDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFileUploadResponse parses an HTTP response from a FileUploadWithResponse call
func ParseFileUploadResponse(rsp *http.Response) (*FileUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Файл
			Response *File `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActorInfoResponse parses an HTTP response from a GetActorInfoWithResponse call
func ParseGetActorInfoResponse(rsp *http.Response) (*GetActorInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActorInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// AboutMeText Текст о себе
				AboutMeText *string `json:"about_me_text,omitempty"`

				// AllowMobilePush Разрешена ли отправка пушей в мобильное приложение через FCM
				AllowMobilePush *bool `json:"allow_mobile_push,omitempty"`

				// ArchivedWantsCount Количество архивных запросов пользователя
				ArchivedWantsCount *int `json:"archived_wants_count,omitempty"`

				// AvatarPath Путь к изображению аватара
				AvatarPath *string `json:"avatar_path,omitempty"`

				// BlackFridayForSellers Активность акции ЧП для продавцов
				BlackFridayForSellers *bool `json:"black_friday_for_sellers,omitempty"`

				// CityId Идентификатор города
				CityId *int `json:"city_id,omitempty"`

				// CountryId Идентификатор страны
				CountryId *int `json:"country_id,omitempty"`

				// CoverPath Путь к баннеру пользователя
				CoverPath *string `json:"cover_path,omitempty"`

				// Currency Валюта
				Currency *string `json:"currency,omitempty"`

				// FavouriteKworksCount Кол-во избранных кворков
				FavouriteKworksCount *int `json:"favourite_kworks_count,omitempty"`

				// Fullname Настоящее имя
				Fullname *string `json:"fullname,omitempty"`

				// HiddenKworksCount Кол-во скрытых кворков
				HiddenKworksCount *int `json:"hidden_kworks_count,omitempty"`

				// Id Идентификатор пользователя
				Id *int `json:"id,omitempty"`

				// KworksCount Кол-во кворков актора
				KworksCount *int `json:"kworks_count,omitempty"`

				// OffersCount Количество предложений пользователя
				OffersCount *int `json:"offers_count,omitempty"`

				// Profession Специальность пользователя
				Profession *string `json:"profession"`

				// PushNotificationsSoundAllowed Включен ли звук в мобильных пуш уведомлениях
				PushNotificationsSoundAllowed *bool `json:"push_notifications_sound_allowed,omitempty"`

				// TimezoneId Идентификатор часового пояса
				TimezoneId *int `json:"timezone_id,omitempty"`

				// TotalAmount Баланс общий
				TotalAmount *float32 `json:"total_amount,omitempty"`

				// Type Текущая роль пользователя worker|payer
				Type *string `json:"type,omitempty"`

				// Username Имя пользователя
				Username *string `json:"username,omitempty"`

				// Verified Подтвержден ли email
				Verified *bool `json:"verified,omitempty"`

				// WorkerStatus Статус продавца (null, free, busy)
				WorkerStatus *string `json:"worker_status,omitempty"`

				// YescrowPayer Дочерние роли покупателя
				YescrowPayer *struct {
					// Company Компания
					Company *struct {
						// Name Название компании
						Name *string `json:"name,omitempty"`

						// Status Статус компании (0 - Проверка инициирована, 1 - Проверка пройдена, 2 - Проверка отклонена)
						Status *int `json:"status,omitempty"`
					} `json:"company,omitempty"`

					// Role Дочерняя роль (0 - Частное лицо, 1 - Компания)
					Role *int `json:"role,omitempty"`
				} `json:"yescrow_payer,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetArbitrationReasonsResponse parses an HTTP response from a GetArbitrationReasonsWithResponse call
func ParseGetArbitrationReasonsResponse(rsp *http.Response) (*GetArbitrationReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArbitrationReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]ArbitrationReason `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAvailableFeaturesResponse parses an HTTP response from a GetAvailableFeaturesWithResponse call
func ParseGetAvailableFeaturesResponse(rsp *http.Response) (*GetAvailableFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// IsSupportDialogAvailable Флаг открытого общения со службой поддержки
				IsSupportDialogAvailable *bool `json:"is_support_dialog_available,omitempty"`

				// SelfEmployed Информация СЗ/ИП
				SelfEmployed *struct {
					// ShowRegistrationNotification Флаг для отображения успешной регистрации СЗ/ИП
					ShowRegistrationNotification *bool `json:"show_registration_notification,omitempty"`

					// ShowSurveyPopup Флаг для отображения опроса
					ShowSurveyPopup *bool `json:"show_survey_popup,omitempty"`
				} `json:"self_employed,omitempty"`

				// TestGroups Набор тестовых групп пользователя
				TestGroups *[]map[string]bool `json:"test_groups,omitempty"`

				// VoiceMessages Голосовые сообщения
				VoiceMessages *struct {
					// IsVoiceMessageRecordingAvailable Разрешение записывать ГС
					IsVoiceMessageRecordingAvailable *bool `json:"is_voice_message_recording_available,omitempty"`

					// ReceivingSettings Настройки получения ГС
					ReceivingSettings *struct {
						// IsReceivingAllowed Флаг разрешения приема ГС
						IsReceivingAllowed *bool `json:"is_receiving_allowed,omitempty"`

						// IsReceivingSettingAllowed Флаг доступности настройки ГС
						IsReceivingSettingAllowed *bool `json:"is_receiving_setting_allowed,omitempty"`

						// ShouldShowSettingsPopup Флаг показа попапа
						ShouldShowSettingsPopup *bool `json:"should_show_settings_popup,omitempty"`
					} `json:"receiving_settings,omitempty"`

					// SpeedControl Параметры скорости ГС
					SpeedControl *struct {
						// AvailableSpeeds Список допустимых скоростей
						AvailableSpeeds *[]float32 `json:"available_speeds,omitempty"`

						// IsAvailable Разрешение менять скорость
						IsAvailable *bool `json:"is_available,omitempty"`

						// Speed Скорость воспроизведения
						Speed *float32 `json:"speed,omitempty"`
					} `json:"speed_control,omitempty"`
				} `json:"voice_messages,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBadgesInfoResponse parses an HTTP response from a GetBadgesInfoWithResponse call
func ParseGetBadgesInfoResponse(rsp *http.Response) (*GetBadgesInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBadgesInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// DialogsUnreadCount Количество непрочитанных диалогов
				DialogsUnreadCount *int `json:"dialogs_unread_count,omitempty"`

				// ImportantDialogCount Количество важных диалогов
				ImportantDialogCount *int `json:"important_dialog_count,omitempty"`

				// ImportantNotificationsCount Есть ли важные непрочитанные уведомления
				ImportantNotificationsCount *bool `json:"important_notifications_count,omitempty"`

				// NotificationsNotDelivered Необходимость отображать уведомление о добавлении приложения в белый список
				NotificationsNotDelivered *bool `json:"notifications_not_delivered,omitempty"`

				// NotificationsUnreadCount Количество непрочитанных уведомлений
				NotificationsUnreadCount *int `json:"notifications_unread_count,omitempty"`

				// UnreadMessagesCount Количество непрочитанных сообщений
				UnreadMessagesCount *int `json:"unread_messages_count,omitempty"`

				// WarningDialogsCount Количество важных непрочитанных диалогов
				WarningDialogsCount *int `json:"warning_dialogs_count,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillRefillUrlResponse parses an HTTP response from a GetBillRefillUrlWithResponse call
func ParseGetBillRefillUrlResponse(rsp *http.Response) (*GetBillRefillUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillRefillUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// YescrowPaymentUrl URL для редиректа браузера
				YescrowPaymentUrl *string `json:"yescrowPaymentUrl,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCaptchaStatusResponse parses an HTTP response from a GetCaptchaStatusWithResponse call
func ParseGetCaptchaStatusResponse(rsp *http.Response) (*GetCaptchaStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptchaStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ShowCaptcha Требуется ли показать капчу при запросе сброса пароля
				ShowCaptcha *bool `json:"show_captcha,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetChannelResponse parses an HTTP response from a GetChannelWithResponse call
func ParseGetChannelResponse(rsp *http.Response) (*GetChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Channel Идентификатор канала
				Channel *string `json:"channel,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCompanyDetailsResponse parses an HTTP response from a GetCompanyDetailsWithResponse call
func ParseGetCompanyDetailsResponse(rsp *http.Response) (*GetCompanyDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные о компании
			Response *GetCompanyDetails_200_Response `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetComplainCategoriesResponse parses an HTTP response from a GetComplainCategoriesWithResponse call
func ParseGetComplainCategoriesResponse(rsp *http.Response) (*GetComplainCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplainCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Категории жалоб
			Response *[]ComplainCategory `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCookieResponse parses an HTTP response from a GetCookieWithResponse call
func ParseGetCookieResponse(rsp *http.Response) (*GetCookieResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCookieResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentVersionsResponse parses an HTTP response from a GetCurrentVersionsWithResponse call
func ParseGetCurrentVersionsResponse(rsp *http.Response) (*GetCurrentVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *struct {
				// CriticalUpdate Флаг критического обновления
				CriticalUpdate *bool `json:"critical_update,omitempty"`

				// CurrentVersionAndroid Текущая версия Android
				CurrentVersionAndroid *string `json:"current_version_android,omitempty"`

				// CurrentVersionIos Текущая версия iOS
				CurrentVersionIos *string `json:"current_version_ios,omitempty"`

				// Facebook Флаг использования Facebook
				Facebook *bool `json:"facebook,omitempty"`

				// Notification In-app уведомление или null
				Notification *struct {
					Id                  *int    `json:"id,omitempty"`
					Lang                *string `json:"lang,omitempty"`
					Link                *string `json:"link,omitempty"`
					MinSupportedVersion *int    `json:"min_supported_version,omitempty"`
					ShowPeriodDays      *int    `json:"show_period_days,omitempty"`

					// SupportEndDate Unix timestamp окончания поддержки
					SupportEndDate *int    `json:"support_end_date,omitempty"`
					Text           *string `json:"text,omitempty"`
					Title          *string `json:"title,omitempty"`
				} `json:"notification"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Текст ошибки
			Error *string `json:"error,omitempty"`

			// ErrorCode Код ошибки
			ErrorCode *int `json:"error_code,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCustomOptionsPresetsResponse parses an HTTP response from a GetCustomOptionsPresetsWithResponse call
func ParseGetCustomOptionsPresetsResponse(rsp *http.Response) (*GetCustomOptionsPresetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomOptionsPresetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// ExtraLimitPrice Сумма опций для покупателя, которую ещё можно добавить в заказ
				ExtraLimitPrice *int `json:"extra_limit_price,omitempty"`

				// PriceRange Цены
				PriceRange *[]struct {
					// PayerPrice Цена
					PayerPrice *float32 `json:"payer_price,omitempty"`

					// WorkerPrice Цена с комиссией
					WorkerPrice *float32 `json:"worker_price,omitempty"`
				} `json:"price_range,omitempty"`

				// TimeUpperBoundInDays Максимальное количество дней, доступное для опции
				TimeUpperBoundInDays *int `json:"time_upper_bound_in_days,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDialogResponse parses an HTTP response from a GetDialogWithResponse call
func ParseGetDialogResponse(rsp *http.Response) (*GetDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *DialogMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExtrasAvailableForOrderResponse parses an HTTP response from a GetExtrasAvailableForOrderWithResponse call
func ParseGetExtrasAvailableForOrderResponse(rsp *http.Response) (*GetExtrasAvailableForOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExtrasAvailableForOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]OrderOption `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFishingTutorialQuestionsResponse parses an HTTP response from a GetFishingTutorialQuestionsWithResponse call
func ParseGetFishingTutorialQuestionsResponse(rsp *http.Response) (*GetFishingTutorialQuestionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFishingTutorialQuestionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *[]struct {
				Answers *[]struct {
					// Comment Комментарий к ответу
					Comment *string `json:"comment,omitempty"`

					// IsCorrect Верный ли ответ
					IsCorrect *bool `json:"isCorrect,omitempty"`

					// Text Вариант ответа
					Text *string `json:"text,omitempty"`
				} `json:"answers,omitempty"`

				// Text Текст вопроса
				Text *string `json:"text,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности запроса
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHiddenKworksResponse parses an HTTP response from a GetHiddenKworksWithResponse call
func ParseGetHiddenKworksResponse(rsp *http.Response) (*GetHiddenKworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHiddenKworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Кворки пользователя
			Response *ProfileKworks `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInboxTracksResponse parses an HTTP response from a GetInboxTracksWithResponse call
func ParseGetInboxTracksResponse(rsp *http.Response) (*GetInboxTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInboxTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Orders Данные об активных заказах между пользователями
			Orders *[]TrackOrder `json:"orders,omitempty"`

			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]InboxTrackMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`

			// User Данные о собеседнике
			User *Interlocutor `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkAnswersResponse parses an HTTP response from a GetKworkAnswersWithResponse call
func ParseGetKworkAnswersResponse(rsp *http.Response) (*GetKworkAnswersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkAnswersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response FAQ
			Response *[]struct {
				// Answer Ответ
				Answer *int `json:"answer,omitempty"`

				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Position Позиция
				Position *int `json:"position,omitempty"`

				// Question Вопрос
				Question *string `json:"question,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkDetailsResponse parses an HTTP response from a GetKworkDetailsWithResponse call
func ParseGetKworkDetailsResponse(rsp *http.Response) (*GetKworkDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Active Статус кворка
				Active *int `json:"active,omitempty"`

				// AdditionalOptions Дополнительные опции
				AdditionalOptions *[]struct {
					// Id Идентификатор опции
					Id *int `json:"id,omitempty"`

					// Name Наименование опции
					Name *string `json:"name,omitempty"`

					// Price Стоимость опции
					Price *int `json:"price,omitempty"`
				} `json:"additional_options,omitempty"`

				// Badges Бейджи кворка
				Badges *KworkBadges `json:"badges,omitempty"`

				// Category Id категории
				Category *int `json:"category,omitempty"`

				// ChannelLink Данные о канале
				ChannelLink *[]struct {
					// Link Адрес ссылки
					Link *string `json:"link,omitempty"`

					// Type Тип сети
					Type *string `json:"type,omitempty"`
				} `json:"channel_link,omitempty"`

				// ChannelStat Данные о канале
				ChannelStat *[]struct {
					// AvgPostReach Просмотры на пост
					AvgPostReach *int `json:"avg_post_reach,omitempty"`

					// ErrPercent Вовлеченность
					ErrPercent *float32 `json:"err_percent,omitempty"`

					// MentionsCount Кол-во упоминаний
					MentionsCount *int `json:"mentions_count,omitempty"`

					// ParticipantsCount Кол-во подписчиков
					ParticipantsCount *int `json:"participants_count,omitempty"`

					// PostsPerDay Публикаций в день
					PostsPerDay *int `json:"posts_per_day,omitempty"`

					// PricePerThousand Цена за 1000 просмотров
					PricePerThousand *float32 `json:"price_per_thousand,omitempty"`
				} `json:"channel_stat,omitempty"`

				// Classifications Классификации для вывода
				Classifications *[]struct {
					// Attrs Атрибуты через запятую
					Attrs *string `json:"attrs,omitempty"`

					// Title Заголовок
					Title *string `json:"title,omitempty"`
				} `json:"classifications,omitempty"`

				// DefaultKworkPrice Стандартная цена кворка
				DefaultKworkPrice *int `json:"default_kwork_price,omitempty"`

				// Feat Активен кворк или нет
				Feat *int `json:"feat,omitempty"`

				// Files Прикрепленные файлы
				Files *[]struct {
					// EntityType Тип файла
					EntityType *string `json:"entity_type,omitempty"`

					// Fname Имя файла
					Fname *string `json:"fname,omitempty"`

					// Url Ссылка на файл
					Url *string `json:"url,omitempty"`
				} `json:"files,omitempty"`

				// Id Идентификатор кворка
				Id *string `json:"id,omitempty"`

				// ImageUrl Путь к обложке кворка
				ImageUrl *string `json:"image_url,omitempty"`

				// IsFavorite Кворк в избранных у активного юзера
				IsFavorite *bool `json:"is_favorite,omitempty"`

				// IsHidden Кворк скрыт у активного юзера
				IsHidden *bool `json:"is_hidden,omitempty"`

				// IsKworkRejectedWithSpamReason Отклонен ли кворк с причиной Спам
				IsKworkRejectedWithSpamReason *bool `json:"is_kwork_rejected_with_spam_reason,omitempty"`

				// IsSubscription Наличие бейджа “подписка”
				IsSubscription *bool `json:"is_subscription,omitempty"`

				// KworkDescription Описание кворка
				KworkDescription *string `json:"kwork_description,omitempty"`

				// KworkInFavoritesCount Кол-во раз, которое кворк добавили в избранное
				KworkInFavoritesCount *int `json:"kwork_in_favorites_count,omitempty"`

				// KworkInstructions Инструкции для покупателей
				KworkInstructions *string `json:"kwork_instructions,omitempty"`

				// KworkLink Ссылка на кворк
				KworkLink *string `json:"kwork_link,omitempty"`

				// KworkTitle Наименование кворка
				KworkTitle *string `json:"kwork_title,omitempty"`

				// Lang Язык кворка
				Lang *string `json:"lang,omitempty"`

				// LinksSites Ссылки кворка
				LinksSites *[]KworkLinkSiteItem `json:"links_sites,omitempty"`

				// LinksSitesCount Кол-во ссылок кворка
				LinksSitesCount *int `json:"links_sites_count,omitempty"`

				// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
				NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

				// OrdersInQueueCount Заказов в очереди
				OrdersInQueueCount *int `json:"orders_in_queue_count,omitempty"`

				// Packages Пакетные предложения для кворка
				Packages *[]KworkPackage `json:"packages,omitempty"`

				// PortfolioItems Первые 10 работ портфолио кворка
				PortfolioItems *[]ProfilePortfolios `json:"portfolio_items,omitempty"`

				// PortfolioItemsCount Кол-во работ в портфолио кворка
				PortfolioItemsCount *int `json:"portfolio_items_count,omitempty"`

				// RejectFieldsString Список причин отклонения кворка, если он отклонен
				RejectFieldsString *string        `json:"reject_fields_string,omitempty"`
				ShortUserInfo      *ShortUserInfo `json:"short_user_info,omitempty"`

				// ShowSubscribersStatistics Достаточно ли данных для отображения графика о динамике подписчиков на канале
				ShowSubscribersStatistics *bool `json:"show_subscribers_statistics,omitempty"`

				// Term Срок выполнения
				Term *string `json:"term,omitempty"`

				// UnitAndQuantity Единицы измерения и кол-во
				UnitAndQuantity *struct {
					// BaseVolume Базовый объем(в выбранном типе объема)
					BaseVolume *int `json:"base_volume,omitempty"`

					// BaseVolumeName Название базового минимального объема
					BaseVolumeName *string `json:"base_volume_name,omitempty"`

					// BaseVolumePrice Стоимость базового объема
					BaseVolumePrice *int `json:"base_volume_price,omitempty"`

					// MaxVolume Максимальный объем заказа(в выбранном типе объема)
					MaxVolume *int `json:"max_volume,omitempty"`

					// MinDays Количество дней на выполнение минимального объема заказа.
					MinDays *int `json:"min_days,omitempty"`

					// VolumeLabel Текст количество х, где х - объем в нужном склонении
					VolumeLabel *string `json:"volume_label,omitempty"`

					// VolumeTypeId Идентификатор выбранного типа объема
					VolumeTypeId *int `json:"volume_type_id,omitempty"`

					// VolumeTypes Возможные типы объемов для кворка
					VolumeTypes *[]struct {
						// ContainsId Единица объема для contains_value
						ContainsId *int `json:"contains_id,omitempty"`

						// ContainsValue Количество в других единицах (contains_id)
						ContainsValue *int `json:"contains_value,omitempty"`

						// Id Идентификатор типа объема
						Id *int `json:"id,omitempty"`

						// Name Наименование в единственном числе
						Name *string `json:"name,omitempty"`

						// NameAccusative Наименование в винительном падеже
						NameAccusative *string `json:"name_accusative,omitempty"`

						// NamePlural1119 Наименование во множественном числе, от 11 до 19
						NamePlural1119 *string `json:"name_plural_11_19,omitempty"`

						// NamePlural24 Наименование во множественном числе, от 2 до 4
						NamePlural24 *string `json:"name_plural_2_4,omitempty"`

						// NameShort Сокращенное наименование
						NameShort *string `json:"name_short,omitempty"`
					} `json:"volume_types,omitempty"`
				} `json:"unit_and_quantity,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkDetailsExtraResponse parses an HTTP response from a GetKworkDetailsExtraWithResponse call
func ParseGetKworkDetailsExtraResponse(rsp *http.Response) (*GetKworkDetailsExtraResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkDetailsExtraResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// KworkRatings Оценки
				KworkRatings *struct {
					// Communication Коммуникация
					Communication *float32 `json:"communication,omitempty"`

					// Quality Качество
					Quality *float32 `json:"quality,omitempty"`

					// Speed Скорость
					Speed *float32 `json:"speed,omitempty"`
				} `json:"kwork_ratings,omitempty"`

				// LastReviews Последние 3 отзыва
				LastReviews *[]struct {
					// Answer Ответ на отзыв
					Answer *struct {
						// Id Идентификатор
						Id *int `json:"id,omitempty"`

						// Profilepicture Аватар
						Profilepicture *string `json:"profilepicture,omitempty"`

						// Text Текст
						Text *string `json:"text,omitempty"`

						// TimeAdded Когда был добавлен ответ (timestamp)
						TimeAdded *int `json:"time_added,omitempty"`

						// UserId Идентификатор пользователя
						UserId *int `json:"user_id,omitempty"`

						// Username Имя пользователя
						Username *string `json:"username,omitempty"`
					} `json:"answer,omitempty"`

					// Bad Плохой отзыв
					Bad *bool `json:"bad,omitempty"`

					// Good Хороший отзыв
					Good *bool `json:"good,omitempty"`

					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// Text Текст отзыва
					Text *string `json:"text,omitempty"`

					// TimeAdded Когда был добавлен (timestamp)
					TimeAdded *int `json:"time_added,omitempty"`

					// Writer Автор отзыва
					Writer *struct {
						// Id Идентификатор
						Id *int `json:"id,omitempty"`

						// Profilepicture Аватар
						Profilepicture *string `json:"profilepicture,omitempty"`

						// Username Имя пользователя
						Username *string `json:"username,omitempty"`
					} `json:"writer,omitempty"`
				} `json:"last_reviews,omitempty"`

				// LinksSites Ссылки кворка
				LinksSites *[]KworkLinkSiteItem `json:"links_sites,omitempty"`

				// LinksSitesCount Кол-во ссылок кворка
				LinksSitesCount *int `json:"links_sites_count,omitempty"`

				// LinksSitesV2 Ссылки кворка (новый формат)
				LinksSitesV2 *struct {
					// LinkHeaders Загаловки для табилцы ссылок
					LinkHeaders *[]string `json:"link_headers,omitempty"`

					// LinksContent Данные для таблицы ссылок
					LinksContent *[]KworkLinkSiteItem `json:"links_content,omitempty"`
				} `json:"links_sites_v2,omitempty"`

				// NotAvailableForCompany Отображать уведомление о том, что кворк не доступен для дочерней роли покупателя 'Компания'
				NotAvailableForCompany *bool `json:"not_available_for_company,omitempty"`

				// OtherKworks Другие кворки пользователя
				OtherKworks *[]KworkInList `json:"other_kworks,omitempty"`

				// RecommendedKworks Рекомендуемые кворки
				RecommendedKworks *[]KworkInList `json:"recommended_kworks,omitempty"`

				// ReviewsCount Кол-во отзывов кворка
				ReviewsCount *int `json:"reviews_count,omitempty"`

				// SimilarKworks Похожие кворки
				SimilarKworks *[]KworkInList `json:"similar_kworks,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkLinksTableResponse parses an HTTP response from a GetKworkLinksTableWithResponse call
func ParseGetKworkLinksTableResponse(rsp *http.Response) (*GetKworkLinksTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkLinksTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Ссылки кворка
			Response *[]KworkLinkSiteItem `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkLinksTablev2Response parses an HTTP response from a GetKworkLinksTablev2WithResponse call
func ParseGetKworkLinksTablev2Response(rsp *http.Response) (*GetKworkLinksTablev2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkLinksTablev2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Ссылки кворка
			Response *struct {
				// LinkHeaders Загаловки для табилцы ссылок
				LinkHeaders *[]string `json:"link_headers,omitempty"`

				// LinksContent Данные для таблицы ссылок
				LinksContent *[]KworkLinkSiteItem `json:"links_content,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkPortfoliosResponse parses an HTTP response from a GetKworkPortfoliosWithResponse call
func ParseGetKworkPortfoliosResponse(rsp *http.Response) (*GetKworkPortfoliosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkPortfoliosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Работы портфолио
			Response *[]ProfilePortfolios `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKworkReviewsResponse parses an HTTP response from a GetKworkReviewsWithResponse call
func ParseGetKworkReviewsResponse(rsp *http.Response) (*GetKworkReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKworkReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Отзывы
			Response *[]struct {
				// Answer Ответ продавца на отзыв
				Answer *UserAnswer `json:"answer,omitempty"`

				// Bad Отрицательный ли отзыв
				Bad *string `json:"bad,omitempty"`

				// Good Положительный ли отзыв
				Good *string `json:"good,omitempty"`

				// Id Идентификатор отзыва
				Id *int `json:"id,omitempty"`

				// Text Отзыв
				Text *string `json:"text,omitempty"`

				// TimeAdded Дата создания
				TimeAdded *int `json:"time_added,omitempty"`

				// Writer Краткие данные автора отзыва
				Writer *UserReviewWriter `json:"writer,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrderCancellationReasonsResponse parses an HTTP response from a GetOrderCancellationReasonsWithResponse call
func ParseGetOrderCancellationReasonsResponse(rsp *http.Response) (*GetOrderCancellationReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderCancellationReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]CancelReason `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrderDetailsResponse parses an HTTP response from a GetOrderDetailsWithResponse call
func ParseGetOrderDetailsResponse(rsp *http.Response) (*GetOrderDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]OrderDetails `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrderFilesResponse parses an HTTP response from a GetOrderFilesWithResponse call
func ParseGetOrderFilesResponse(rsp *http.Response) (*GetOrderFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *[]struct {
				// CloudUrl Имя в файлохранидище
				CloudUrl *string `json:"cloudUrl,omitempty"`

				// Date Дата создания файла
				Date *int `json:"date,omitempty"`

				// EntityType Тип файла
				EntityType *string `json:"entity_type,omitempty"`

				// Fname Имя файла
				Fname *string `json:"fname,omitempty"`

				// Id Идентификатор файла
				Id *int `json:"id,omitempty"`

				// MiniatureUrl Ссылка на картинку миниатюру
				MiniatureUrl *string `json:"miniature_url,omitempty"`

				// Owner Отправлялся ли файл текущим пользователем
				Owner *bool `json:"owner,omitempty"`

				// Size Размер
				Size *int `json:"size,omitempty"`

				// Url Ссылка на файл
				Url *string `json:"url,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrderHeaderResponse parses an HTTP response from a GetOrderHeaderWithResponse call
func ParseGetOrderHeaderResponse(rsp *http.Response) (*GetOrderHeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderHeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]OrderHeader `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrderProvidedDataResponse parses an HTTP response from a GetOrderProvidedDataWithResponse call
func ParseGetOrderProvidedDataResponse(rsp *http.Response) (*GetOrderProvidedDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderProvidedDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]OrderProvidedData `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrderedExtrasResponse parses an HTTP response from a GetOrderedExtrasWithResponse call
func ParseGetOrderedExtrasResponse(rsp *http.Response) (*GetOrderedExtrasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderedExtrasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Count Количество
				Count *int `json:"count,omitempty"`

				// Duration Продолжительность
				Duration *int `json:"duration,omitempty"`

				// ExtraId ИД опции
				ExtraId *int `json:"extra_id,omitempty"`

				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// IsDeletingRequested Есть ли запрос на удаление (85 трек)
				IsDeletingRequested *bool `json:"is_deleting_requested,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`

				// Price Цена заказа
				Price *float32 `json:"price,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPayerCompanyModalUrlResponse parses an HTTP response from a GetPayerCompanyModalUrlWithResponse call
func ParseGetPayerCompanyModalUrlResponse(rsp *http.Response) (*GetPayerCompanyModalUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayerCompanyModalUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Ссылка
			Response *string `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPaymentMethodsResponse parses an HTTP response from a GetPaymentMethodsWithResponse call
func ParseGetPaymentMethodsResponse(rsp *http.Response) (*GetPaymentMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// Currency Валюта
				Currency *string `json:"currency,omitempty"`

				// PaymentTypeAvailableCollection Доступные типы оплаты для пользователя с вложенной структурой
				PaymentTypeAvailableCollection *[]PaymentType `json:"payment_type_available_collection,omitempty"`

				// ServiceFeeFixed Фиксированная сумма, прибавляемая к комиссии для типа percent_and_fixed
				ServiceFeeFixed *int `json:"service_fee_fixed,omitempty"`

				// ServiceFeeMin Фиксированная минимальная сумма сервисного сбора для типа min_or_percent, которая считается до service_fee_min_percent_sum
				ServiceFeeMin *int `json:"service_fee_min,omitempty"`

				// ServiceFeeMinPercentSum Минимальная сумма, после которой считается процент от суммы для типа min_or_percent
				ServiceFeeMinPercentSum *int `json:"service_fee_min_percent_sum,omitempty"`

				// ServiceFeePercent Процент сервисного сбора, берется всегда для типа percent_and_fixed и если сумма выше service_fee_min_percent_sum для типа min_or_percent
				ServiceFeePercent *float32 `json:"service_fee_percent,omitempty"`

				// ServiceFeePercentLevels Уровни комиссий
				ServiceFeePercentLevels *[]struct {
					// From Сумма от
					From *int `json:"from,omitempty"`

					// Percent Комиссия
					Percent *float32 `json:"percent,omitempty"`
				} `json:"service_fee_percent_levels,omitempty"`

				// ServiceFeeType Тип расчета комиссии. Возможные варианты: min_or_percent, percent_and_fixed
				ServiceFeeType *string `json:"service_fee_type,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSecurityUserDataResponse parses an HTTP response from a GetSecurityUserDataWithResponse call
func ParseGetSecurityUserDataResponse(rsp *http.Response) (*GetSecurityUserDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityUserDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ConfirmationType Тип уведомления call/sms/digits
				ConfirmationType *string `json:"confirmation_type,omitempty"`

				// Email email пользователя
				Email *string `json:"email,omitempty"`

				// IsAvailableKworkCreation Может ли пользователь создавать кворки
				IsAvailableKworkCreation *bool `json:"is_available_kwork_creation,omitempty"`

				// IsProfileCompleted Данные
				IsProfileCompleted *struct {
					// Details Заполнено ли поле `О себе`
					Details *bool `json:"details,omitempty"`

					// Profession Заполнено ли поле `Профессия`
					Profession *bool `json:"profession,omitempty"`

					// ProfilePic Заполнено ли поле `Аватар`
					ProfilePic *bool `json:"profile_pic,omitempty"`
				} `json:"is_profile_completed,omitempty"`

				// Phone Телефон пользователя
				Phone *string `json:"phone,omitempty"`

				// TelegramBotLink Ссылка для Telegram
				TelegramBotLink *string `json:"telegram_bot_link,omitempty"`

				// Username Имя пользователя
				Username *string `json:"username,omitempty"`

				// UsernameChangeAvailable Дата, с которой можно менять логин
				UsernameChangeAvailable *int `json:"username_change_available,omitempty"`

				// UsernameChanged Был ли изменен логин
				UsernameChanged *bool `json:"username_changed,omitempty"`

				// WhatsappLink Ссылка для WhatsApp
				WhatsappLink *string `json:"whatsapp_link,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubscribersStatisticsResponse parses an HTTP response from a GetSubscribersStatisticsWithResponse call
func ParseGetSubscribersStatisticsResponse(rsp *http.Response) (*GetSubscribersStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscribersStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Count Количество
				Count *int `json:"count,omitempty"`

				// Date Дата
				Date *string `json:"date,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTracksResponse parses an HTTP response from a GetTracksWithResponse call
func ParseGetTracksResponse(rsp *http.Response) (*GetTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Messages Массив элементов чата
				Messages *[]Track `json:"messages,omitempty"`

				// Review Блок отзывов и ответов на них
				Review *struct {
					// Answer Ответ на отзыв
					Answer *struct {
						// Actions Доступное действия
						Actions *struct {
							// Id Идентификатор действия
							Id *string `json:"id,omitempty"`
						} `json:"actions,omitempty"`

						// IsUnread Прочитан ли ответ на отзыв
						IsUnread *bool `json:"is_unread,omitempty"`

						// ModerationStatus Статус модерации (new - на модерации, active - видно всем, reject - отклонен)
						ModerationStatus *string `json:"moderation_status,omitempty"`

						// Review Ответ
						Review *string `json:"review,omitempty"`

						// SentTimestamp Время отправки UnixTime
						SentTimestamp *int `json:"sent_timestamp,omitempty"`

						// Title Название
						Title *string `json:"title,omitempty"`
					} `json:"answer,omitempty"`

					// Review Отзыв
					Review *struct {
						// Actions Действия
						Actions *[]string `json:"actions,omitempty"`

						// AutoMode Автоотзыв, если был
						AutoMode *string `json:"auto_mode,omitempty"`

						// IsUnread Прочитан ли отзыв
						IsUnread *bool `json:"is_unread,omitempty"`

						// Review Отзыв
						Review *string `json:"review,omitempty"`

						// SentTimestamp Время отправки UnixTime
						SentTimestamp *int `json:"sent_timestamp,omitempty"`

						// Title Название
						Title *string `json:"title,omitempty"`

						// Type Положительный/отрицательный
						Type *string `json:"type,omitempty"`
					} `json:"review,omitempty"`
				} `json:"review,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// AboutMeText Текст о себе
				AboutMeText *string `json:"about_me_text,omitempty"`

				// AchievmentsList Бейдж пользователя
				AchievmentsList *ProfileBadges `json:"achievments_list,omitempty"`

				// AvatarPath Путь к изображению аватара
				AvatarPath *string `json:"avatar_path,omitempty"`

				// BadReviews Количество отрицательных отзывов
				BadReviews *int `json:"bad_reviews,omitempty"`

				// CompletedOrdersCount Количество выполненных заказов
				CompletedOrdersCount *int `json:"completed_orders_count,omitempty"`

				// CompletedOrdersPercent Процент успешно сданных заказов
				CompletedOrdersPercent *int `json:"completed_orders_percent,omitempty"`

				// CoverPath Путь к баннеру пользователя
				CoverPath *string `json:"cover_path,omitempty"`

				// Fullname Настоящее имя
				Fullname *string `json:"fullname,omitempty"`

				// GoodReviews Количество положительных отзывов
				GoodReviews *int `json:"good_reviews,omitempty"`

				// Id Идентификатор пользователя
				Id *int `json:"id,omitempty"`

				// InTimeCompletedOrdersPercent Процент сданных вовремя заказов
				InTimeCompletedOrdersPercent *int `json:"in_time_completed_orders_percent,omitempty"`

				// IsCashlessPaymentAvailable Может ли работать по эскроу схеме
				IsCashlessPaymentAvailable *bool `json:"is_cashless_payment_available,omitempty"`

				// IsOnline Онлайн ли пользователь
				IsOnline *bool `json:"is_online,omitempty"`

				// IsVerifiedWorker Верифицирован ли по паспорту или по адресу
				IsVerifiedWorker *bool `json:"is_verified_worker,omitempty"`

				// KworksCount Кол-во кворков актора
				KworksCount *int `json:"kworks_count,omitempty"`

				// LastOnlineTimestamp Дата последней активности на сайте
				LastOnlineTimestamp *int `json:"last_online_timestamp,omitempty"`

				// Note Заметка о пользователе
				Note *struct {
					// PostedTimestamp Дата публикации
					PostedTimestamp *int `json:"posted_timestamp,omitempty"`

					// Text Текст заметки
					Text *int `json:"text,omitempty"`
				} `json:"note,omitempty"`

				// Profession Специальность пользователя
				Profession *string `json:"profession"`

				// RepeatedOrdersPercent Процент повторных заказов
				RepeatedOrdersPercent *int `json:"repeated_orders_percent,omitempty"`

				// ReviewsCount Общее количество отзывов
				ReviewsCount *int `json:"reviews_count,omitempty"`

				// Skills Навыки
				Skills *[]struct {
					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`
				} `json:"skills,omitempty"`

				// Username Имя пользователя
				Username *string `json:"username,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsersLastOrderInfoResponse parses an HTTP response from a GetUsersLastOrderInfoWithResponse call
func ParseGetUsersLastOrderInfoResponse(rsp *http.Response) (*GetUsersLastOrderInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersLastOrderInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// EndDay День месяца завершения заказа
				EndDay *string `json:"endDay,omitempty"`

				// EndMonth Месяц завершения заказа
				EndMonth *string `json:"endMonth,omitempty"`

				// EndYear Год завершения заказа
				EndYear *string `json:"endYear,omitempty"`

				// Interlocutor Username собеседника
				Interlocutor *string `json:"interlocutor,omitempty"`

				// OrderId Идентификатор заказа
				OrderId *int `json:"orderId,omitempty"`

				// StartDay День месяца создания заказа
				StartDay *string `json:"startDay,omitempty"`

				// StartMonth Месяц создания заказа
				StartMonth *string `json:"startMonth,omitempty"`

				// StartTime Дата создания заказа (предложения) unixtime
				StartTime *int `json:"startTime,omitempty"`

				// StartYear Год создания заказа
				StartYear *string `json:"startYear,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVoiceMessageConvertStatusResponse parses an HTTP response from a GetVoiceMessageConvertStatusWithResponse call
func ParseGetVoiceMessageConvertStatusResponse(rsp *http.Response) (*GetVoiceMessageConvertStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceMessageConvertStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVoiceMessageTranscriptionResponse parses an HTTP response from a GetVoiceMessageTranscriptionWithResponse call
func ParseGetVoiceMessageTranscriptionResponse(rsp *http.Response) (*GetVoiceMessageTranscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceMessageTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWantsCountResponse parses an HTTP response from a GetWantsCountWithResponse call
func ParseGetWantsCountResponse(rsp *http.Response) (*GetWantsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWantsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Count Количество найденных проектов
				Count   *int `json:"count,omitempty"`
				Filters *struct {
					ByBudget *[]BudgetWithCount `json:"by_budget,omitempty"`
					Offers   *[]KworksWithCount `json:"offers,omitempty"`
				} `json:"filters,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWebAuthTokenResponse parses an HTTP response from a GetWebAuthTokenWithResponse call
func ParseGetWebAuthTokenResponse(rsp *http.Response) (*GetWebAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ExpiresAt Срок жизни токена (UNIX timestamp)
				ExpiresAt *int `json:"expires_at,omitempty"`

				// Token Авторизационный токен
				Token *string `json:"token,omitempty"`

				// Url URL для входа в веб версию (с токеном)
				Url *string `json:"url,omitempty"`

				// UrlToRedirect URL, куда будет произведен редирект после входа в веб. Если указан NULL, будет производится редирект на главную.
				UrlToRedirect *int `json:"url_to_redirect,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHideDialogResponse parses an HTTP response from a HideDialogWithResponse call
func ParseHideDialogResponse(rsp *http.Response) (*HideDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HideDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Сообщение
			Message *string `json:"message,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`

			// UnhideAvailableSecs Количество секунд в течение которых можно востановить диалог
			UnhideAvailableSecs *int `json:"unhide_available_secs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHideSelfEmployedNotificationResponse parses an HTTP response from a HideSelfEmployedNotificationWithResponse call
func ParseHideSelfEmployedNotificationResponse(rsp *http.Response) (*HideSelfEmployedNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HideSelfEmployedNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHideVoiceMessageSettingsPopupResponse parses an HTTP response from a HideVoiceMessageSettingsPopupWithResponse call
func ParseHideVoiceMessageSettingsPopupResponse(rsp *http.Response) (*HideVoiceMessageSettingsPopupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HideVoiceMessageSettingsPopupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxComplainMessageResponse parses an HTTP response from a InboxComplainMessageWithResponse call
func ParseInboxComplainMessageResponse(rsp *http.Response) (*InboxComplainMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxComplainMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxCreateResponse parses an HTTP response from a InboxCreateWithResponse call
func ParseInboxCreateResponse(rsp *http.Response) (*InboxCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ConversationId Сквозной идентификатор сообщения или трека
				ConversationId *int `json:"conversation_id,omitempty"`

				// Id Идентификатор сообщения или трека
				Id *int `json:"id,omitempty"`

				// MassMailingNotification Необходимо ли вывести предупреждение о приближении к лимитам сообщений
				MassMailingNotification *bool `json:"mass_mailing_notification,omitempty"`

				// Page Номер страницы где находится сообщения
				Page *int `json:"page,omitempty"`

				// Time Дата сообщения UNIXTIME
				Time *int `json:"time,omitempty"`

				// Type Тип созданного сообщения
				Type *InboxCreate200ResponseType `json:"type,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Текст ошибки
			Error *string `json:"error,omitempty"`

			// ErrorCode Код ошибки
			ErrorCode *int `json:"error_code,omitempty"`

			// Response Данные
			Response *struct {
				// ExpireTime Количество секунд до снятия ограничения
				ExpireTime *int `json:"expire_time,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxCustomRequestDeclineResponse parses an HTTP response from a InboxCustomRequestDeclineWithResponse call
func ParseInboxCustomRequestDeclineResponse(rsp *http.Response) (*InboxCustomRequestDeclineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxCustomRequestDeclineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxDeleteResponse parses an HTTP response from a InboxDeleteWithResponse call
func ParseInboxDeleteResponse(rsp *http.Response) (*InboxDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxEditResponse parses an HTTP response from a InboxEditWithResponse call
func ParseInboxEditResponse(rsp *http.Response) (*InboxEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxForwardResponse parses an HTTP response from a InboxForwardWithResponse call
func ParseInboxForwardResponse(rsp *http.Response) (*InboxForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Files Массив информации по файлам
				Files *[]struct {
					// NewFileId Идентификатор пересланного файла
					NewFileId *int `json:"new_file_id,omitempty"`

					// OldFileId Идентификатор старого  файла
					OldFileId *int `json:"old_file_id,omitempty"`
				} `json:"files"`

				// NewMessageId Идентификатор пересланного сообщения
				NewMessageId *int `json:"new_message_id,omitempty"`

				// OldMessageId Идентификатор пересылаемого сообщения
				OldMessageId *int `json:"old_message_id,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxMessageResponse parses an HTTP response from a InboxMessageWithResponse call
func ParseInboxMessageResponse(rsp *http.Response) (*InboxMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]GetMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxPayerDeclineResponse parses an HTTP response from a InboxPayerDeclineWithResponse call
func ParseInboxPayerDeclineResponse(rsp *http.Response) (*InboxPayerDeclineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxPayerDeclineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxReadResponse parses an HTTP response from a InboxReadWithResponse call
func ParseInboxReadResponse(rsp *http.Response) (*InboxReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxTrackMessageResponse parses an HTTP response from a InboxTrackMessageWithResponse call
func ParseInboxTrackMessageResponse(rsp *http.Response) (*InboxTrackMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxTrackMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]GetMessageWithTrack `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxWorkerDeclineResponse parses an HTTP response from a InboxWorkerDeclineWithResponse call
func ParseInboxWorkerDeclineResponse(rsp *http.Response) (*InboxWorkerDeclineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxWorkerDeclineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInboxesResponse parses an HTTP response from a InboxesWithResponse call
func ParseInboxesResponse(rsp *http.Response) (*InboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]InboxMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIsDialogAllowResponse parses an HTTP response from a IsDialogAllowWithResponse call
func ParseIsDialogAllowResponse(rsp *http.Response) (*IsDialogAllowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsDialogAllowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные о разрешение диалога
			Response *struct {
				// CurrentUserTime Текущее время получателя
				CurrentUserTime *int `json:"currentUserTime,omitempty"`

				// HasDialog Наличие диалога с получателем
				HasDialog *bool `json:"hasDialog,omitempty"`

				// IsDaytime День ли сейчас в получателя
				IsDaytime *bool `json:"isDaytime,omitempty"`

				// IsOnline Онлайн ли получатель
				IsOnline *bool `json:"isOnline,omitempty"`

				// IsPageNeedSmsVerification Нужна ли верификация по СМС для отправки сообщения на этой странице
				IsPageNeedSmsVerification *bool `json:"isPageNeedSmsVerification,omitempty"`

				// IsSmsVerified Верифицирован ли по смс текущий пользователь
				IsSmsVerified *bool `json:"isSmsVerified,omitempty"`

				// PrivateMessageStatus Текущий код разрешения диалога
				PrivateMessageStatus *int `json:"privateMessageStatus,omitempty"`

				// PrivateMessageStatuses Возможные коды причин запрета переписки
				PrivateMessageStatuses *map[string]interface{} `json:"privateMessageStatuses,omitempty"`

				// ReceivedLastOnline Метка времени получателя последнего статуса онлайн
				ReceivedLastOnline *int `json:"receivedLastOnline,omitempty"`

				// ResponseTime Показатель отвечает за в строковом представлении
				ResponseTime *string `json:"responseTime,omitempty"`

				// ShowInboxAllowModal Флаг необходимости показа окна разрешения отправки
				ShowInboxAllowModal *bool `json:"showInboxAllowModal,omitempty"`

				// UserUtcOffset Разница во временной зоне между UTC и получателем
				UserUtcOffset *int `json:"userUtcOffset,omitempty"`

				// UtcOffset Разница во временной зоне между отправителем и получателем
				UtcOffset *int `json:"utcOffset,omitempty"`

				// WorkTime Информация по рабочему времени получателя
				WorkTime *string `json:"workTime,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseKworksResponse parses an HTTP response from a KworksWithResponse call
func ParseKworksResponse(rsp *http.Response) (*KworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Kworks Кворки
			Kworks *[]KworkInListWithWorkerLevel `json:"kworks,omitempty"`

			// Response Данные
			Response *struct {
				// Classifiers Вложенные классификаторы
				Classifiers *[]struct {
					// Id Идентификатор
					Id *int `json:"id,omitempty"`

					// IsCatalogItem Это элемент каталога или классификация(аттрибут)?
					IsCatalogItem *bool `json:"isCatalogItem,omitempty"`

					// KworksCount Количество кворков внутри классификатора
					KworksCount *int `json:"kworks_count,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`

					// Visibility Видимость:1-всем, 2-только продавцам, 3-виден всем в в панели поиска, но не на странице кворка
					Visibility *int `json:"visibility,omitempty"`
				} `json:"classifiers,omitempty"`

				// KworksCount Количество кворков
				KworksCount *int `json:"kworks_count,omitempty"`

				// Paging Данные пагинации с лимитом
				Paging *PagingWithPages `json:"paging,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseKworksCategoriesListResponse parses an HTTP response from a KworksCategoriesListWithResponse call
func ParseKworksCategoriesListResponse(rsp *http.Response) (*KworksCategoriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KworksCategoriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Id Идентификатор категории
				Id *int `json:"id,omitempty"`

				// Kworks Кворки пользователя
				Kworks *ProfileKworksWithWorkerLevel `json:"kworks,omitempty"`

				// KworksCount Количество активных кворков в категории
				KworksCount *int `json:"kworks_count,omitempty"`

				// Name Название категории
				Name *string `json:"name,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseKworksStatusListResponse parses an HTTP response from a KworksStatusListWithResponse call
func ParseKworksStatusListResponse(rsp *http.Response) (*KworksStatusListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &KworksStatusListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Kworks Кворк пользователя
				Kworks *ProfileKwork `json:"kworks,omitempty"`

				// KworksCount Количество кворков в группе
				KworksCount *int `json:"kworks_count,omitempty"`

				// Name Название группы
				Name *string `json:"name,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkInboxTracksAsReadResponse parses an HTTP response from a MarkInboxTracksAsReadWithResponse call
func ParseMarkInboxTracksAsReadResponse(rsp *http.Response) (*MarkInboxTracksAsReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkInboxTracksAsReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkKworkAsFavoriteResponse parses an HTTP response from a MarkKworkAsFavoriteWithResponse call
func ParseMarkKworkAsFavoriteResponse(rsp *http.Response) (*MarkKworkAsFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkKworkAsFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkKworkAsHiddenResponse parses an HTTP response from a MarkKworkAsHiddenWithResponse call
func ParseMarkKworkAsHiddenResponse(rsp *http.Response) (*MarkKworkAsHiddenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkKworkAsHiddenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkKworksBlackFridayResponse parses an HTTP response from a MarkKworksBlackFridayWithResponse call
func ParseMarkKworksBlackFridayResponse(rsp *http.Response) (*MarkKworksBlackFridayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkKworksBlackFridayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// BlackFridayPrice цена кворка в период ЧП
				BlackFridayPrice *int `json:"black_friday_price,omitempty"`

				// DiscountPercentage размер скидки для бейджа
				DiscountPercentage *int `json:"discount_percentage,omitempty"`

				// IsBlackFriday участвует ли кворк в ЧП
				IsBlackFriday *bool `json:"is_black_friday,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkVoiceMessageHeardResponse parses an HTTP response from a MarkVoiceMessageHeardWithResponse call
func ParseMarkVoiceMessageHeardResponse(rsp *http.Response) (*MarkVoiceMessageHeardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkVoiceMessageHeardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMiniatureResponse parses an HTTP response from a MiniatureWithResponse call
func ParseMiniatureResponse(rsp *http.Response) (*MiniatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MiniatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMyWantsResponse parses an HTTP response from a MyWantsWithResponse call
func ParseMyWantsResponse(rsp *http.Response) (*MyWantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MyWantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]WantPayer `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseNotificationsResponse parses an HTTP response from a NotificationsWithResponse call
func ParseNotificationsResponse(rsp *http.Response) (*NotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Сгруппированные по типам уведомления
			Response *[]NotificationType `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseNotificationsFetchResponse parses an HTTP response from a NotificationsFetchWithResponse call
func ParseNotificationsFetchResponse(rsp *http.Response) (*NotificationsFetchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsFetchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Push-события
			Response *[]PushEvent `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseNotificationsReceivedResponse parses an HTTP response from a NotificationsReceivedWithResponse call
func ParseNotificationsReceivedResponse(rsp *http.Response) (*NotificationsReceivedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationsReceivedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOfferResponse parses an HTTP response from a OfferWithResponse call
func ParseOfferResponse(rsp *http.Response) (*OfferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Предложение на запрос услуги на бирже
			Response *Offer `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOfferOrderOptionsResponse parses an HTTP response from a OfferOrderOptionsWithResponse call
func ParseOfferOrderOptionsResponse(rsp *http.Response) (*OfferOrderOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfferOrderOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Messages Массив элементов чата
				Messages *[]Track `json:"messages,omitempty"`

				// User Данные о собеседнике
				User *Interlocutor `json:"user,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOffersResponse parses an HTTP response from a OffersWithResponse call
func ParseOffersResponse(rsp *http.Response) (*OffersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OffersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Connects Объект с коннектами
			Connects *Connects `json:"connects,omitempty"`

			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]Offer `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOfflineResponse parses an HTTP response from a OfflineWithResponse call
func ParseOfflineResponse(rsp *http.Response) (*OfflineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfflineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOrderResponse parses an HTTP response from a OrderWithResponse call
func ParseOrderResponse(rsp *http.Response) (*OrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// Order Данные заказа
				Order *struct {
					// Id Идентификатор заказа
					Id *int `json:"id,omitempty"`

					// KworkTitle Название заказа для пользователя
					KworkTitle *string `json:"kwork_title,omitempty"`
				} `json:"order,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOrderKworkResponse parses an HTTP response from a OrderKworkWithResponse call
func ParseOrderKworkResponse(rsp *http.Response) (*OrderKworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrderKworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// OrderId Идентификатор созданного заказа
				OrderId *int `json:"orderId,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest BalanceDeficit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOrderStageResponse parses an HTTP response from a OrderStageWithResponse call
func ParseOrderStageResponse(rsp *http.Response) (*OrderStageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrderStageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOrdersBetweenResponse parses an HTTP response from a OrdersBetweenWithResponse call
func ParseOrdersBetweenResponse(rsp *http.Response) (*OrdersBetweenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrdersBetweenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Id Идентификатор заказа
				Id *int `json:"id,omitempty"`

				// KworkTitle Название заказа
				KworkTitle *string `json:"kwork_title,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePauseKworkResponse parses an HTTP response from a PauseKworkWithResponse call
func ParsePauseKworkResponse(rsp *http.Response) (*PauseKworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseKworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePayOrderAwaitingPaymentResponse parses an HTTP response from a PayOrderAwaitingPaymentWithResponse call
func ParsePayOrderAwaitingPaymentResponse(rsp *http.Response) (*PayOrderAwaitingPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayOrderAwaitingPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePayerBuyExtrasResponse parses an HTTP response from a PayerBuyExtrasWithResponse call
func ParsePayerBuyExtrasResponse(rsp *http.Response) (*PayerBuyExtrasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayerBuyExtrasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest BalanceDeficit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePayerDeclineExtrasResponse parses an HTTP response from a PayerDeclineExtrasWithResponse call
func ParsePayerDeclineExtrasResponse(rsp *http.Response) (*PayerDeclineExtrasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayerDeclineExtrasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePayerDeclinesExtraRemovalRequestResponse parses an HTTP response from a PayerDeclinesExtraRemovalRequestWithResponse call
func ParsePayerDeclinesExtraRemovalRequestResponse(rsp *http.Response) (*PayerDeclinesExtraRemovalRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayerDeclinesExtraRemovalRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePayerExtraDeleteResponse parses an HTTP response from a PayerExtraDeleteWithResponse call
func ParsePayerExtraDeleteResponse(rsp *http.Response) (*PayerExtraDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayerExtraDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePayerOrdersResponse parses an HTTP response from a PayerOrdersWithResponse call
func ParsePayerOrdersResponse(rsp *http.Response) (*PayerOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayerOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Filter Выбранный фильтр
				Filter *string `json:"filter,omitempty"`

				// FilterCounts Объект количеств по статусам
				FilterCounts *struct {
					// Active Количество заказов по фильтру active
					Active *int `json:"active,omitempty"`

					// All Общее количество заказов
					All *int `json:"all,omitempty"`

					// Cancelled Количество заказов по фильтру cancelled
					Cancelled *int `json:"cancelled,omitempty"`

					// Completed Количество заказов по фильтру completed
					Completed *int `json:"completed,omitempty"`

					// Delivered Количество заказов по фильтру delivered
					Delivered *int `json:"delivered,omitempty"`
				} `json:"filter_counts,omitempty"`

				// Orders Массив объектов - заказов
				Orders *struct {
					// CanAddReview Можно добавить отзыв
					CanAddReview *bool `json:"can_add_review,omitempty"`

					// CanRepeatOrder Можно ли заказать еще
					CanRepeatOrder *bool `json:"can_repeat_order,omitempty"`

					// CanсelReason Причина отмены заказа
					CanсelReason *string `json:"canсel_reason,omitempty"`

					// Deadline Время дедлайна заказа UNIXTIME
					Deadline *int `json:"deadline,omitempty"`

					// DisplayTime Время для показа заказа UNIXTIME, При фильтре Выполненные - дата сдачи заказа на проверку (она же дата выполнения), При фильтре Отмененные - дата отмены заказа, В остальных случаях - дата создания заказа
					DisplayTime *int `json:"display_time,omitempty"`

					// DisplayTitle Пользовательское название заказа
					DisplayTitle *string `json:"display_title,omitempty"`

					// HasCompletedStages Есть ли выполненные этапы
					HasCompletedStages *bool `json:"has_completed_stages,omitempty"`

					// HasStages Содержит ли заказ этапы
					HasStages *bool `json:"has_stages,omitempty"`

					// Id Идентификатор заказа
					Id *int `json:"id,omitempty"`

					// InWork Взят в работу
					InWork *bool `json:"in_work,omitempty"`

					// IsCancelRequest Заказ в состоянии запроса отмены (показывать сколько времени осталось на выполнение не нужно) Только для заказов в статусе 1 - В работе
					IsCancelRequest *bool `json:"is_cancel_request,omitempty"`

					// KworkId Идентификатор кворка
					KworkId *int `json:"kwork_id,omitempty"`

					// KworkTitle Название кворка
					KworkTitle *string `json:"kwork_title,omitempty"`

					// MissingData Данные не предоставлены
					MissingData *bool `json:"missing_data,omitempty"`

					// OrderNote Заметка о заказе
					OrderNote *string `json:"order_note,omitempty"`

					// PaymentType Тип заказа: 0 - физлицо, 1 - подписка, 2 - эскроу
					PaymentType *int `json:"payment_type,omitempty"`

					// Photo Путь к обложке кворка
					Photo *string `json:"photo,omitempty"`

					// Price Цена
					Price *float32 `json:"price,omitempty"`

					// Progress Прогресс выполнения работ по заказу
					Progress *int `json:"progress,omitempty"`

					// Project Запрос
					Project *string `json:"project,omitempty"`

					// StagesPrice Цена за все этапы
					StagesPrice *float32 `json:"stages_price,omitempty"`

					// Status Статус заказа 	1 - В работе, 2 - Арбитраж, 3 - Отменен, 4 - На проверке, 5 - Выполнен, 6 - Требуется оплата
					Status *int `json:"status,omitempty"`

					// StatusVirtual Виртуальный статус заказа
					StatusVirtual *int `json:"statusVirtual,omitempty"`

					// TimeAdded Дата заказа UNIXTIME
					TimeAdded *int `json:"time_added,omitempty"`

					// UnreadTracks Количество непрочитанных сообщений в заказе
					UnreadTracks *int `json:"unread_tracks,omitempty"`

					// Worker Объект данных продавца
					Worker *struct {
						// Id Идентификатор
						Id *int `json:"id,omitempty"`

						// IsOnline Онлайн ли пользователь
						IsOnline *bool `json:"is_online,omitempty"`

						// Profilepicture Ссылка на изображение аватара
						Profilepicture *string `json:"profilepicture,omitempty"`

						// Username Имя пользователя
						Username *string `json:"username,omitempty"`
					} `json:"worker,omitempty"`

					// YescrowPaymentNotAvailable Бензнал Эскроу больше не доступен
					YescrowPaymentNotAvailable *bool `json:"yescrowPaymentNotAvailable,omitempty"`
				} `json:"orders,omitempty"`

				// Paging Объект данных пагинации
				Paging *struct {
					// Limit Количество элементов на странице
					Limit *int `json:"limit,omitempty"`

					// Page Текущая страница
					Page *int `json:"page,omitempty"`

					// Total Общее количество заказов по текущему фильтру
					Total *int `json:"total,omitempty"`
				} `json:"paging,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePayerUpgradePackageResponse parses an HTTP response from a PayerUpgradePackageWithResponse call
func ParsePayerUpgradePackageResponse(rsp *http.Response) (*PayerUpgradePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayerUpgradePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest BalanceDeficit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePortfolioCategoriesListResponse parses an HTTP response from a PortfolioCategoriesListWithResponse call
func ParsePortfolioCategoriesListResponse(rsp *http.Response) (*PortfolioCategoriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PortfolioCategoriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Id Идентификатор категории
				Id *int `json:"id,omitempty"`

				// Name Название категории
				Name *string `json:"name,omitempty"`

				// PortfolioCount Количество работ в категории
				PortfolioCount *int `json:"portfolio_count,omitempty"`

				// PortfolioList Портфолио пользователя
				PortfolioList *ProfilePortfolios `json:"portfolio_list,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePortfolioListResponse parses an HTTP response from a PortfolioListWithResponse call
func ParsePortfolioListResponse(rsp *http.Response) (*PortfolioListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PortfolioListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Paging Информация о пагинации
				Paging *struct {
					// Limit Количество элементов на странице
					Limit *int `json:"limit,omitempty"`

					// Page Номер страницы
					Page *int `json:"page,omitempty"`

					// Pages Всего страниц
					Pages *int `json:"pages,omitempty"`

					// Total Всего портфолио
					Total *int `json:"total,omitempty"`
				} `json:"paging,omitempty"`

				// Portfolio Портфолио пользователя
				Portfolio *ProfilePortfolios `json:"portfolio,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePositiveReviewsCountResponse parses an HTTP response from a PositiveReviewsCountWithResponse call
func ParsePositiveReviewsCountResponse(rsp *http.Response) (*PositiveReviewsCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PositiveReviewsCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Количество отзывов => Количество кворков с таким количество отзывов
			Response *PositiveReviewsCount `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrivacyResponse parses an HTTP response from a PrivacyWithResponse call
func ParsePrivacyResponse(rsp *http.Response) (*PrivacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrivacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimpleHtml
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectsResponse parses an HTTP response from a ProjectsWithResponse call
func ParseProjectsResponse(rsp *http.Response) (*ProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Connects Объект с коннектами
			Connects *Connects `json:"connects,omitempty"`

			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]WantWorker `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePushInAppNotificationLogResponse parses an HTTP response from a PushInAppNotificationLogWithResponse call
func ParsePushInAppNotificationLogResponse(rsp *http.Response) (*PushInAppNotificationLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PushInAppNotificationLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRateArbitrationResponse parses an HTTP response from a RateArbitrationWithResponse call
func ParseRateArbitrationResponse(rsp *http.Response) (*RateArbitrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RateArbitrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRechargeBalanceResponse parses an HTTP response from a RechargeBalanceWithResponse call
func ParseRechargeBalanceResponse(rsp *http.Response) (*RechargeBalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RechargeBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// PaymentUrlWebView Ссылка оплаты в WebView
				PaymentUrlWebView *string `json:"paymentUrlWebView,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRegisterCloudTokenResponse parses an HTTP response from a RegisterCloudTokenWithResponse call
func ParseRegisterCloudTokenResponse(rsp *http.Response) (*RegisterCloudTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterCloudTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRejectCancelOrderRequestByPayerResponse parses an HTTP response from a RejectCancelOrderRequestByPayerWithResponse call
func ParseRejectCancelOrderRequestByPayerResponse(rsp *http.Response) (*RejectCancelOrderRequestByPayerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectCancelOrderRequestByPayerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRejectCancelOrderRequestByWorkerResponse parses an HTTP response from a RejectCancelOrderRequestByWorkerWithResponse call
func ParseRejectCancelOrderRequestByWorkerResponse(rsp *http.Response) (*RejectCancelOrderRequestByWorkerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectCancelOrderRequestByWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRejectStageSuggestionResponse parses an HTTP response from a RejectStageSuggestionWithResponse call
func ParseRejectStageSuggestionResponse(rsp *http.Response) (*RejectStageSuggestionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectStageSuggestionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRepeatOrderResponse parses an HTTP response from a RepeatOrderWithResponse call
func ParseRepeatOrderResponse(rsp *http.Response) (*RepeatOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepeatOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// OrderId Идентификатор созданного заказа
				OrderId *int `json:"orderId,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest BalanceDeficit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReportAppVersionResponse parses an HTTP response from a ReportAppVersionWithResponse call
func ParseReportAppVersionResponse(rsp *http.Response) (*ReportAppVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportAppVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRequestPhoneChangingResponse parses an HTTP response from a RequestPhoneChangingWithResponse call
func ParseRequestPhoneChangingResponse(rsp *http.Response) (*RequestPhoneChangingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestPhoneChangingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Hash Валидационный кеш
				Hash *string `json:"hash,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResolutionResponse parses an HTTP response from a ResolutionWithResponse call
func ParseResolutionResponse(rsp *http.Response) (*ResolutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimpleHtml
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestartWantResponse parses an HTTP response from a RestartWantWithResponse call
func ParseRestartWantResponse(rsp *http.Response) (*RestartWantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartWantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveOrderNoteResponse parses an HTTP response from a SaveOrderNoteWithResponse call
func ParseSaveOrderNoteResponse(rsp *http.Response) (*SaveOrderNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveOrderNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveUserNoteResponse parses an HTTP response from a SaveUserNoteWithResponse call
func ParseSaveUserNoteResponse(rsp *http.Response) (*SaveUserNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Classifiers Вложенные классификаторы
			Classifiers *[]struct {
				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// IsCatalogItem Это элемент каталога или классификация(аттрибут)?
				IsCatalogItem *bool `json:"isCatalogItem,omitempty"`

				// KworksCount Количество кворков внутри классификатора
				KworksCount *int `json:"kworks_count,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`

				// Visibility Видимость:1-всем, 2-только продавцам, 3-виден всем в в панели поиска, но не на странице кворка
				Visibility *int `json:"visibility,omitempty"`
			} `json:"classifiers,omitempty"`

			// Paging Данные пагинации
			Paging *[]struct {
				// Limit Количество кворков на странице
				Limit *int `json:"limit,omitempty"`

				// Page Номер текущей страницы
				Page *int `json:"page,omitempty"`

				// Total Общее количество кворков
				Total *int `json:"total,omitempty"`
			} `json:"paging,omitempty"`

			// Response Найденные кворки
			Response *[]ProfileKworksWithWorkerLevel `json:"response,omitempty"`

			// SearchCategories Категории и количество результатов
			SearchCategories *[]struct {
				// Category ID
				Category *int `json:"category,omitempty"`

				// Count Количество записей
				Count *int `json:"count,omitempty"`

				// Name Название категории
				Name *string `json:"name,omitempty"`
			} `json:"searchCategories,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchDialogsResponse parses an HTTP response from a SearchDialogsWithResponse call
func ParseSearchDialogsResponse(rsp *http.Response) (*SearchDialogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDialogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации
			Paging *Paging `json:"paging,omitempty"`

			// Response Массив объектов сообщений
			Response *[]DialogMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchInboxesResponse parses an HTTP response from a SearchInboxesWithResponse call
func ParseSearchInboxesResponse(rsp *http.Response) (*SearchInboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchInboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]InboxMessage `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchKworksCatalogQueryResponse parses an HTTP response from a SearchKworksCatalogQueryWithResponse call
func ParseSearchKworksCatalogQueryResponse(rsp *http.Response) (*SearchKworksCatalogQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchKworksCatalogQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Найденные фразы
			Response *[]map[string]interface{} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchMessagesResponse parses an HTTP response from a SearchMessagesWithResponse call
func ParseSearchMessagesResponse(rsp *http.Response) (*SearchMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]struct {
				// ConversationId conversation_id
				ConversationId *int `json:"conversation_id,omitempty"`

				// Id id сообщения
				Id *int `json:"id,omitempty"`

				// Phrase Найденное слово
				Phrase *string `json:"phrase,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchOrderTracksResponse parses an HTTP response from a SearchOrderTracksWithResponse call
func ParseSearchOrderTracksResponse(rsp *http.Response) (*SearchOrderTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchOrderTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Данные
			Response *[]struct {
				// ConversationId conversation_id
				ConversationId *int `json:"conversation_id,omitempty"`

				// Id id сообщения
				Id *int `json:"id,omitempty"`

				// Phrase Найденное слово
				Phrase *string `json:"phrase,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchTracksResponse parses an HTTP response from a SearchTracksWithResponse call
func ParseSearchTracksResponse(rsp *http.Response) (*SearchTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Идентификаторы треков
			Response *[]int `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendBonusResponse parses an HTTP response from a SendBonusWithResponse call
func ParseSendBonusResponse(rsp *http.Response) (*SendBonusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendBonusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// Amount Сумма пополнения без комиссии, если не хватает средств
				Amount *int `json:"amount,omitempty"`

				// Error Текст ошибки
				Error *string `json:"error,omitempty"`

				// ErrorCode Код ошибки
				ErrorCode *int `json:"error_code,omitempty"`

				// PaymentTypeAvailable Доступные типы оплаты для пользователя
				PaymentTypeAvailable *map[string]interface{} `json:"payment_type_available,omitempty"`

				// PaymentUrl Ссылка на платежную систему для пополнения на необходимую сумму
				PaymentUrl *string `json:"payment_url,omitempty"`

				// ServiceFeeMin Фиксированная минимальная сумма сервисного сбора, которая считается до service_fee_min_percent_sum
				ServiceFeeMin *int `json:"service_fee_min,omitempty"`

				// ServiceFeeMinPercentSum Минимальная сумма, после которой считается процент от суммы
				ServiceFeeMinPercentSum *int `json:"service_fee_min_percent_sum,omitempty"`

				// ServiceFeePercent Процент сервисного сбора, если сумма выше service_fee_min_percent_sum
				ServiceFeePercent *float32 `json:"service_fee_percent,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendCompanyForVerificationResponse parses an HTTP response from a SendCompanyForVerificationWithResponse call
func ParseSendCompanyForVerificationResponse(rsp *http.Response) (*SendCompanyForVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendCompanyForVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Результат
			Response *struct {
				// Status 0 – на проверке, 1 – одобрено, 2 – отказано
				Status *int `json:"status,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendOrderForApprovalResponse parses an HTTP response from a SendOrderForApprovalWithResponse call
func ParseSendOrderForApprovalResponse(rsp *http.Response) (*SendOrderForApprovalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendOrderForApprovalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendOrderForArbitrationResponse parses an HTTP response from a SendOrderForArbitrationWithResponse call
func ParseSendOrderForArbitrationResponse(rsp *http.Response) (*SendOrderForArbitrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendOrderForArbitrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendOrderForRevisionResponse parses an HTTP response from a SendOrderForRevisionWithResponse call
func ParseSendOrderForRevisionResponse(rsp *http.Response) (*SendOrderForRevisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendOrderForRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendOrderReceiptLinkForVerificationResponse parses an HTTP response from a SendOrderReceiptLinkForVerificationWithResponse call
func ParseSendOrderReceiptLinkForVerificationResponse(rsp *http.Response) (*SendOrderReceiptLinkForVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendOrderReceiptLinkForVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendOrderRequirementsResponse parses an HTTP response from a SendOrderRequirementsWithResponse call
func ParseSendOrderRequirementsResponse(rsp *http.Response) (*SendOrderRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendOrderRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendReportResponse parses an HTTP response from a SendReportWithResponse call
func ParseSendReportResponse(rsp *http.Response) (*SendReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// TrackId Идентификатор созданного трека
				TrackId *int `json:"trackId,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendSelfEmployedSurveyResultResponse parses an HTTP response from a SendSelfEmployedSurveyResultWithResponse call
func ParseSendSelfEmployedSurveyResultResponse(rsp *http.Response) (*SendSelfEmployedSurveyResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendSelfEmployedSurveyResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendUserStatusResponse parses an HTTP response from a SendUserStatusWithResponse call
func ParseSendUserStatusResponse(rsp *http.Response) (*SendUserStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendUserStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendWhatsAppCodeResponse parses an HTTP response from a SendWhatsAppCodeWithResponse call
func ParseSendWhatsAppCodeResponse(rsp *http.Response) (*SendWhatsAppCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendWhatsAppCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Phone Маска номера телефона, на который отправили код
				Phone *string `json:"phone,omitempty"`

				// Timeout Время через которое можно повторить отправку
				Timeout *int `json:"timeout,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetAvailableAtWeekendsResponse parses an HTTP response from a SetAvailableAtWeekendsWithResponse call
func ParseSetAvailableAtWeekendsResponse(rsp *http.Response) (*SetAvailableAtWeekendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAvailableAtWeekendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetDialogStarredResponse parses an HTTP response from a SetDialogStarredWithResponse call
func ParseSetDialogStarredResponse(rsp *http.Response) (*SetDialogStarredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDialogStarredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Сообщение
			Message *string `json:"message,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetFavoriteResponse parses an HTTP response from a SetFavoriteWithResponse call
func ParseSetFavoriteResponse(rsp *http.Response) (*SetFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetFishingTutorialStatusResponse parses an HTTP response from a SetFishingTutorialStatusWithResponse call
func ParseSetFishingTutorialStatusResponse(rsp *http.Response) (*SetFishingTutorialStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFishingTutorialStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности запроса
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetOrderRatingResponse parses an HTTP response from a SetOrderRatingWithResponse call
func ParseSetOrderRatingResponse(rsp *http.Response) (*SetOrderRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOrderRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetTakingOrdersResponse parses an HTTP response from a SetTakingOrdersWithResponse call
func ParseSetTakingOrdersResponse(rsp *http.Response) (*SetTakingOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetTakingOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetUserTypeResponse parses an HTTP response from a SetUserTypeWithResponse call
func ParseSetUserTypeResponse(rsp *http.Response) (*SetUserTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetUserTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// IsSupportDialogAvailable Флаг открытого общения со службой поддержки
				IsSupportDialogAvailable *bool `json:"is_support_dialog_available,omitempty"`

				// SelfEmployed Информация СЗ/ИП
				SelfEmployed *struct {
					// ShowRegistrationNotification Флаг для отображения успешной регистрации СЗ/ИП
					ShowRegistrationNotification *bool `json:"show_registration_notification,omitempty"`

					// ShowSurveyPopup Флаг для отображения опроса
					ShowSurveyPopup *bool `json:"show_survey_popup,omitempty"`
				} `json:"self_employed,omitempty"`

				// TestGroups Набор тестовых групп пользователя
				TestGroups *[]map[string]bool `json:"test_groups,omitempty"`

				// VoiceMessages Голосовые сообщения
				VoiceMessages *struct {
					// IsVoiceMessageRecordingAvailable Разрешение записывать ГС
					IsVoiceMessageRecordingAvailable *bool `json:"is_voice_message_recording_available,omitempty"`

					// ReceivingSettings Настройки получения ГС
					ReceivingSettings *struct {
						// IsReceivingAllowed Флаг разрешения приема ГС
						IsReceivingAllowed *bool `json:"is_receiving_allowed,omitempty"`

						// IsReceivingSettingAllowed Флаг доступности настройки ГС
						IsReceivingSettingAllowed *bool `json:"is_receiving_setting_allowed,omitempty"`

						// ShouldShowSettingsPopup Флаг показа попапа
						ShouldShowSettingsPopup *bool `json:"should_show_settings_popup,omitempty"`
					} `json:"receiving_settings,omitempty"`

					// SpeedControl Параметры скорости ГС
					SpeedControl *struct {
						// AvailableSpeeds Список допустимых скоростей
						AvailableSpeeds *[]float32 `json:"available_speeds,omitempty"`

						// IsAvailable Разрешение менять скорость
						IsAvailable *bool `json:"is_available,omitempty"`

						// Speed Скорость воспроизведения
						Speed *float32 `json:"speed,omitempty"`
					} `json:"speed_control,omitempty"`
				} `json:"voice_messages,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetVoiceMessageReceivingResponse parses an HTTP response from a SetVoiceMessageReceivingWithResponse call
func ParseSetVoiceMessageReceivingResponse(rsp *http.Response) (*SetVoiceMessageReceivingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVoiceMessageReceivingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetVoiceMessageSpeedResponse parses an HTTP response from a SetVoiceMessageSpeedWithResponse call
func ParseSetVoiceMessageSpeedResponse(rsp *http.Response) (*SetVoiceMessageSpeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVoiceMessageSpeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// Speed Скорость воспроизведения
				Speed *float32 `json:"speed,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSignInResponse parses an HTTP response from a SignInWithResponse call
func ParseSignInResponse(rsp *http.Response) (*SignInResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignInResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Текст ошибки
			Error *string `json:"error,omitempty"`

			// ErrorCode Код ошибки
			ErrorCode *int `json:"error_code,omitempty"`

			// RecaptchaPassToken Токен для пропуска капчи
			RecaptchaPassToken *string `json:"recaptcha_pass_token,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSignUpResponse parses an HTTP response from a SignUpWithResponse call
func ParseSignUpResponse(rsp *http.Response) (*SignUpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignUpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialSignInResponse parses an HTTP response from a SocialSignInWithResponse call
func ParseSocialSignInResponse(rsp *http.Response) (*SocialSignInResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialSignInResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialSignInByTokenResponse parses an HTTP response from a SocialSignInByTokenWithResponse call
func ParseSocialSignInByTokenResponse(rsp *http.Response) (*SocialSignInByTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialSignInByTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialSignInByTokenv2Response parses an HTTP response from a SocialSignInByTokenv2WithResponse call
func ParseSocialSignInByTokenv2Response(rsp *http.Response) (*SocialSignInByTokenv2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialSignInByTokenv2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialSignUpResponse parses an HTTP response from a SocialSignUpWithResponse call
func ParseSocialSignUpResponse(rsp *http.Response) (*SocialSignUpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialSignUpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialSignUpByTokenResponse parses an HTTP response from a SocialSignUpByTokenWithResponse call
func ParseSocialSignUpByTokenResponse(rsp *http.Response) (*SocialSignUpByTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialSignUpByTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartKworkResponse parses an HTTP response from a StartKworkWithResponse call
func ParseStartKworkResponse(rsp *http.Response) (*StartKworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartKworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Message Активирован или активирован и станет активным после проверки модератором
				Message *string `json:"message,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopWantResponse parses an HTTP response from a StopWantWithResponse call
func ParseStopWantResponse(rsp *http.Response) (*StopWantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopWantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSuggestStagesResponse parses an HTTP response from a SuggestStagesWithResponse call
func ParseSuggestStagesResponse(rsp *http.Response) (*SuggestStagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuggestStagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTermsResponse parses an HTTP response from a TermsWithResponse call
func ParseTermsResponse(rsp *http.Response) (*TermsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TermsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimpleHtml
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTermsOfServiceResponse parses an HTTP response from a TermsOfServiceWithResponse call
func ParseTermsOfServiceResponse(rsp *http.Response) (*TermsOfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TermsOfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimpleHtml
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTimezonesResponse parses an HTTP response from a TimezonesWithResponse call
func ParseTimezonesResponse(rsp *http.Response) (*TimezonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimezonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Временные зоны
			Response *[]struct {
				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Name Название
				Name *string `json:"name,omitempty"`

				// UtcOffset Сдвиг от UTC
				UtcOffset *string `json:"utc_offset,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTrackDeleteResponse parses an HTTP response from a TrackDeleteWithResponse call
func ParseTrackDeleteResponse(rsp *http.Response) (*TrackDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTrackEditResponse parses an HTTP response from a TrackEditWithResponse call
func ParseTrackEditResponse(rsp *http.Response) (*TrackEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTrackMessageResponse parses an HTTP response from a TrackMessageWithResponse call
func ParseTrackMessageResponse(rsp *http.Response) (*TrackMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]Track `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTrackReadResponse parses an HTTP response from a TrackReadWithResponse call
func ParseTrackReadResponse(rsp *http.Response) (*TrackReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTranslationLanguagesResponse parses an HTTP response from a TranslationLanguagesWithResponse call
func ParseTranslationLanguagesResponse(rsp *http.Response) (*TranslationLanguagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TranslationLanguagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Языки для перевода
			Response *map[string]struct {
				// Genitive Название в родительном падеже
				Genitive *string `json:"genitive,omitempty"`

				// Id Идентификатор
				Id *int `json:"id,omitempty"`

				// Nominative Название в именительном падеже
				Nominative *string `json:"nominative,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTypingResponse parses an HTTP response from a TypingWithResponse call
func ParseTypingResponse(rsp *http.Response) (*TypingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TypingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnarchiveDialogResponse parses an HTTP response from a UnarchiveDialogWithResponse call
func ParseUnarchiveDialogResponse(rsp *http.Response) (*UnarchiveDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnblockDialogResponse parses an HTTP response from a UnblockDialogWithResponse call
func ParseUnblockDialogResponse(rsp *http.Response) (*UnblockDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnblockDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Message Сообщение об успехе
				Message *string `json:"message,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUnreadDialogResponse parses an HTTP response from a UnreadDialogWithResponse call
func ParseUnreadDialogResponse(rsp *http.Response) (*UnreadDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnreadDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAvatarResponse parses an HTTP response from a UpdateAvatarWithResponse call
func ParseUpdateAvatarResponse(rsp *http.Response) (*UpdateAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateChatDraftMessageResponse parses an HTTP response from a UpdateChatDraftMessageWithResponse call
func ParseUpdateChatDraftMessageResponse(rsp *http.Response) (*UpdateChatDraftMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChatDraftMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateOrderDraftMessageResponse parses an HTTP response from a UpdateOrderDraftMessageWithResponse call
func ParseUpdateOrderDraftMessageResponse(rsp *http.Response) (*UpdateOrderDraftMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrderDraftMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSettingsResponse parses an HTTP response from a UpdateSettingsWithResponse call
func ParseUpdateSettingsResponse(rsp *http.Response) (*UpdateSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Message Сообщение необходимое для вывода пользователю
				Message *string `json:"message,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateStageProgressResponse parses an HTTP response from a UpdateStageProgressWithResponse call
func ParseUpdateStageProgressResponse(rsp *http.Response) (*UpdateStageProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStageProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// TrackId Идентификатор созданного трека
				TrackId *int `json:"trackId,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadCoverResponse parses an HTTP response from a UploadCoverWithResponse call
func ParseUploadCoverResponse(rsp *http.Response) (*UploadCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Массив с данными
			Response *struct {
				// Src Ссылка на загруженную обложку
				Src *string `json:"src,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadLogResponse parses an HTTP response from a UploadLogWithResponse call
func ParseUploadLogResponse(rsp *http.Response) (*UploadLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadPortfolioFileResponse parses an HTTP response from a UploadPortfolioFileWithResponse call
func ParseUploadPortfolioFileResponse(rsp *http.Response) (*UploadPortfolioFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadPortfolioFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]struct {
				// Hash ИД хеша
				Hash *int `json:"hash,omitempty"`

				// Id ИД файла
				Id *int `json:"id,omitempty"`

				// Path Путь к файлу
				Path *string `json:"path,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadedFileResponse parses an HTTP response from a UploadedFileWithResponse call
func ParseUploadedFileResponse(rsp *http.Response) (*UploadedFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadedFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserResponse parses an HTTP response from a UserWithResponse call
func ParseUserResponse(rsp *http.Response) (*UserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Публичные данные пользователя
			Response *User `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserByUsernameResponse parses an HTTP response from a UserByUsernameWithResponse call
func ParseUserByUsernameResponse(rsp *http.Response) (*UserByUsernameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserByUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Публичные данные пользователя
			Response *User `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserKworksResponse parses an HTTP response from a UserKworksWithResponse call
func ParseUserKworksResponse(rsp *http.Response) (*UserKworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserKworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Кворки пользователя
			Response *ProfileKworksWithWorkerLevel `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserReviewsResponse parses an HTTP response from a UserReviewsWithResponse call
func ParseUserReviewsResponse(rsp *http.Response) (*UserReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]UserReview `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserSearchResponse parses an HTTP response from a UserSearchWithResponse call
func ParseUserSearchResponse(rsp *http.Response) (*UserSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Найденные пользователи
			Response *[]UserWorker `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseVerifyPhoneActivationCodeResponse parses an HTTP response from a VerifyPhoneActivationCodeWithResponse call
func ParseVerifyPhoneActivationCodeResponse(rsp *http.Response) (*VerifyPhoneActivationCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyPhoneActivationCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Phone Телефон под маской *** который был добавлен в аккаунт
				Phone *string `json:"phone,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseVerifySmsCodeForAccountDeletingResponse parses an HTTP response from a VerifySmsCodeForAccountDeletingWithResponse call
func ParseVerifySmsCodeForAccountDeletingResponse(rsp *http.Response) (*VerifySmsCodeForAccountDeletingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifySmsCodeForAccountDeletingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// ConfirmationType Тип отправления кода подтверждения, sms/email/deleted
				ConfirmationType *string `json:"confirmation_type,omitempty"`

				// Orders Массив заказов если они есть
				Orders *[]struct {
					// Id ID заказа
					Id *int `json:"id,omitempty"`

					// Name Название
					Name *string `json:"name,omitempty"`
				} `json:"orders,omitempty"`

				// Timeout Время задержки перед следующей попыткой в секундах
				Timeout *int `json:"timeout,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseViewedCatalogKworksResponse parses an HTTP response from a ViewedCatalogKworksWithResponse call
func ParseViewedCatalogKworksResponse(rsp *http.Response) (*ViewedCatalogKworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ViewedCatalogKworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Paging Данные пагинации с лимитом
			Paging *PagingWithPages `json:"paging,omitempty"`

			// Response Кворки пользователя
			Response *ProfileKworks `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseVoiceUploadResponse parses an HTTP response from a VoiceUploadWithResponse call
func ParseVoiceUploadResponse(rsp *http.Response) (*VoiceUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VoiceUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// FileId ИД файла
				FileId *int `json:"fileId,omitempty"`

				// Path Путь до файла
				Path *string `json:"path,omitempty"`

				// VoiceMessageId ИД голосового сообщения
				VoiceMessageId *string `json:"voiceMessageId,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWantResponse parses an HTTP response from a WantWithResponse call
func ParseWantResponse(rsp *http.Response) (*WantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]WantPayer `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWantsStatusListResponse parses an HTTP response from a WantsStatusListWithResponse call
func ParseWantsStatusListResponse(rsp *http.Response) (*WantsStatusListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WantsStatusListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *[]WantsList `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWorkerConfirmsExtraRemovalRequestResponse parses an HTTP response from a WorkerConfirmsExtraRemovalRequestWithResponse call
func ParseWorkerConfirmsExtraRemovalRequestResponse(rsp *http.Response) (*WorkerConfirmsExtraRemovalRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerConfirmsExtraRemovalRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWorkerDeclineExtrasResponse parses an HTTP response from a WorkerDeclineExtrasWithResponse call
func ParseWorkerDeclineExtrasResponse(rsp *http.Response) (*WorkerDeclineExtrasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerDeclineExtrasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWorkerDeclinesExtraRemovalRequestResponse parses an HTTP response from a WorkerDeclinesExtraRemovalRequestWithResponse call
func ParseWorkerDeclinesExtraRemovalRequestResponse(rsp *http.Response) (*WorkerDeclinesExtraRemovalRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerDeclinesExtraRemovalRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWorkerExtraDeleteResponse parses an HTTP response from a WorkerExtraDeleteWithResponse call
func ParseWorkerExtraDeleteResponse(rsp *http.Response) (*WorkerExtraDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerExtraDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWorkerInprogressResponse parses an HTTP response from a WorkerInprogressWithResponse call
func ParseWorkerInprogressResponse(rsp *http.Response) (*WorkerInprogressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerInprogressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Success
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWorkerOrdersResponse parses an HTTP response from a WorkerOrdersWithResponse call
func ParseWorkerOrdersResponse(rsp *http.Response) (*WorkerOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Данные
			Response *struct {
				// Filter Выбранный фильтр
				Filter *string `json:"filter,omitempty"`

				// FilterCounts Объект количеств по статусам
				FilterCounts *struct {
					// Active Количество заказов по фильтру active
					Active *int `json:"active,omitempty"`

					// All Общее количество заказов
					All *string `json:"all,omitempty"`

					// AwaitingReceipt Количество заказов по фильтру awaiting_receipt
					AwaitingReceipt *int `json:"awaiting_receipt,omitempty"`

					// Cancelled Количество заказов по фильтру cancelled
					Cancelled *int `json:"cancelled,omitempty"`

					// Completed Количество заказов по фильтру completed
					Completed *int `json:"completed,omitempty"`

					// Delivered Количество заказов по фильтру delivered
					Delivered *int `json:"delivered,omitempty"`
				} `json:"filter_counts,omitempty"`

				// Orders Массив объектов - заказов
				Orders *struct {
					// CanAddPortfolio Можно загрузить портфолио к заказу
					CanAddPortfolio *bool `json:"can_add_portfolio,omitempty"`

					// CanсelReason Причина отмены заказа
					CanсelReason *string `json:"canсel_reason,omitempty"`

					// Deadline Дата сдачи заказа в UNIXTIME
					Deadline *int `json:"deadline,omitempty"`

					// DisplayTitle Пользовательское название заказа
					DisplayTitle *string `json:"display_title,omitempty"`

					// Duration Время выполнения заказа в секундах
					Duration *int `json:"duration,omitempty"`

					// HasCompletedStages Есть ли выполненные этапы
					HasCompletedStages *bool `json:"has_completed_stages,omitempty"`

					// HasStages Содержит ли заказ этапы
					HasStages *bool `json:"has_stages,omitempty"`

					// Id Идентификатор заказа
					Id *int `json:"id,omitempty"`

					// InWork Взят в работу
					InWork *bool `json:"in_work,omitempty"`

					// IsCancelRequest Заказ в состоянии запроса отмены (показывать сколько времени осталось на выполнение не нужно) Только для заказов в статусе 1 - В работе
					IsCancelRequest *bool `json:"is_cancel_request,omitempty"`

					// KworkTitle Название кворка
					KworkTitle *string `json:"kwork_title,omitempty"`

					// OrderNote Заметка о заказе
					OrderNote *string `json:"order_note,omitempty"`

					// Payer Объект данных заказчика
					Payer *struct {
						// Id Идентификатор
						Id *int `json:"id,omitempty"`

						// IsOnline Онлайн ли пользователь
						IsOnline *bool `json:"is_online,omitempty"`

						// Profilepicture Ссылка на изображение аватара
						Profilepicture *string `json:"profilepicture,omitempty"`

						// Username Имя пользователя
						Username *string `json:"username,omitempty"`
					} `json:"payer,omitempty"`

					// PaymentType Тип заказа: 0 - физлицо, 1 - подписка, 2 - эскроу
					PaymentType *int `json:"payment_type,omitempty"`

					// Photo Путь к обложке кворка
					Photo *string `json:"photo,omitempty"`

					// Price Цена
					Price *float32 `json:"price,omitempty"`

					// Progress Прогресс выполнения работ по заказу
					Progress *int `json:"progress,omitempty"`

					// Project Запрос
					Project *string `json:"project,omitempty"`

					// StagesPrice Цена за все этапы
					StagesPrice *float32 `json:"stages_price,omitempty"`

					// Status Статус заказа 	1 - В работе, 2 - Арбитраж, 3 - Отменен, 4 - На проверке, 5 - Выполнен, 6 - Требуется оплата
					Status *int `json:"status,omitempty"`

					// StatusVirtual Виртуальный статус
					StatusVirtual *int `json:"statusVirtual,omitempty"`

					// TimeAdded Дата заказа UNIXTIME
					TimeAdded *int `json:"time_added,omitempty"`

					// TimeCanсel Дата отмены заказа UNIXTIME
					TimeCanсel *int `json:"time_canсel,omitempty"`

					// TimeIsLost 1 - остался час, чтобы взять заказ в работу, так как прошло 23 часа с момента оплаты, 0 - осталось более часа, чтобы взять заказ, так как прошло менее 23 часа с момента оплаты, 1 - все остальные заказы, которые не требуется брать в работу. -2 - заказ не сдан вовремя
					TimeIsLost *int `json:"time_is_lost,omitempty"`

					// TimeLeft Осталось времени, значимо только для заказов в статусе 1 - В работе (Если пусто - Время вышло, 	Если in_work = 1 - Осталось на выполнение заказа, Если in_work = 0 - Осталось до автоотмены заказа)
					TimeLeft *string `json:"time_left,omitempty"`

					// UnreadTracks Количество непрочитанных сообщений в заказе
					UnreadTracks *int `json:"unread_tracks,omitempty"`
				} `json:"orders,omitempty"`

				// Paging Объект данных пагинации
				Paging *struct {
					// Limit Количество элементов на странице
					Limit *int `json:"limit,omitempty"`

					// Page Текущая страница
					Page *int `json:"page,omitempty"`

					// Total Общее количество заказов по текущему фильтру
					Total *int `json:"total,omitempty"`
				} `json:"paging,omitempty"`
			} `json:"response,omitempty"`

			// Success Флаг успешности
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
